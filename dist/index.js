import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "module";
/******/ var __webpack_modules__ = {
  /***/ 7351: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    var __createBinding =
      (this && this.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (this && this.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null)
          for (var k in mod)
            if (k !== "default" && Object.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.issue = exports.issueCommand = void 0;
    const os = __importStar(__nccwpck_require__(2037));
    const utils_1 = __nccwpck_require__(5278);
    /**
     * Commands
     *
     * Command Format:
     *   ::name key=value,key=value::message
     *
     * Examples:
     *   ::warning::This is the message
     *   ::set-env name=MY_VAR::some value
     */
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports.issue = issue;
    const CMD_STRING = "::";
    class Command {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    }
    function escapeData(s) {
      return utils_1
        .toCommandValue(s)
        .replace(/%/g, "%25")
        .replace(/\r/g, "%0D")
        .replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return utils_1
        .toCommandValue(s)
        .replace(/%/g, "%25")
        .replace(/\r/g, "%0D")
        .replace(/\n/g, "%0A")
        .replace(/:/g, "%3A")
        .replace(/,/g, "%2C");
    }
    //# sourceMappingURL=command.js.map

    /***/
  },

  /***/ 2186: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    var __createBinding =
      (this && this.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (this && this.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null)
          for (var k in mod)
            if (k !== "default" && Object.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
    var __awaiter =
      (this && this.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIDToken =
      exports.getState =
      exports.saveState =
      exports.group =
      exports.endGroup =
      exports.startGroup =
      exports.info =
      exports.notice =
      exports.warning =
      exports.error =
      exports.debug =
      exports.isDebug =
      exports.setFailed =
      exports.setCommandEcho =
      exports.setOutput =
      exports.getBooleanInput =
      exports.getMultilineInput =
      exports.getInput =
      exports.addPath =
      exports.setSecret =
      exports.exportVariable =
      exports.ExitCode =
        void 0;
    const command_1 = __nccwpck_require__(7351);
    const file_command_1 = __nccwpck_require__(717);
    const utils_1 = __nccwpck_require__(5278);
    const os = __importStar(__nccwpck_require__(2037));
    const path = __importStar(__nccwpck_require__(1017));
    const oidc_utils_1 = __nccwpck_require__(8041);
    /**
     * The code to exit an action
     */
    var ExitCode;
    (function (ExitCode) {
      /**
       * A code indicating that the action was successful
       */
      ExitCode[(ExitCode["Success"] = 0)] = "Success";
      /**
       * A code indicating that the action was a failure
       */
      ExitCode[(ExitCode["Failure"] = 1)] = "Failure";
    })((ExitCode = exports.ExitCode || (exports.ExitCode = {})));
    //-----------------------------------------------------------------------
    // Variables
    //-----------------------------------------------------------------------
    /**
     * Sets env variable for this action and future actions in the job
     * @param name the name of the variable to set
     * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand(
          "ENV",
          file_command_1.prepareKeyValueMessage(name, val)
        );
      }
      command_1.issueCommand("set-env", { name }, convertedVal);
    }
    exports.exportVariable = exportVariable;
    /**
     * Registers a secret which will get masked from logs
     * @param secret value of the secret
     */
    function setSecret(secret) {
      command_1.issueCommand("add-mask", {}, secret);
    }
    exports.setSecret = setSecret;
    /**
     * Prepends inputPath to the PATH (for this action and future actions)
     * @param inputPath
     */
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        file_command_1.issueFileCommand("PATH", inputPath);
      } else {
        command_1.issueCommand("add-path", {}, inputPath);
      }
      process.env["PATH"] =
        `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    /**
     * Gets the value of an input.
     * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
     * Returns an empty string if the value is not defined.
     *
     * @param     name     name of the input to get
     * @param     options  optional. See InputOptions.
     * @returns   string
     */
    function getInput(name, options) {
      const val =
        process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput;
    /**
     * Gets the values of an multiline input.  Each value is also trimmed.
     *
     * @param     name     name of the input to get
     * @param     options  optional. See InputOptions.
     * @returns   string[]
     *
     */
    function getMultilineInput(name, options) {
      const inputs = getInput(name, options)
        .split("\n")
        .filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput;
    /**
     * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
     * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
     * The return value is also in boolean type.
     * ref: https://yaml.org/spec/1.2/spec.html#id2804923
     *
     * @param     name     name of the input to get
     * @param     options  optional. See InputOptions.
     * @returns   boolean
     */
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput(name, options);
      if (trueValue.includes(val)) return true;
      if (falseValue.includes(val)) return false;
      throw new TypeError(
        `Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
          `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``
      );
    }
    exports.getBooleanInput = getBooleanInput;
    /**
     * Sets the value of an output.
     *
     * @param     name     name of the output to set
     * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand(
          "OUTPUT",
          file_command_1.prepareKeyValueMessage(name, value)
        );
      }
      process.stdout.write(os.EOL);
      command_1.issueCommand(
        "set-output",
        { name },
        utils_1.toCommandValue(value)
      );
    }
    exports.setOutput = setOutput;
    /**
     * Enables or disables the echoing of commands into stdout for the rest of the step.
     * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
     *
     */
    function setCommandEcho(enabled) {
      command_1.issue("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    //-----------------------------------------------------------------------
    // Results
    //-----------------------------------------------------------------------
    /**
     * Sets the action status to failed.
     * When the action exits it will be with an exit code of 1
     * @param message add error issue message
     */
    function setFailed(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports.setFailed = setFailed;
    //-----------------------------------------------------------------------
    // Logging Commands
    //-----------------------------------------------------------------------
    /**
     * Gets whether Actions Step Debug is on or not
     */
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    /**
     * Writes debug message to user log
     * @param message debug message
     */
    function debug(message) {
      command_1.issueCommand("debug", {}, message);
    }
    exports.debug = debug;
    /**
     * Adds an error issue
     * @param message error issue message. Errors will be converted to string via toString()
     * @param properties optional properties to add to the annotation.
     */
    function error(message, properties = {}) {
      command_1.issueCommand(
        "error",
        utils_1.toCommandProperties(properties),
        message instanceof Error ? message.toString() : message
      );
    }
    exports.error = error;
    /**
     * Adds a warning issue
     * @param message warning issue message. Errors will be converted to string via toString()
     * @param properties optional properties to add to the annotation.
     */
    function warning(message, properties = {}) {
      command_1.issueCommand(
        "warning",
        utils_1.toCommandProperties(properties),
        message instanceof Error ? message.toString() : message
      );
    }
    exports.warning = warning;
    /**
     * Adds a notice issue
     * @param message notice issue message. Errors will be converted to string via toString()
     * @param properties optional properties to add to the annotation.
     */
    function notice(message, properties = {}) {
      command_1.issueCommand(
        "notice",
        utils_1.toCommandProperties(properties),
        message instanceof Error ? message.toString() : message
      );
    }
    exports.notice = notice;
    /**
     * Writes info to log with console.log.
     * @param message info message
     */
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports.info = info;
    /**
     * Begin an output group.
     *
     * Output until the next `groupEnd` will be foldable in this group
     *
     * @param name The name of the output group
     */
    function startGroup(name) {
      command_1.issue("group", name);
    }
    exports.startGroup = startGroup;
    /**
     * End an output group.
     */
    function endGroup() {
      command_1.issue("endgroup");
    }
    exports.endGroup = endGroup;
    /**
     * Wrap an asynchronous function call in a group.
     *
     * Returns the same type as the function itself.
     *
     * @param name The name of the group
     * @param fn The function to wrap in the group
     */
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports.group = group;
    //-----------------------------------------------------------------------
    // Wrapper action state
    //-----------------------------------------------------------------------
    /**
     * Saves state for current action, the state can only be retrieved by this action's post job execution.
     *
     * @param     name     name of the state to store
     * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand(
          "STATE",
          file_command_1.prepareKeyValueMessage(name, value)
        );
      }
      command_1.issueCommand(
        "save-state",
        { name },
        utils_1.toCommandValue(value)
      );
    }
    exports.saveState = saveState;
    /**
     * Gets the value of an state set by this action's main execution.
     *
     * @param     name     name of the state to get
     * @returns   string
     */
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    /**
     * Summary exports
     */
    var summary_1 = __nccwpck_require__(1327);
    Object.defineProperty(exports, "summary", {
      enumerable: true,
      get: function () {
        return summary_1.summary;
      },
    });
    /**
     * @deprecated use core.summary
     */
    var summary_2 = __nccwpck_require__(1327);
    Object.defineProperty(exports, "markdownSummary", {
      enumerable: true,
      get: function () {
        return summary_2.markdownSummary;
      },
    });
    /**
     * Path exports
     */
    var path_utils_1 = __nccwpck_require__(2981);
    Object.defineProperty(exports, "toPosixPath", {
      enumerable: true,
      get: function () {
        return path_utils_1.toPosixPath;
      },
    });
    Object.defineProperty(exports, "toWin32Path", {
      enumerable: true,
      get: function () {
        return path_utils_1.toWin32Path;
      },
    });
    Object.defineProperty(exports, "toPlatformPath", {
      enumerable: true,
      get: function () {
        return path_utils_1.toPlatformPath;
      },
    });
    //# sourceMappingURL=core.js.map

    /***/
  },

  /***/ 717: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    // For internal use, subject to change.
    var __createBinding =
      (this && this.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (this && this.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null)
          for (var k in mod)
            if (k !== "default" && Object.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
    // We use any as a valid input type
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const fs = __importStar(__nccwpck_require__(7147));
    const os = __importStar(__nccwpck_require__(2037));
    const uuid_1 = __nccwpck_require__(5840);
    const utils_1 = __nccwpck_require__(5278);
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(
          `Unable to find environment variable for file command ${command}`
        );
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(
        filePath,
        `${utils_1.toCommandValue(message)}${os.EOL}`,
        {
          encoding: "utf8",
        }
      );
    }
    exports.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${uuid_1.v4()}`;
      const convertedValue = utils_1.toCommandValue(value);
      // These should realistically never happen, but just in case someone finds a
      // way to exploit uuid generation let's not allow keys or values that contain
      // the delimiter.
      if (key.includes(delimiter)) {
        throw new Error(
          `Unexpected input: name should not contain the delimiter "${delimiter}"`
        );
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(
          `Unexpected input: value should not contain the delimiter "${delimiter}"`
        );
      }
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports.prepareKeyValueMessage = prepareKeyValueMessage;
    //# sourceMappingURL=file-command.js.map

    /***/
  },

  /***/ 8041: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    var __awaiter =
      (this && this.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OidcClient = void 0;
    const http_client_1 = __nccwpck_require__(6255);
    const auth_1 = __nccwpck_require__(5526);
    const core_1 = __nccwpck_require__(2186);
    class OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry,
        };
        return new http_client_1.HttpClient(
          "actions/oidc-client",
          [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())],
          requestOptions
        );
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error(
            "Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable"
          );
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error(
            "Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable"
          );
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
          });
          const id_token =
            (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            // New ID Token is requested from action service
            let id_token_url = OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            core_1.debug(`ID token url is ${id_token_url}`);
            const id_token = yield OidcClient.getCall(id_token_url);
            core_1.setSecret(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    }
    exports.OidcClient = OidcClient;
    //# sourceMappingURL=oidc-utils.js.map

    /***/
  },

  /***/ 2981: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    var __createBinding =
      (this && this.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (this && this.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null)
          for (var k in mod)
            if (k !== "default" && Object.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
    const path = __importStar(__nccwpck_require__(1017));
    /**
     * toPosixPath converts the given path to the posix form. On Windows, \\ will be
     * replaced with /.
     *
     * @param pth. Path to transform.
     * @return string Posix path.
     */
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports.toPosixPath = toPosixPath;
    /**
     * toWin32Path converts the given path to the win32 form. On Linux, / will be
     * replaced with \\.
     *
     * @param pth. Path to transform.
     * @return string Win32 path.
     */
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports.toWin32Path = toWin32Path;
    /**
     * toPlatformPath converts the given path to a platform-specific path. It does
     * this by replacing instances of / and \ with the platform-specific path
     * separator.
     *
     * @param pth The path to platformize.
     * @return string The platform-specific path.
     */
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports.toPlatformPath = toPlatformPath;
    //# sourceMappingURL=path-utils.js.map

    /***/
  },

  /***/ 1327: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    var __awaiter =
      (this && this.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.summary =
      exports.markdownSummary =
      exports.SUMMARY_DOCS_URL =
      exports.SUMMARY_ENV_VAR =
        void 0;
    const os_1 = __nccwpck_require__(2037);
    const fs_1 = __nccwpck_require__(7147);
    const { access, appendFile, writeFile } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports.SUMMARY_DOCS_URL =
      "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    class Summary {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(
              `Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`
            );
          }
          try {
            yield access(
              pathFromEnv,
              fs_1.constants.R_OK | fs_1.constants.W_OK
            );
          } catch (_a) {
            throw new Error(
              `Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`
            );
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
          .map(([key, value]) => ` ${key}="${value}"`)
          .join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0
            ? void 0
            : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows
          .map((row) => {
            const cells = row
              .map((cell) => {
                if (typeof cell === "string") {
                  return this.wrap("td", cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? "th" : "td";
                const attrs = Object.assign(
                  Object.assign({}, colspan && { colspan }),
                  rowspan && { rowspan }
                );
                return this.wrap(tag, data, attrs);
              })
              .join("");
            return this.wrap("tr", cells);
          })
          .join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap(
          "details",
          this.wrap("summary", label) + content
        );
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(
          Object.assign({}, width && { width }),
          height && { height }
        );
        const element = this.wrap(
          "img",
          null,
          Object.assign({ src, alt }, attrs)
        );
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag)
          ? tag
          : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    }
    const _summary = new Summary();
    /**
     * @deprecated use `core.summary`
     */
    exports.markdownSummary = _summary;
    exports.summary = _summary;
    //# sourceMappingURL=summary.js.map

    /***/
  },

  /***/ 5278: /***/ (__unused_webpack_module, exports) => {
    // We use any as a valid input type
    /* eslint-disable @typescript-eslint/no-explicit-any */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCommandProperties = exports.toCommandValue = void 0;
    /**
     * Sanitizes an input into a string so it can be passed into issueCommand safely
     * @param input input to sanitize into a string
     */
    function toCommandValue(input) {
      if (input === null || input === undefined) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
    /**
     *
     * @param annotationProperties
     * @returns The command properties to send with the actual annotation command
     * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
     */
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn,
      };
    }
    exports.toCommandProperties = toCommandProperties;
    //# sourceMappingURL=utils.js.map

    /***/
  },

  /***/ 5526: /***/ function (__unused_webpack_module, exports) {
    var __awaiter =
      (this && this.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PersonalAccessTokenCredentialHandler =
      exports.BearerCredentialHandler =
      exports.BasicCredentialHandler =
        void 0;
    class BasicCredentialHandler {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] =
          `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    }
    exports.BasicCredentialHandler = BasicCredentialHandler;
    class BearerCredentialHandler {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    }
    exports.BearerCredentialHandler = BearerCredentialHandler;
    class PersonalAccessTokenCredentialHandler {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] =
          `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    }
    exports.PersonalAccessTokenCredentialHandler =
      PersonalAccessTokenCredentialHandler;
    //# sourceMappingURL=auth.js.map

    /***/
  },

  /***/ 6255: /***/ function (
    __unused_webpack_module,
    exports,
    __nccwpck_require__
  ) {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    var __createBinding =
      (this && this.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (this && this.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null)
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
    var __awaiter =
      (this && this.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient =
      exports.isHttps =
      exports.HttpClientResponse =
      exports.HttpClientError =
      exports.getProxyUrl =
      exports.MediaTypes =
      exports.Headers =
      exports.HttpCodes =
        void 0;
    const http = __importStar(__nccwpck_require__(3685));
    const https = __importStar(__nccwpck_require__(5687));
    const pm = __importStar(__nccwpck_require__(9835));
    const tunnel = __importStar(__nccwpck_require__(4294));
    const undici_1 = __nccwpck_require__(1773);
    var HttpCodes;
    (function (HttpCodes) {
      HttpCodes[(HttpCodes["OK"] = 200)] = "OK";
      HttpCodes[(HttpCodes["MultipleChoices"] = 300)] = "MultipleChoices";
      HttpCodes[(HttpCodes["MovedPermanently"] = 301)] = "MovedPermanently";
      HttpCodes[(HttpCodes["ResourceMoved"] = 302)] = "ResourceMoved";
      HttpCodes[(HttpCodes["SeeOther"] = 303)] = "SeeOther";
      HttpCodes[(HttpCodes["NotModified"] = 304)] = "NotModified";
      HttpCodes[(HttpCodes["UseProxy"] = 305)] = "UseProxy";
      HttpCodes[(HttpCodes["SwitchProxy"] = 306)] = "SwitchProxy";
      HttpCodes[(HttpCodes["TemporaryRedirect"] = 307)] = "TemporaryRedirect";
      HttpCodes[(HttpCodes["PermanentRedirect"] = 308)] = "PermanentRedirect";
      HttpCodes[(HttpCodes["BadRequest"] = 400)] = "BadRequest";
      HttpCodes[(HttpCodes["Unauthorized"] = 401)] = "Unauthorized";
      HttpCodes[(HttpCodes["PaymentRequired"] = 402)] = "PaymentRequired";
      HttpCodes[(HttpCodes["Forbidden"] = 403)] = "Forbidden";
      HttpCodes[(HttpCodes["NotFound"] = 404)] = "NotFound";
      HttpCodes[(HttpCodes["MethodNotAllowed"] = 405)] = "MethodNotAllowed";
      HttpCodes[(HttpCodes["NotAcceptable"] = 406)] = "NotAcceptable";
      HttpCodes[(HttpCodes["ProxyAuthenticationRequired"] = 407)] =
        "ProxyAuthenticationRequired";
      HttpCodes[(HttpCodes["RequestTimeout"] = 408)] = "RequestTimeout";
      HttpCodes[(HttpCodes["Conflict"] = 409)] = "Conflict";
      HttpCodes[(HttpCodes["Gone"] = 410)] = "Gone";
      HttpCodes[(HttpCodes["TooManyRequests"] = 429)] = "TooManyRequests";
      HttpCodes[(HttpCodes["InternalServerError"] = 500)] =
        "InternalServerError";
      HttpCodes[(HttpCodes["NotImplemented"] = 501)] = "NotImplemented";
      HttpCodes[(HttpCodes["BadGateway"] = 502)] = "BadGateway";
      HttpCodes[(HttpCodes["ServiceUnavailable"] = 503)] = "ServiceUnavailable";
      HttpCodes[(HttpCodes["GatewayTimeout"] = 504)] = "GatewayTimeout";
    })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
    var Headers;
    (function (Headers) {
      Headers["Accept"] = "accept";
      Headers["ContentType"] = "content-type";
    })(Headers || (exports.Headers = Headers = {}));
    var MediaTypes;
    (function (MediaTypes) {
      MediaTypes["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
    /**
     * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports.getProxyUrl = getProxyUrl;
    const HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect,
    ];
    const HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout,
    ];
    const RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    const ExponentialBackoffCeiling = 10;
    const ExponentialBackoffTimeSlice = 5;
    class HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
      }
    }
    exports.HttpClientError = HttpClientError;
    class HttpClientResponse {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) =>
            __awaiter(this, void 0, void 0, function* () {
              let output = Buffer.alloc(0);
              this.message.on("data", (chunk) => {
                output = Buffer.concat([output, chunk]);
              });
              this.message.on("end", () => {
                resolve(output.toString());
              });
            })
          );
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) =>
            __awaiter(this, void 0, void 0, function* () {
              const chunks = [];
              this.message.on("data", (chunk) => {
                chunks.push(chunk);
              });
              this.message.on("end", () => {
                resolve(Buffer.concat(chunks));
              });
            })
          );
        });
      }
    }
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports.isHttps = isHttps;
    class HttpClient {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade =
              requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(
            "OPTIONS",
            requestUrl,
            null,
            additionalHeaders || {}
          );
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(
            "DELETE",
            requestUrl,
            null,
            additionalHeaders || {}
          );
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(
            "POST",
            requestUrl,
            data,
            additionalHeaders || {}
          );
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(
            "PATCH",
            requestUrl,
            data,
            additionalHeaders || {}
          );
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(
            "HEAD",
            requestUrl,
            null,
            additionalHeaders || {}
          );
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          additionalHeaders[Headers.ContentType] =
            this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.ContentType,
              MediaTypes.ApplicationJson
            );
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          additionalHeaders[Headers.ContentType] =
            this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.ContentType,
              MediaTypes.ApplicationJson
            );
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          additionalHeaders[Headers.ContentType] =
            this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.ContentType,
              MediaTypes.ApplicationJson
            );
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          // Only perform retries on reads since writes may not be idempotent.
          const maxTries =
            this._allowRetries && RetryableHttpVerbs.includes(verb)
              ? this._maxRetries + 1
              : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            // Check if it's an authentication challenge
            if (
              response &&
              response.message &&
              response.message.statusCode === HttpCodes.Unauthorized
            ) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(
                  this,
                  info,
                  data
                );
              } else {
                // We have received an unauthorized response but have no handlers to handle it.
                // Let the response return to the caller.
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (
              response.message.statusCode &&
              HttpRedirectCodes.includes(response.message.statusCode) &&
              this._allowRedirects &&
              redirectsRemaining > 0
            ) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                // if there's no location to redirect to, we won't
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (
                parsedUrl.protocol === "https:" &&
                parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                !this._allowRedirectDowngrade
              ) {
                throw new Error(
                  "Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true."
                );
              }
              // we need to finish reading the response before reassigning response
              // which will leak the open socket.
              yield response.readBody();
              // strip authorization header if redirected to a different hostname
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  // header names are case insensitive
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              // let's make the request with the new redirectUrl
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (
              !response.message.statusCode ||
              !HttpResponseRetryCodes.includes(response.message.statusCode)
            ) {
              // If not a retry code, return immediately instead of retrying
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                // If `err` is not passed, then `res` must be passed.
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(
            data,
            "utf8"
          );
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(undefined, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function (err) {
          // err has statusCode property
          // res should have headers
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function () {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
          ? parseInt(info.parsedUrl.port)
          : defaultPort;
        info.options.path =
          (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign(
            {},
            lowercaseKeys(this.requestOptions.headers),
            lowercaseKeys(headers || {})
          );
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets =
            this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(
              Object.assign(
                {},
                (proxyUrl.username || proxyUrl.password) && {
                  proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
                }
              ),
              { host: proxyUrl.hostname, port: proxyUrl.port }
            ),
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps
              ? tunnel.httpsOverHttps
              : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps
              ? tunnel.httpOverHttps
              : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        // if tunneling agent isn't assigned create a new agent
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
          // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
          // we have to cast it to any and change it directly
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false,
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        // if agent is already assigned use that agent.
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(
          Object.assign(
            { uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 },
            (proxyUrl.username || proxyUrl.password) && {
              token: `${proxyUrl.username}:${proxyUrl.password}`,
            }
          )
        );
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
          // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
          // we have to cast it to any and change it directly
          proxyAgent.options = Object.assign(
            proxyAgent.options.requestTls || {},
            {
              rejectUnauthorized: false,
            }
          );
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) =>
            __awaiter(this, void 0, void 0, function* () {
              const statusCode = res.message.statusCode || 0;
              const response = {
                statusCode,
                result: null,
                headers: {},
              };
              // not found leads to null obj returned
              if (statusCode === HttpCodes.NotFound) {
                resolve(response);
              }
              // get the result from the body
              function dateTimeDeserializer(key, value) {
                if (typeof value === "string") {
                  const a = new Date(value);
                  if (!isNaN(a.valueOf())) {
                    return a;
                  }
                }
                return value;
              }
              let obj;
              let contents;
              try {
                contents = yield res.readBody();
                if (contents && contents.length > 0) {
                  if (options && options.deserializeDates) {
                    obj = JSON.parse(contents, dateTimeDeserializer);
                  } else {
                    obj = JSON.parse(contents);
                  }
                  response.result = obj;
                }
                response.headers = res.message.headers;
              } catch (err) {
                // Invalid resource (contents not json);  leaving result obj null
              }
              // note that 3xx redirects are handled by the http layer.
              if (statusCode > 299) {
                let msg;
                // if exception/error in body, attempt to get better error
                if (obj && obj.message) {
                  msg = obj.message;
                } else if (contents && contents.length > 0) {
                  // it may be the case that the exception is in the body message as string
                  msg = contents;
                } else {
                  msg = `Failed request: (${statusCode})`;
                }
                const err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
              } else {
                resolve(response);
              }
            })
          );
        });
      }
    }
    exports.HttpClient = HttpClient;
    const lowercaseKeys = (obj) =>
      Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
    //# sourceMappingURL=index.js.map

    /***/
  },

  /***/ 9835: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkBypass = exports.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return undefined;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new URL(proxyVar);
        } catch (_a) {
          if (
            !proxyVar.startsWith("http://") &&
            !proxyVar.startsWith("https://")
          )
            return new URL(`http://${proxyVar}`);
        }
      } else {
        return undefined;
      }
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      // Determine the request port
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      // Format the request hostname and hostname with port
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      // Compare request host against noproxy
      for (const upperNoProxyItem of noProxy
        .split(",")
        .map((x) => x.trim().toUpperCase())
        .filter((x) => x)) {
        if (
          upperNoProxyItem === "*" ||
          upperReqHosts.some(
            (x) =>
              x === upperNoProxyItem ||
              x.endsWith(`.${upperNoProxyItem}`) ||
              (upperNoProxyItem.startsWith(".") &&
                x.endsWith(`${upperNoProxyItem}`))
          )
        ) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return (
        hostLower === "localhost" ||
        hostLower.startsWith("127.") ||
        hostLower.startsWith("[::1]") ||
        hostLower.startsWith("[0:0:0:0:0:0:0:1]")
      );
    }
    //# sourceMappingURL=proxy.js.map

    /***/
  },

  /***/ 2199: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const mkdirsSync = __nccwpck_require__(4666).mkdirsSync;
    const utimesMillisSync = __nccwpck_require__(6969).utimesMillisSync;
    const stat = __nccwpck_require__(8260);

    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }

      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true; // default to true for now
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

      // Warn about using preserveTimestamps on 32-bit node
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" +
            "\tsee https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }

      const { srcStat, destStat } = stat.checkPathsSync(
        src,
        dest,
        "copy",
        opts
      );
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path.dirname(dest);
      if (!fs.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }

    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
      const srcStat = statSync(src);

      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (
        srcStat.isFile() ||
        srcStat.isCharacterDevice() ||
        srcStat.isBlockDevice()
      )
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }

    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }

    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }

    function copyFile(srcStat, src, dest, opts) {
      fs.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }

    function handleTimestamps(srcMode, src, dest) {
      // Make sure the file is writable before setting the timestamp
      // otherwise open fails with EPERM when invoked with 'r+'
      // (through utimes call)
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }

    function fileIsNotWritable(srcMode) {
      return (srcMode & 0o200) === 0;
    }

    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 0o200);
    }

    function setDestMode(dest, srcMode) {
      return fs.chmodSync(dest, srcMode);
    }

    function setDestTimestamps(src, dest) {
      // The initial srcStat.atime cannot be trusted
      // because it is modified by the read(2) system call
      // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
      const updatedSrcStat = fs.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }

    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }

    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }

    function copyDir(src, dest, opts) {
      fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }

    function copyDirItem(item, src, dest, opts) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }

    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }

      if (!destStat) {
        return fs.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs.readlinkSync(dest);
        } catch (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(
            `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
          );
        }

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(
            `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
          );
        }
        return copyLink(resolvedSrc, dest);
      }
    }

    function copyLink(resolvedSrc, dest) {
      fs.unlinkSync(dest);
      return fs.symlinkSync(resolvedSrc, dest);
    }

    module.exports = copySync;

    /***/
  },

  /***/ 9205: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const mkdirs = __nccwpck_require__(4666).mkdirs;
    const pathExists = __nccwpck_require__(7237).pathExists;
    const utimesMillis = __nccwpck_require__(6969).utimesMillis;
    const stat = __nccwpck_require__(8260);

    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }

      cb = cb || function () {};
      opts = opts || {};

      opts.clobber = "clobber" in opts ? !!opts.clobber : true; // default to true for now
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

      // Warn about using preserveTimestamps on 32-bit node
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" +
            "\tsee https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }

      stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err) return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err) => {
          if (err) return cb(err);
          runFilter(src, dest, opts, (err, include) => {
            if (err) return cb(err);
            if (!include) return cb();

            checkParentDir(destStat, src, dest, opts, cb);
          });
        });
      });
    }

    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err) return cb(err);
        if (dirExists) return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err) => {
          if (err) return cb(err);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }

    function runFilter(src, dest, opts, cb) {
      if (!opts.filter) return cb(null, true);
      Promise.resolve(opts.filter(src, dest)).then(
        (include) => cb(null, include),
        (error) => cb(error)
      );
    }

    function getStats(destStat, src, dest, opts, cb) {
      const stat = opts.dereference ? fs.stat : fs.lstat;
      stat(src, (err, srcStat) => {
        if (err) return cb(err);

        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (
          srcStat.isFile() ||
          srcStat.isCharacterDevice() ||
          srcStat.isBlockDevice()
        )
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }

    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }

    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs.unlink(dest, (err) => {
          if (err) return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else return cb();
    }

    function copyFile(srcStat, src, dest, opts, cb) {
      fs.copyFile(src, dest, (err) => {
        if (err) return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }

    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      // Make sure the file is writable before setting the timestamp
      // otherwise open fails with EPERM when invoked with 'r+'
      // (through utimes call)
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err) return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }

    function fileIsNotWritable(srcMode) {
      return (srcMode & 0o200) === 0;
    }

    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 0o200, cb);
    }

    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err) return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }

    function setDestMode(dest, srcMode, cb) {
      return fs.chmod(dest, srcMode, cb);
    }

    function setDestTimestamps(src, dest, cb) {
      // The initial srcStat.atime cannot be trusted
      // because it is modified by the read(2) system call
      // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
      fs.stat(src, (err, updatedSrcStat) => {
        if (err) return cb(err);
        return utimesMillis(
          dest,
          updatedSrcStat.atime,
          updatedSrcStat.mtime,
          cb
        );
      });
    }

    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }

    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs.mkdir(dest, (err) => {
        if (err) return cb(err);
        copyDir(src, dest, opts, (err) => {
          if (err) return cb(err);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }

    function copyDir(src, dest, opts, cb) {
      fs.readdir(src, (err, items) => {
        if (err) return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }

    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item) return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }

    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      runFilter(srcItem, destItem, opts, (err, include) => {
        if (err) return cb(err);
        if (!include) return copyDirItems(items, src, dest, opts, cb);

        stat.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
          if (err) return cb(err);
          const { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err) => {
            if (err) return cb(err);
            return copyDirItems(items, src, dest, opts, cb);
          });
        });
      });
    }

    function onLink(destStat, src, dest, opts, cb) {
      fs.readlink(src, (err, resolvedSrc) => {
        if (err) return cb(err);
        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
        }

        if (!destStat) {
          return fs.symlink(resolvedSrc, dest, cb);
        } else {
          fs.readlink(dest, (err, resolvedDest) => {
            if (err) {
              // dest exists and is a regular file or directory,
              // Windows may throw UNKNOWN error. If dest already exists,
              // fs throws error anyway, so no need to guard against it here.
              if (err.code === "EINVAL" || err.code === "UNKNOWN")
                return fs.symlink(resolvedSrc, dest, cb);
              return cb(err);
            }
            if (opts.dereference) {
              resolvedDest = path.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(
                new Error(
                  `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
                )
              );
            }

            // do not copy if src is a subdir of dest since unlinking
            // dest in this case would result in removing src contents
            // and therefore a broken symlink would be created.
            if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(
                new Error(
                  `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
                )
              );
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }

    function copyLink(resolvedSrc, dest, cb) {
      fs.unlink(dest, (err) => {
        if (err) return cb(err);
        return fs.symlink(resolvedSrc, dest, cb);
      });
    }

    module.exports = copy;

    /***/
  },

  /***/ 4144: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromCallback;
    module.exports = {
      copy: u(__nccwpck_require__(9205)),
      copySync: __nccwpck_require__(2199),
    };

    /***/
  },

  /***/ 7987: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const fs = __nccwpck_require__(2577);
    const path = __nccwpck_require__(1017);
    const mkdir = __nccwpck_require__(4666);
    const remove = __nccwpck_require__(806);

    const emptyDir = u(async function emptyDir(dir) {
      let items;
      try {
        items = await fs.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }

      return Promise.all(
        items.map((item) => remove.remove(path.join(dir, item)))
      );
    });

    function emptyDirSync(dir) {
      let items;
      try {
        items = fs.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }

      items.forEach((item) => {
        item = path.join(dir, item);
        remove.removeSync(item);
      });
    }

    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir,
    };

    /***/
  },

  /***/ 9606: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromCallback;
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(7758);
    const mkdir = __nccwpck_require__(4666);

    function createFile(file, callback) {
      function makeFile() {
        fs.writeFile(file, "", (err) => {
          if (err) return callback(err);
          callback();
        });
      }

      fs.stat(file, (err, stats) => {
        // eslint-disable-line handle-callback-err
        if (!err && stats.isFile()) return callback();
        const dir = path.dirname(file);
        fs.stat(dir, (err, stats) => {
          if (err) {
            // if the directory doesn't exist, make it
            if (err.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err) => {
                if (err) return callback(err);
                makeFile();
              });
            }
            return callback(err);
          }

          if (stats.isDirectory()) makeFile();
          else {
            // parent is not a directory
            // This is just to cause an internal ENOTDIR error to be thrown
            fs.readdir(dir, (err) => {
              if (err) return callback(err);
            });
          }
        });
      });
    }

    function createFileSync(file) {
      let stats;
      try {
        stats = fs.statSync(file);
      } catch {}
      if (stats && stats.isFile()) return;

      const dir = path.dirname(file);
      try {
        if (!fs.statSync(dir).isDirectory()) {
          // parent is not a directory
          // This is just to cause an internal ENOTDIR error to be thrown
          fs.readdirSync(dir);
        }
      } catch (err) {
        // If the stat call above failed because the directory doesn't exist, create it
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }

      fs.writeFileSync(file, "");
    }

    module.exports = {
      createFile: u(createFile),
      createFileSync,
    };

    /***/
  },

  /***/ 2695: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { createFile, createFileSync } = __nccwpck_require__(9606);
    const { createLink, createLinkSync } = __nccwpck_require__(2985);
    const { createSymlink, createSymlinkSync } = __nccwpck_require__(8263);

    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync,
    };

    /***/
  },

  /***/ 2985: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromCallback;
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(7758);
    const mkdir = __nccwpck_require__(4666);
    const pathExists = __nccwpck_require__(7237).pathExists;
    const { areIdentical } = __nccwpck_require__(8260);

    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath, dstpath) {
        fs.link(srcpath, dstpath, (err) => {
          if (err) return callback(err);
          callback(null);
        });
      }

      fs.lstat(dstpath, (_, dstStat) => {
        fs.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);

          const dir = path.dirname(dstpath);
          pathExists(dir, (err, dirExists) => {
            if (err) return callback(err);
            if (dirExists) return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err) => {
              if (err) return callback(err);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }

    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs.lstatSync(dstpath);
      } catch {}

      try {
        const srcStat = fs.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }

      const dir = path.dirname(dstpath);
      const dirExists = fs.existsSync(dir);
      if (dirExists) return fs.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);

      return fs.linkSync(srcpath, dstpath);
    }

    module.exports = {
      createLink: u(createLink),
      createLinkSync,
    };

    /***/
  },

  /***/ 6339: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(7758);
    const pathExists = __nccwpck_require__(7237).pathExists;

    /**
     * Function that returns two types of paths, one relative to symlink, and one
     * relative to the current working directory. Checks if path is absolute or
     * relative. If the path is relative, this function checks if the path is
     * relative to symlink or relative to current working directory. This is an
     * initiative to find a smarter `srcpath` to supply when building symlinks.
     * This allows you to determine which path to use out of one of three possible
     * types of source paths. The first is an absolute path. This is detected by
     * `path.isAbsolute()`. When an absolute path is provided, it is checked to
     * see if it exists. If it does it's used, if not an error is returned
     * (callback)/ thrown (sync). The other two options for `srcpath` are a
     * relative url. By default Node's `fs.symlink` works by creating a symlink
     * using `dstpath` and expects the `srcpath` to be relative to the newly
     * created symlink. If you provide a `srcpath` that does not exist on the file
     * system it results in a broken symlink. To minimize this, the function
     * checks to see if the 'relative to symlink' source file exists, and if it
     * does it will use it. If it does not, it checks if there's a file that
     * exists that is relative to the current working directory, if does its used.
     * This preserves the expectations of the original fs.symlink spec and adds
     * the ability to pass in `relative to current working direcotry` paths.
     */

    function symlinkPaths(srcpath, dstpath, callback) {
      if (path.isAbsolute(srcpath)) {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath,
          });
        });
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err) return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath,
            });
          } else {
            return fs.lstat(srcpath, (err) => {
              if (err) {
                err.message = err.message.replace("lstat", "ensureSymlink");
                return callback(err);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path.relative(dstdir, srcpath),
              });
            });
          }
        });
      }
    }

    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path.isAbsolute(srcpath)) {
        exists = fs.existsSync(srcpath);
        if (!exists) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath,
        };
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        exists = fs.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath,
          };
        } else {
          exists = fs.existsSync(srcpath);
          if (!exists) throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path.relative(dstdir, srcpath),
          };
        }
      }
    }

    module.exports = {
      symlinkPaths,
      symlinkPathsSync,
    };

    /***/
  },

  /***/ 7946: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);

    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type) return callback(null, type);
      fs.lstat(srcpath, (err, stats) => {
        if (err) return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }

    function symlinkTypeSync(srcpath, type) {
      let stats;

      if (type) return type;
      try {
        stats = fs.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }

    module.exports = {
      symlinkType,
      symlinkTypeSync,
    };

    /***/
  },

  /***/ 8263: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromCallback;
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(2577);
    const _mkdirs = __nccwpck_require__(4666);
    const mkdirs = _mkdirs.mkdirs;
    const mkdirsSync = _mkdirs.mkdirsSync;

    const _symlinkPaths = __nccwpck_require__(6339);
    const symlinkPaths = _symlinkPaths.symlinkPaths;
    const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

    const _symlinkType = __nccwpck_require__(7946);
    const symlinkType = _symlinkType.symlinkType;
    const symlinkTypeSync = _symlinkType.symlinkTypeSync;

    const pathExists = __nccwpck_require__(7237).pathExists;

    const { areIdentical } = __nccwpck_require__(8260);

    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;

      fs.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([fs.stat(srcpath), fs.stat(dstpath)]).then(
            ([srcStat, dstStat]) => {
              if (areIdentical(srcStat, dstStat)) return callback(null);
              _createSymlink(srcpath, dstpath, type, callback);
            }
          );
        } else _createSymlink(srcpath, dstpath, type, callback);
      });
    }

    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err) return callback(err);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err, type) => {
          if (err) return callback(err);
          const dir = path.dirname(dstpath);
          pathExists(dir, (err, dirExists) => {
            if (err) return callback(err);
            if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
            mkdirs(dir, (err) => {
              if (err) return callback(err);
              fs.symlink(srcpath, dstpath, type, callback);
            });
          });
        });
      });
    }

    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs.lstatSync(dstpath);
      } catch {}
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs.statSync(srcpath);
        const dstStat = fs.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }

      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      const exists = fs.existsSync(dir);
      if (exists) return fs.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs.symlinkSync(srcpath, dstpath, type);
    }

    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync,
    };

    /***/
  },

  /***/ 2577: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    // This is adapted from https://github.com/normalize/mz
    // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
    const u = __nccwpck_require__(9046).fromCallback;
    const fs = __nccwpck_require__(7758);

    const api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile",
    ].filter((key) => {
      // Some commands are not available on some systems. Ex:
      // fs.cp was added in Node.js v16.7.0
      // fs.lchown is not available on at least some Linux
      return typeof fs[key] === "function";
    });

    // Export cloned fs:
    Object.assign(exports, fs);

    // Universalify async methods:
    api.forEach((method) => {
      exports[method] = u(fs[method]);
    });

    // We differ from mz/fs in that we still ship the old, broken, fs.exists()
    // since we are a drop-in replacement for the native module
    exports.exists = function (filename, callback) {
      if (typeof callback === "function") {
        return fs.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs.exists(filename, resolve);
      });
    };

    // fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args

    exports.read = function (fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs.read(
          fd,
          buffer,
          offset,
          length,
          position,
          (err, bytesRead, buffer) => {
            if (err) return reject(err);
            resolve({ bytesRead, buffer });
          }
        );
      });
    };

    // Function signature can be
    // fs.write(fd, buffer[, offset[, length[, position]]], callback)
    // OR
    // fs.write(fd, string[, position[, encoding]], callback)
    // We need to handle both cases, so we use ...args
    exports.write = function (fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.write(fd, buffer, ...args);
      }

      return new Promise((resolve, reject) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer });
        });
      });
    };

    // Function signature is
    // s.readv(fd, buffers[, position], callback)
    // We need to handle the optional arg, so we use ...args
    exports.readv = function (fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.readv(fd, buffers, ...args);
      }

      return new Promise((resolve, reject) => {
        fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffers });
        });
      });
    };

    // Function signature is
    // s.writev(fd, buffers[, position], callback)
    // We need to handle the optional arg, so we use ...args
    exports.writev = function (fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.writev(fd, buffers, ...args);
      }

      return new Promise((resolve, reject) => {
        fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers });
        });
      });
    };

    // fs.realpath.native sometimes not available if fs is monkey-patched
    if (typeof fs.realpath.native === "function") {
      exports.realpath.native = u(fs.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }

    /***/
  },

  /***/ 4850: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = {
      // Export promiseified graceful-fs:
      ...__nccwpck_require__(2577),
      // Export extra methods:
      ...__nccwpck_require__(4144),
      ...__nccwpck_require__(7987),
      ...__nccwpck_require__(2695),
      ...__nccwpck_require__(1405),
      ...__nccwpck_require__(4666),
      ...__nccwpck_require__(4790),
      ...__nccwpck_require__(5144),
      ...__nccwpck_require__(7237),
      ...__nccwpck_require__(806),
    };

    /***/
  },

  /***/ 1405: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const jsonFile = __nccwpck_require__(9344);

    jsonFile.outputJson = u(__nccwpck_require__(6701));
    jsonFile.outputJsonSync = __nccwpck_require__(4470);
    // aliases
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;

    module.exports = jsonFile;

    /***/
  },

  /***/ 9344: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const jsonFile = __nccwpck_require__(6160);

    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync,
    };

    /***/
  },

  /***/ 4470: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { stringify } = __nccwpck_require__(5902);
    const { outputFileSync } = __nccwpck_require__(5144);

    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);

      outputFileSync(file, str, options);
    }

    module.exports = outputJsonSync;

    /***/
  },

  /***/ 6701: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { stringify } = __nccwpck_require__(5902);
    const { outputFile } = __nccwpck_require__(5144);

    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);

      await outputFile(file, str, options);
    }

    module.exports = outputJson;

    /***/
  },

  /***/ 4666: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const { makeDir: _makeDir, makeDirSync } = __nccwpck_require__(1924);
    const makeDir = u(_makeDir);

    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync,
    };

    /***/
  },

  /***/ 1924: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(2577);
    const { checkPath } = __nccwpck_require__(7963);

    const getMode = (options) => {
      const defaults = { mode: 0o777 };
      if (typeof options === "number") return options;
      return { ...defaults, ...options }.mode;
    };

    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);

      return fs.mkdir(dir, {
        mode: getMode(options),
        recursive: true,
      });
    };

    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);

      return fs.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true,
      });
    };

    /***/
  },

  /***/ 7963: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // Adapted from https://github.com/sindresorhus/make-dir
    // Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    const path = __nccwpck_require__(1017);

    // https://github.com/nodejs/node/issues/8987
    // https://github.com/libuv/libuv/pull/1088
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(
          pth.replace(path.parse(pth).root, "")
        );

        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };

    /***/
  },

  /***/ 4790: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromCallback;
    module.exports = {
      move: u(__nccwpck_require__(4800)),
      moveSync: __nccwpck_require__(8615),
    };

    /***/
  },

  /***/ 8615: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const copySync = __nccwpck_require__(4144).copySync;
    const removeSync = __nccwpck_require__(806).removeSync;
    const mkdirpSync = __nccwpck_require__(4666).mkdirpSync;
    const stat = __nccwpck_require__(8260);

    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;

      const { srcStat, isChangingCase = false } = stat.checkPathsSync(
        src,
        dest,
        "move",
        opts
      );
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }

    function isParentRoot(dest) {
      const parent = path.dirname(dest);
      const parsedPath = path.parse(parent);
      return parsedPath.root === parent;
    }

    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }

    function rename(src, dest, overwrite) {
      try {
        fs.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }

    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true,
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }

    module.exports = moveSync;

    /***/
  },

  /***/ 4800: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const copy = __nccwpck_require__(4144).copy;
    const remove = __nccwpck_require__(806).remove;
    const mkdirp = __nccwpck_require__(4666).mkdirp;
    const pathExists = __nccwpck_require__(7237).pathExists;
    const stat = __nccwpck_require__(8260);

    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }

      opts = opts || {};

      const overwrite = opts.overwrite || opts.clobber || false;

      stat.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err) return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err) => {
          if (err) return cb(err);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp(path.dirname(dest), (err) => {
            if (err) return cb(err);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }

    function isParentRoot(dest) {
      const parent = path.dirname(dest);
      const parsedPath = path.parse(parent);
      return parsedPath.root === parent;
    }

    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase) return rename(src, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err) => {
          if (err) return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err) return cb(err);
        if (destExists) return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }

    function rename(src, dest, overwrite, cb) {
      fs.rename(src, dest, (err) => {
        if (!err) return cb();
        if (err.code !== "EXDEV") return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }

    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true,
      };
      copy(src, dest, opts, (err) => {
        if (err) return cb(err);
        return remove(src, cb);
      });
    }

    module.exports = move;

    /***/
  },

  /***/ 5144: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromCallback;
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const mkdir = __nccwpck_require__(4666);
    const pathExists = __nccwpck_require__(7237).pathExists;

    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }

      const dir = path.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err) return callback(err);
        if (itDoes) return fs.writeFile(file, data, encoding, callback);

        mkdir.mkdirs(dir, (err) => {
          if (err) return callback(err);

          fs.writeFile(file, data, encoding, callback);
        });
      });
    }

    function outputFileSync(file, ...args) {
      const dir = path.dirname(file);
      if (fs.existsSync(dir)) {
        return fs.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs.writeFileSync(file, ...args);
    }

    module.exports = {
      outputFile: u(outputFile),
      outputFileSync,
    };

    /***/
  },

  /***/ 7237: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const fs = __nccwpck_require__(2577);

    function pathExists(path) {
      return fs
        .access(path)
        .then(() => true)
        .catch(() => false);
    }

    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs.existsSync,
    };

    /***/
  },

  /***/ 806: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const u = __nccwpck_require__(9046).fromCallback;

    function remove(path, callback) {
      fs.rm(path, { recursive: true, force: true }, callback);
    }

    function removeSync(path) {
      fs.rmSync(path, { recursive: true, force: true });
    }

    module.exports = {
      remove: u(remove),
      removeSync,
    };

    /***/
  },

  /***/ 8260: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(2577);
    const path = __nccwpck_require__(1017);
    const util = __nccwpck_require__(3837);

    function getStats(src, dest, opts) {
      const statFunc = opts.dereference
        ? (file) => fs.stat(file, { bigint: true })
        : (file) => fs.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        }),
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }

    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference
        ? (file) => fs.statSync(file, { bigint: true })
        : (file) => fs.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }

    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err) return cb(err);
        const { srcStat, destStat } = stats;

        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path.basename(src);
            const destBaseName = path.basename(dest);
            if (
              funcName === "move" &&
              srcBaseName !== destBaseName &&
              srcBaseName.toLowerCase() === destBaseName.toLowerCase()
            ) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(
              new Error("Source and destination must not be the same.")
            );
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(
              new Error(
                `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
              )
            );
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(
              new Error(
                `Cannot overwrite directory '${dest}' with non-directory '${src}'.`
              )
            );
          }
        }

        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }

    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);

      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (
            funcName === "move" &&
            srcBaseName !== destBaseName &&
            srcBaseName.toLowerCase() === destBaseName.toLowerCase()
          ) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
          );
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite directory '${dest}' with non-directory '${src}'.`
          );
        }
      }

      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }

    // recursively check if dest parent is a subdirectory of src.
    // It works for all file types including symlinks since it
    // checks the src and dest inodes. It starts from the deepest
    // parent and stops once it reaches the src parent or the root path.
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (
        destParent === srcParent ||
        destParent === path.parse(destParent).root
      )
        return cb();
      fs.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT") return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }

    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (
        destParent === srcParent ||
        destParent === path.parse(destParent).root
      )
        return;
      let destStat;
      try {
        destStat = fs.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }

    function areIdentical(srcStat, destStat) {
      return (
        destStat.ino &&
        destStat.dev &&
        destStat.ino === srcStat.ino &&
        destStat.dev === srcStat.dev
      );
    }

    // return true if dest is a subdir of src, otherwise false.
    // It only checks the path strings.
    function isSrcSubdir(src, dest) {
      const srcArr = path
        .resolve(src)
        .split(path.sep)
        .filter((i) => i);
      const destArr = path
        .resolve(dest)
        .split(path.sep)
        .filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }

    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }

    module.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical,
    };

    /***/
  },

  /***/ 6969: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);

    function utimesMillis(path, atime, mtime, callback) {
      // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
      fs.open(path, "r+", (err, fd) => {
        if (err) return callback(err);
        fs.futimes(fd, atime, mtime, (futimesErr) => {
          fs.close(fd, (closeErr) => {
            if (callback) callback(futimesErr || closeErr);
          });
        });
      });
    }

    function utimesMillisSync(path, atime, mtime) {
      const fd = fs.openSync(path, "r+");
      fs.futimesSync(fd, atime, mtime);
      return fs.closeSync(fd);
    }

    module.exports = {
      utimesMillis,
      utimesMillisSync,
    };

    /***/
  },

  /***/ 9756: /***/ (__unused_webpack_module, exports) => {
    /**
     * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
     *
     * Works with anything that has a `length` property and index access properties, including NodeList.
     *
     * @template {unknown} T
     * @param {Array<T> | ({length:number, [number]: T})} list
     * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
     * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
     * 				allows injecting a custom implementation in tests
     * @returns {T | undefined}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
     * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
     */
    function find(list, predicate, ac) {
      if (ac === undefined) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(undefined, item, i, list)) {
            return item;
          }
        }
      }
    }

    /**
     * "Shallow freezes" an object to render it immutable.
     * Uses `Object.freeze` if available,
     * otherwise the immutability is only in the type.
     *
     * Is used to create "enum like" objects.
     *
     * @template T
     * @param {T} object the object to freeze
     * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
     * 				allows to inject custom object constructor for tests
     * @returns {Readonly<T>}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
     */
    function freeze(object, oc) {
      if (oc === undefined) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }

    /**
     * Since we can not rely on `Object.assign` we provide a simplified version
     * that is sufficient for our needs.
     *
     * @param {Object} target
     * @param {Object | null | undefined} source
     *
     * @returns {Object} target
     * @throws TypeError if target is not an object
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
     */
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }

    /**
     * All mime types that are allowed as input to `DOMParser.parseFromString`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
     * @see DOMParser.prototype.parseFromString
     */
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",

      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function (value) {
        return value === MIME_TYPE.HTML;
      },

      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",

      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",

      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",

      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml",
    });

    /**
     * Namespaces that are used in this code base.
     *
     * @see http://www.w3.org/TR/REC-xml-names
     */
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",

      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function (uri) {
        return uri === NAMESPACE.HTML;
      },

      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",

      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",

      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/",
    });

    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;

    /***/
  },

  /***/ 5072: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var __webpack_unused_export__;
    var conventions = __nccwpck_require__(9756);
    var dom = __nccwpck_require__(1389);
    var entities = __nccwpck_require__(8508);
    var sax = __nccwpck_require__(6058);

    var DOMImplementation = dom.DOMImplementation;

    var NAMESPACE = conventions.NAMESPACE;

    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;

    /**
     * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
     *
     * > XML parsed entities are often stored in computer files which,
     * > for editing convenience, are organized into lines.
     * > These lines are typically separated by some combination
     * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
     * >
     * > To simplify the tasks of applications, the XML processor must behave
     * > as if it normalized all line breaks in external parsed entities (including the document entity)
     * > on input, before parsing, by translating all of the following to a single #xA character:
     * >
     * > 1. the two-character sequence #xD #xA
     * > 2. the two-character sequence #xD #x85
     * > 3. the single character #x85
     * > 4. the single character #x2028
     * > 5. any #xD character that is not immediately followed by #xA or #x85.
     *
     * @param {string} input
     * @returns {string}
     */
    function normalizeLineEndings(input) {
      return input
        .replace(/\r[\n\u0085]/g, "\n")
        .replace(/[\r\u0085\u2028]/g, "\n");
    }

    /**
     * @typedef Locator
     * @property {number} [columnNumber]
     * @property {number} [lineNumber]
     */

    /**
     * @typedef DOMParserOptions
     * @property {DOMHandler} [domBuilder]
     * @property {Function} [errorHandler]
     * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
     * 						defaults to `normalizeLineEndings`
     * @property {Locator} [locator]
     * @property {Record<string, string>} [xmlns]
     *
     * @see normalizeLineEndings
     */

    /**
     * The DOMParser interface provides the ability to parse XML or HTML source code
     * from a string into a DOM `Document`.
     *
     * _xmldom is different from the spec in that it allows an `options` parameter,
     * to override the default behavior._
     *
     * @param {DOMParserOptions} [options]
     * @constructor
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
     */
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }

    DOMParser.prototype.parseFromString = function (source, mimeType) {
      var options = this.options;
      var sax = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }

      sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax.parse(normalize(source), defaultNSMap, entityMap);
      } else {
        sax.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn =
            errorImpl.length == 2
              ? function (msg) {
                  errorImpl(key, msg);
                }
              : errorImpl;
        }
        errorHandler[key] =
          (fn &&
            function (msg) {
              fn("[xmldom " + key + "]\t" + msg + _locator(locator));
            }) ||
          function () {};
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }

    //console.log('#\n\n\n\n\n\n\n####')
    /**
     * +ContentHandler+ErrorHandler
     * +LexicalHandler+EntityResolver2
     * -DeclHandler-DTDHandler
     *
     * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
     * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
     * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
     */
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    /**
     * @see org.xml.sax.ContentHandler#startDocument
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
     */
    DOMHandler.prototype = {
      startDocument: function () {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function (namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;

        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function (namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function (prefix, uri) {},
      endPrefixMapping: function (prefix) {},
      processingInstruction: function (target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function (ch, start, length) {},
      characters: function (chars, start, length) {
        chars = _toString.apply(this, arguments);
        //console.log(chars)
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
            //process xml
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function (name) {},
      endDocument: function () {
        this.doc.normalize();
      },
      setDocumentLocator: function (locator) {
        if ((this.locator = locator)) {
          // && !('lineNumber' in locator)){
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function (chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },

      startCDATA: function () {
        //used in characters() methods
        this.cdata = true;
      },
      endCDATA: function () {
        this.cdata = false;
      },

      startDTD: function (name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function (error) {
        console.warn("[xmldom warning]\t" + error, _locator(this.locator));
      },
      error: function (error) {
        console.error("[xmldom error]\t" + error, _locator(this.locator));
      },
      fatalError: function (error) {
        throw new ParseError(error, this.locator);
      },
    };
    function _locator(l) {
      if (l) {
        return (
          "\n@" +
          (l.systemId || "") +
          "#[line:" +
          l.lineNumber +
          ",col:" +
          l.columnNumber +
          "]"
        );
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        //java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }

    /*
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
     * used method of org.xml.sax.ext.LexicalHandler:
     *  #comment(chars, start, length)
     *  #startCDATA()
     *  #endCDATA()
     *  #startDTD(name, publicId, systemId)
     *
     *
     * IGNORED method of org.xml.sax.ext.LexicalHandler:
     *  #endDTD()
     *  #startEntity(name)
     *  #endEntity(name)
     *
     *
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
     * IGNORED method of org.xml.sax.ext.DeclHandler
     * 	#attributeDecl(eName, aName, type, mode, value)
     *  #elementDecl(name, model)
     *  #externalEntityDecl(name, publicId, systemId)
     *  #internalEntityDecl(name, value)
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
     * IGNORED method of org.xml.sax.EntityResolver2
     *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
     *  #resolveEntity(publicId, systemId)
     *  #getExternalSubset(name, baseURI)
     * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
     * IGNORED method of org.xml.sax.DTDHandler
     *  #notationDecl(name, publicId, systemId) {};
     *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
     */
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
      /\w+/g,
      function (key) {
        DOMHandler.prototype[key] = function () {
          return null;
        };
      }
    );

    /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    } //appendChild and setAttributeNS are preformance key

    __webpack_unused_export__ = DOMHandler;
    __webpack_unused_export__ = normalizeLineEndings;
    exports.DOMParser = DOMParser;

    /***/
  },

  /***/ 1389: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var conventions = __nccwpck_require__(9756);

    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;

    /**
     * A prerequisite for `[].filter`, to drop elements that are empty
     * @param {string} input
     * @returns {boolean}
     */
    function notEmptyString(input) {
      return input !== "";
    }
    /**
     * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
     * @see https://infra.spec.whatwg.org/#ascii-whitespace
     *
     * @param {string} input
     * @returns {string[]} (can be empty)
     */
    function splitOnASCIIWhitespace(input) {
      // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }

    /**
     * Adds element as a key to current if it is not already present.
     *
     * @param {Record<string, boolean | undefined>} current
     * @param {string} element
     * @returns {Record<string, boolean | undefined>}
     */
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }

    /**
     * @see https://infra.spec.whatwg.org/#ordered-set
     * @param {string} input
     * @returns {string[]}
     */
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }

    /**
     * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
     * which we can not rely on being available.
     *
     * @param {any[]} list
     * @returns {function(any): boolean}
     */
    function arrayIncludes(list) {
      return function (element) {
        return list && list.indexOf(element) !== -1;
      };
    }

    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }

    /**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        function t() {}
        t.prototype = Super.prototype;
        t = new t();
        copy(pt, t);
        Class.prototype = pt = t;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }

    // Node Types
    var NodeType = {};
    var ELEMENT_NODE = (NodeType.ELEMENT_NODE = 1);
    var ATTRIBUTE_NODE = (NodeType.ATTRIBUTE_NODE = 2);
    var TEXT_NODE = (NodeType.TEXT_NODE = 3);
    var CDATA_SECTION_NODE = (NodeType.CDATA_SECTION_NODE = 4);
    var ENTITY_REFERENCE_NODE = (NodeType.ENTITY_REFERENCE_NODE = 5);
    var ENTITY_NODE = (NodeType.ENTITY_NODE = 6);
    var PROCESSING_INSTRUCTION_NODE =
      (NodeType.PROCESSING_INSTRUCTION_NODE = 7);
    var COMMENT_NODE = (NodeType.COMMENT_NODE = 8);
    var DOCUMENT_NODE = (NodeType.DOCUMENT_NODE = 9);
    var DOCUMENT_TYPE_NODE = (NodeType.DOCUMENT_TYPE_NODE = 10);
    var DOCUMENT_FRAGMENT_NODE = (NodeType.DOCUMENT_FRAGMENT_NODE = 11);
    var NOTATION_NODE = (NodeType.NOTATION_NODE = 12);

    // ExceptionCode
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = (ExceptionCode.INDEX_SIZE_ERR =
      ((ExceptionMessage[1] = "Index size error"), 1));
    var DOMSTRING_SIZE_ERR = (ExceptionCode.DOMSTRING_SIZE_ERR =
      ((ExceptionMessage[2] = "DOMString size error"), 2));
    var HIERARCHY_REQUEST_ERR = (ExceptionCode.HIERARCHY_REQUEST_ERR =
      ((ExceptionMessage[3] = "Hierarchy request error"), 3));
    var WRONG_DOCUMENT_ERR = (ExceptionCode.WRONG_DOCUMENT_ERR =
      ((ExceptionMessage[4] = "Wrong document"), 4));
    var INVALID_CHARACTER_ERR = (ExceptionCode.INVALID_CHARACTER_ERR =
      ((ExceptionMessage[5] = "Invalid character"), 5));
    var NO_DATA_ALLOWED_ERR = (ExceptionCode.NO_DATA_ALLOWED_ERR =
      ((ExceptionMessage[6] = "No data allowed"), 6));
    var NO_MODIFICATION_ALLOWED_ERR =
      (ExceptionCode.NO_MODIFICATION_ALLOWED_ERR =
        ((ExceptionMessage[7] = "No modification allowed"), 7));
    var NOT_FOUND_ERR = (ExceptionCode.NOT_FOUND_ERR =
      ((ExceptionMessage[8] = "Not found"), 8));
    var NOT_SUPPORTED_ERR = (ExceptionCode.NOT_SUPPORTED_ERR =
      ((ExceptionMessage[9] = "Not supported"), 9));
    var INUSE_ATTRIBUTE_ERR = (ExceptionCode.INUSE_ATTRIBUTE_ERR =
      ((ExceptionMessage[10] = "Attribute in use"), 10));
    //level2
    var INVALID_STATE_ERR = (ExceptionCode.INVALID_STATE_ERR =
      ((ExceptionMessage[11] = "Invalid state"), 11));
    var SYNTAX_ERR = (ExceptionCode.SYNTAX_ERR =
      ((ExceptionMessage[12] = "Syntax error"), 12));
    var INVALID_MODIFICATION_ERR = (ExceptionCode.INVALID_MODIFICATION_ERR =
      ((ExceptionMessage[13] = "Invalid modification"), 13));
    var NAMESPACE_ERR = (ExceptionCode.NAMESPACE_ERR =
      ((ExceptionMessage[14] = "Invalid namespace"), 14));
    var INVALID_ACCESS_ERR = (ExceptionCode.INVALID_ACCESS_ERR =
      ((ExceptionMessage[15] = "Invalid access"), 15));

    /**
     * DOM Level 2
     * Object DOMException
     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
     * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
     */
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);

    /**
     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
     * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
     * The items in the NodeList are accessible via an integral index, starting from 0.
     */
    function NodeList() {}
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function (index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function (isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function (predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function (item) {
        return Array.prototype.indexOf.call(this, item);
      },
    };

    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function (i) {
      _updateLiveList(this);
      return this[i] || null;
    };

    _extends(LiveNodeList, NodeList);

    /**
     * Objects implementing the NamedNodeMap interface are used
     * to represent collections of nodes that can be accessed by name.
     * Note that NamedNodeMap does not inherit from NodeList;
     * NamedNodeMaps are not maintained in any particular order.
     * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
     * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
     * and does not imply that the DOM specifies an order to these Nodes.
     * NamedNodeMap objects in the DOM are live.
     * used for attributes or DocumentType entities
     */
    function NamedNodeMap() {}

    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }

    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      //console.log('remove attr:'+attr)
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(
          NOT_FOUND_ERR,
          new Error(el.tagName + "@" + attr)
        );
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function (key) {
        //		if(key.indexOf(':')>0 || key == 'xmlns'){
        //			return null;
        //		}
        //console.log()
        var i = this.length;
        while (i--) {
          var attr = this[i];
          //console.log(attr.nodeName,key)
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function (attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function (attr) {
        // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
        var el = attr.ownerElement,
          oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },

      /* returns Node */
      removeNamedItem: function (key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      }, // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

      //for level2
      removeNamedItemNS: function (namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function (namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (
            node.localName == localName &&
            node.namespaceURI == namespaceURI
          ) {
            return node;
          }
        }
        return null;
      },
    };

    /**
     * The DOMImplementation interface represents an object providing methods
     * which are not dependent on any particular document.
     * Such an object is returned by the `Document.implementation` property.
     *
     * __The individual methods describe the differences compared to the specs.__
     *
     * @constructor
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
     * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
     */
    function DOMImplementation() {}

    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function (feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function (namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function (qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";

        return node;
      },
    };

    /**
     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
     */

    function Node() {}

    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function (newChild, refChild) {
        //raises
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function (newChild, oldChild) {
        //raises
        _insertBefore(
          this,
          newChild,
          oldChild,
          assertPreReplacementValidityInDocument
        );
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function (oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function (newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function () {
        return this.firstChild != null;
      },
      cloneNode: function (deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function () {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (
            next &&
            next.nodeType == TEXT_NODE &&
            child.nodeType == TEXT_NODE
          ) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function (feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function () {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function (namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          //console.dir(map)
          if (map) {
            for (var n in map) {
              if (
                Object.prototype.hasOwnProperty.call(map, n) &&
                map[n] === namespaceURI
              ) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function (prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          //console.dir(map)
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function (namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      },
    };

    function _xmlEncoder(c) {
      return (
        (c == "<" && "&lt;") ||
        (c == ">" && "&gt;") ||
        (c == "&" && "&amp;") ||
        (c == '"' && "&quot;") ||
        "&#" + c.charCodeAt() + ";"
      );
    }

    copy(NodeType, Node);
    copy(NodeType, Node.prototype);

    /**
     * @param callback return true for continue,false for break
     * @return boolean true: break visit;
     */
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if ((node = node.firstChild)) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while ((node = node.nextSibling));
      }
    }

    function Document() {
      this.ownerDocument = this;
    }

    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        //update namespace
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }

    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        //update namespace
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }

    /**
     * Updates `el.childNodes`, updating the indexed items and it's `length`.
     * Passing `newChild` means it will be appended.
     * Otherwise it's assumed that an item has been removed,
     * and `el.firstNode` and it's `.nextSibling` are used
     * to walk the current list of child nodes.
     *
     * @param {Document} doc
     * @param {Node} el
     * @param {Node} [newChild]
     * @private
     */
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        //update childNodes
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }

    /**
     * Removes the connections between `parentNode` and `child`
     * and any existing `child.previousSibling` or `child.nextSibling`.
     *
     * @see https://github.com/xmldom/xmldom/issues/135
     * @see https://github.com/xmldom/xmldom/issues/145
     *
     * @param {Node} parentNode
     * @param {Node} child
     * @returns {Node} the child that was removed.
     * @private
     */
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }

    /**
     * Returns `true` if `node` can be a parent for insertion.
     * @param {Node} node
     * @returns {boolean}
     */
    function hasValidParentNodeType(node) {
      return (
        node &&
        (node.nodeType === Node.DOCUMENT_NODE ||
          node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
          node.nodeType === Node.ELEMENT_NODE)
      );
    }

    /**
     * Returns `true` if `node` can be inserted according to it's `nodeType`.
     * @param {Node} node
     * @returns {boolean}
     */
    function hasInsertableNodeType(node) {
      return (
        node &&
        (isElementNode(node) ||
          isTextNode(node) ||
          isDocTypeNode(node) ||
          node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
          node.nodeType === Node.COMMENT_NODE ||
          node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
      );
    }

    /**
     * Returns true if `node` is a DOCTYPE node
     * @param {Node} node
     * @returns {boolean}
     */
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }

    /**
     * Returns true if the node is an element
     * @param {Node} node
     * @returns {boolean}
     */
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    /**
     * Returns true if `node` is a text node
     * @param {Node} node
     * @returns {boolean}
     */
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }

    /**
     * Check if en element node can be inserted before `child`, or at the end if child is falsy,
     * according to the presence and position of a doctype node on the same level.
     *
     * @param {Document} doc The document node
     * @param {Node} child the node that would become the nextSibling if the element would be inserted
     * @returns {boolean} `true` if an element can be inserted before child
     * @private
     * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
     */
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(
        child &&
        docTypeNode &&
        parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child)
      );
    }

    /**
     * Check if en element node can be inserted before `child`, or at the end if child is falsy,
     * according to the presence and position of a doctype node on the same level.
     *
     * @param {Node} doc The document node
     * @param {Node} child the node that would become the nextSibling if the element would be inserted
     * @returns {boolean} `true` if an element can be inserted before child
     * @private
     * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
     */
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];

      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }

      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(
        child &&
        docTypeNode &&
        parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child)
      );
    }

    /**
     * @private
     * Steps 1-5 of the checks before inserting and before replacing a child are the same.
     *
     * @param {Node} parent the parent node to insert `node` into
     * @param {Node} node the node to insert
     * @param {Node=} child the node that should become the `nextSibling` of `node`
     * @returns {Node}
     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
     * @throws DOMException if `child` is provided but is not a child of `parent`.
     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
     * @see https://dom.spec.whatwg.org/#concept-node-replace
     */
    function assertPreInsertionValidity1to5(parent, node, child) {
      // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected parent node type " + parent.nodeType
        );
      }
      // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
      // not implemented!
      // 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) ||
        // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        (isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " +
            node.nodeType +
            " for parent node type " +
            parent.nodeType
        );
      }
    }

    /**
     * @private
     * Step 6 of the checks before inserting and before replacing a child are different.
     *
     * @param {Document} parent the parent node to insert `node` into
     * @param {Node} node the node to insert
     * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
     * @returns {Node}
     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
     * @throws DOMException if `child` is provided but is not a child of `parent`.
     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
     * @see https://dom.spec.whatwg.org/#concept-node-replace
     */
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];

      // DocumentFragment
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        // If node has more than one element child or has a Text node child.
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "More than one element or text in fragment"
          );
        }
        // Otherwise, if `node` has one element child and either `parent` has an element child,
        // `child` is a doctype, or `child` is non-null and a doctype is following `child`.
        if (
          nodeChildElements.length === 1 &&
          !isElementInsertionPossible(parent, child)
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Element in fragment can not be inserted before doctype"
          );
        }
      }
      // Element
      if (isElementNode(node)) {
        // `parent` has an element child, `child` is a doctype,
        // or `child` is non-null and a doctype is following `child`.
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Only one element can be added and only after doctype"
          );
        }
      }
      // DocumentType
      if (isDocTypeNode(node)) {
        // `parent` has a doctype child,
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Only one doctype is allowed"
          );
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        // `child` is non-null and an element is preceding `child`,
        if (
          child &&
          parentChildNodes.indexOf(parentElementChild) <
            parentChildNodes.indexOf(child)
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Doctype can only be inserted before an element"
          );
        }
        // or `child` is null and `parent` has an element child.
        if (!child && parentElementChild) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Doctype can not be appended since element is present"
          );
        }
      }
    }

    /**
     * @private
     * Step 6 of the checks before inserting and before replacing a child are different.
     *
     * @param {Document} parent the parent node to insert `node` into
     * @param {Node} node the node to insert
     * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
     * @returns {Node}
     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
     * @throws DOMException if `child` is provided but is not a child of `parent`.
     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
     * @see https://dom.spec.whatwg.org/#concept-node-replace
     */
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];

      // DocumentFragment
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        // If `node` has more than one element child or has a Text node child.
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "More than one element or text in fragment"
          );
        }
        // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
        if (
          nodeChildElements.length === 1 &&
          !isElementReplacementPossible(parent, child)
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Element in fragment can not be inserted before doctype"
          );
        }
      }
      // Element
      if (isElementNode(node)) {
        // `parent` has an element child that is not `child` or a doctype is following `child`.
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Only one element can be added and only after doctype"
          );
        }
      }
      // DocumentType
      if (isDocTypeNode(node)) {
        function hasDoctypeChildThatIsNotChild(node) {
          return isDocTypeNode(node) && node !== child;
        }

        // `parent` has a doctype child that is not `child`,
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Only one doctype is allowed"
          );
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        // or an element is preceding `child`.
        if (
          child &&
          parentChildNodes.indexOf(parentElementChild) <
            parentChildNodes.indexOf(child)
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Doctype can only be inserted before an element"
          );
        }
      }
    }

    /**
     * @private
     * @param {Node} parent the parent node to insert `node` into
     * @param {Node} node the node to insert
     * @param {Node=} child the node that should become the `nextSibling` of `node`
     * @returns {Node}
     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
     * @throws DOMException if `child` is provided but is not a child of `parent`.
     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
     */
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      // To ensure pre-insertion validity of a node into a parent before a child, run these steps:
      assertPreInsertionValidity1to5(parent, node, child);

      // If parent is a document, and any of the statements below, switched on the interface node implements,
      // are true, then throw a "HierarchyRequestError" DOMException.
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(
          parent,
          node,
          child
        );
      }

      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node); //remove and update
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;

      newFirst.previousSibling = pre;
      newLast.nextSibling = child;

      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      //console.log(parent.lastChild.nextSibling == null)
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }

    /**
     * Appends `newChild` to `parentNode`.
     * If `newChild` is already connected to a `parentNode` it is first removed from it.
     *
     * @see https://github.com/xmldom/xmldom/issues/135
     * @see https://github.com/xmldom/xmldom/issues/145
     * @param {Node} parentNode
     * @param {Node} newChild
     * @returns {Node}
     * @private
     */
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }

    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,

      insertBefore: function (newChild, refChild) {
        //raises
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (
          this.documentElement === null &&
          newChild.nodeType === ELEMENT_NODE
        ) {
          this.documentElement = newChild;
        }

        return newChild;
      },
      removeChild: function (oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function (newChild, oldChild) {
        //raises
        _insertBefore(
          this,
          newChild,
          oldChild,
          assertPreReplacementValidityInDocument
        );
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function (importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function (id) {
        var rtv = null;
        _visitNode(this.documentElement, function (node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },

      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function (classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function (base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function (node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                // can be null if the attribute does not exist
                if (nodeClassNames) {
                  // before splitting and iterating just compare them for the most common case
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(
                      arrayIncludes(nodeClassNamesSet)
                    );
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },

      //document factory method:
      createElement: function (tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = (node.attributes = new NamedNodeMap());
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function () {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function (data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function (data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function (data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function (target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function (name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function (name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function (namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = (node.attributes = new NamedNodeMap());
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          //el.prefix = null;
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function (namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          //el.prefix = null;
          node.localName = qualifiedName;
        }
        return node;
      },
    };
    _extends(Document, Node);

    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function (name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function (name) {
        var attr = this.getAttributeNode(name);
        return (attr && attr.value) || "";
      },
      getAttributeNode: function (name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function (name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function (name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },

      //four real opeartion method
      appendChild: function (newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function (newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function (newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function (oldAttr) {
        //console.log(this == oldAttr.ownerElement)
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function (namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },

      hasAttributeNS: function (namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function (namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return (attr && attr.value) || "";
      },
      setAttributeNS: function (namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(
          namespaceURI,
          qualifiedName
        );
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function (namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },

      getElementsByTagName: function (tagName) {
        return new LiveNodeList(this, function (base) {
          var ls = [];
          _visitNode(base, function (node) {
            if (
              node !== base &&
              node.nodeType == ELEMENT_NODE &&
              (tagName === "*" || node.tagName == tagName)
            ) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function (namespaceURI, localName) {
        return new LiveNodeList(this, function (base) {
          var ls = [];
          _visitNode(base, function (node) {
            if (
              node !== base &&
              node.nodeType === ELEMENT_NODE &&
              (namespaceURI === "*" || node.namespaceURI === namespaceURI) &&
              (localName === "*" || node.localName == localName)
            ) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
    };
    Document.prototype.getElementsByTagName =
      Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS =
      Element.prototype.getElementsByTagNameNS;

    _extends(Element, Node);
    function Attr() {}
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);

    function CharacterData() {}
    CharacterData.prototype = {
      data: "",
      substringData: function (offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function (text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function (offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function (newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function (offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function (offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
    };
    _extends(CharacterData, Node);
    function Text() {}
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function (offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      },
    };
    _extends(Text, CharacterData);
    function Comment() {}
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE,
    };
    _extends(Comment, CharacterData);

    function CDATASection() {}
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE,
    };
    _extends(CDATASection, CharacterData);

    function DocumentType() {}
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);

    function Notation() {}
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);

    function Entity() {}
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);

    function EntityReference() {}
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);

    function DocumentFragment() {}
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);

    function ProcessingInstruction() {}
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {}
    XMLSerializer.prototype.serializeToString = function (
      node,
      isHtml,
      nodeFilter
    ) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = (this.nodeType == 9 && this.documentElement) || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;

      if (uri && prefix == null) {
        //console.log(prefix)
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          //isHTML = true;
          var visibleNamespaces = [
            { namespace: uri, prefix: null },
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      //console.log('###',this.nodeType,uri,prefix,buf.join(''))
      return buf.join("");
    }

    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
      // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
      // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
      // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
      // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
      // > [...] Furthermore, the attribute value [...] must not be an empty string.
      // so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
      if (!uri) {
        return false;
      }
      if (
        (prefix === "xml" && uri === NAMESPACE.XML) ||
        uri === NAMESPACE.XMLNS
      ) {
        return false;
      }

      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        // get namespace prefix
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    /**
     * Well-formed constraint: No < in Attribute Values
     * > The replacement text of any entity referred to directly or indirectly
     * > in an attribute value must not contain a <.
     * @see https://www.w3.org/TR/xml11/#CleanAttrVals
     * @see https://www.w3.org/TR/xml11/#NT-AttValue
     *
     * Literal whitespace other than space that appear in attribute values
     * are serialized as their entity references, so they will be preserved.
     * (In contrast to whitespace literals in the input which are normalized to spaces)
     * @see https://www.w3.org/TR/xml11/#AVNormalize
     * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
     */
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(
        " ",
        qualifiedName,
        '="',
        value.replace(/[<>&"\t\n\r]/g, _xmlEncoder),
        '"'
      );
    }

    function serializeToString(
      node,
      buf,
      isHTML,
      nodeFilter,
      visibleNamespaces
    ) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }

      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
        //buf.sort.apply(attrs, attributeSorter);
      }

      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;

          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;

          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            // lookup current default ns from `xmlns` attribute
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              // lookup current default ns in visibleNamespaces
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (
                  namespace.prefix === "" &&
                  namespace.namespace === node.namespaceURI
                ) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }

          buf.push("<", prefixedNodeName);

          for (var i = 0; i < len; i++) {
            // add namespaces for attributes
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({
                prefix: attr.localName,
                namespace: attr.value,
              });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }

          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(
                buf,
                prefix ? "xmlns:" + prefix : "xmlns",
                uri
              );
              visibleNamespaces.push({ prefix: prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }

          // add namespace for current node
          if (
            nodeName === prefixedNodeName &&
            needNamespaceDefine(node, isHTML, visibleNamespaces)
          ) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(
              buf,
              prefix ? "xmlns:" + prefix : "xmlns",
              uri
            );
            visibleNamespaces.push({ prefix: prefix, namespace: uri });
          }

          if (
            child ||
            (isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName))
          ) {
            buf.push(">");
            //if is cdata child node
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(
                    child,
                    buf,
                    isHTML,
                    nodeFilter,
                    visibleNamespaces.slice()
                  );
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(
                  child,
                  buf,
                  isHTML,
                  nodeFilter,
                  visibleNamespaces.slice()
                );
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          // remove added visible namespaces
          //visibleNamespaces.length = startVisibleNamespaces;
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(
              child,
              buf,
              isHTML,
              nodeFilter,
              visibleNamespaces.slice()
            );
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          /**
           * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
           * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
           * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
           * `&amp;` and `&lt;` respectively.
           * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
           * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
           * when that string is not marking the end of a CDATA section.
           *
           * In the content of elements, character data is any string of characters
           * which does not contain the start-delimiter of any markup
           * and does not include the CDATA-section-close delimiter, `]]>`.
           *
           * @see https://www.w3.org/TR/xml/#NT-CharData
           * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
           */
          return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
        //case ENTITY_REFERENCE_NODE:
        //case PROCESSING_INSTRUCTION_NODE:
        ////case TEXT_NODE:
        //case CDATA_SECTION_NODE:
        //case COMMENT_NODE:
        //	deep = false;
        //	break;
        //case DOCUMENT_NODE:
        //case DOCUMENT_TYPE_NODE:
        //cannot be imported.
        //case ENTITY_NODE:
        //case NOTATION_NODE：
        //can not hit in level3
        //default:throw e;
      }
      if (!node2) {
        node2 = node.cloneNode(false); //false
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    //
    //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
    //					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = (node2.attributes = new NamedNodeMap());
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }

    function __set__(object, key, value) {
      object[key] = value;
    }
    //do dynamic
    try {
      if (Object.defineProperty) {
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function () {
            _updateLiveList(this);
            return this.$$length;
          },
        });

        Object.defineProperty(Node.prototype, "textContent", {
          get: function () {
            return getTextContent(this);
          },

          set: function (data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;

              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          },
        });

        function getTextContent(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        }

        __set__ = function (object, key, value) {
          //console.log(value)
          object["$$" + key] = value;
        };
      }
    } catch (e) {
      //ie8
    }

    //if(typeof require == 'function'){
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
    //}

    /***/
  },

  /***/ 8508: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var freeze = __nccwpck_require__(9756).freeze;

    /**
     * The entities that are predefined in every XML document.
     *
     * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
     * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
     */
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"',
    });

    /**
     * A map of all entities that are detected in an HTML document.
     * They contain all entries from `XML_ENTITIES`.
     *
     * @see XML_ENTITIES
     * @see DOMParser.parseFromString
     * @see DOMImplementation.prototype.createHTMLDocument
     * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
     * @see https://html.spec.whatwg.org/entities.json JSON
     * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
     * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
     */
    exports.HTML_ENTITIES = freeze({
      Aacute: "\u00C1",
      aacute: "\u00E1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\u00C2",
      acirc: "\u00E2",
      acute: "\u00B4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\u00C6",
      aelig: "\u00E6",
      af: "\u2061",
      Afr: "\uD835\uDD04",
      afr: "\uD835\uDD1E",
      Agrave: "\u00C0",
      agrave: "\u00E0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "\u0026",
      amp: "\u0026",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\u00C5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\uD835\uDD38",
      aopf: "\uD835\uDD52",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "\u0027",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\u00C5",
      aring: "\u00E5",
      Ascr: "\uD835\uDC9C",
      ascr: "\uD835\uDCB6",
      Assign: "\u2254",
      ast: "\u002A",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\u00C3",
      atilde: "\u00E3",
      Auml: "\u00C4",
      auml: "\u00E4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\uD835\uDD05",
      bfr: "\uD835\uDD1F",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "\u003D\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\uD835\uDD39",
      bopf: "\uD835\uDD53",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\u00A6",
      Bscr: "\u212C",
      bscr: "\uD835\uDCB7",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\u005C",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\u00C7",
      ccedil: "\u00E7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\u00B8",
      Cedilla: "\u00B8",
      cemptyv: "\u29B2",
      cent: "\u00A2",
      CenterDot: "\u00B7",
      centerdot: "\u00B7",
      Cfr: "\u212D",
      cfr: "\uD835\uDD20",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\u00AE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: "\u003A",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: "\u002C",
      commat: "\u0040",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\uD835\uDD54",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\u00A9",
      copy: "\u00A9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\uD835\uDC9E",
      cscr: "\uD835\uDCB8",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\u00A4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\u00B0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\uD835\uDD07",
      dfr: "\uD835\uDD21",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\u00B4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "\u0060",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\u00A8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\u00F7",
      divide: "\u00F7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "\u0024",
      Dopf: "\uD835\uDD3B",
      dopf: "\uD835\uDD55",
      Dot: "\u00A8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\u00A8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\uD835\uDC9F",
      dscr: "\uD835\uDCB9",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\u00C9",
      eacute: "\u00E9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\u00CA",
      ecirc: "\u00EA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\uD835\uDD08",
      efr: "\uD835\uDD22",
      eg: "\u2A9A",
      Egrave: "\u00C8",
      egrave: "\u00E8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\uD835\uDD3C",
      eopf: "\uD835\uDD56",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "\u003D",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\u00D0",
      eth: "\u00F0",
      Euml: "\u00CB",
      euml: "\u00EB",
      euro: "\u20AC",
      excl: "\u0021",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\uD835\uDD09",
      ffr: "\uD835\uDD23",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "\u0066\u006A",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\uD835\uDD3D",
      fopf: "\uD835\uDD57",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\u00BD",
      frac13: "\u2153",
      frac14: "\u00BC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\u00BE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\uD835\uDCBB",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\uD835\uDD0A",
      gfr: "\uD835\uDD24",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\uD835\uDD3E",
      gopf: "\uD835\uDD58",
      grave: "\u0060",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\uD835\uDCA2",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: "\u003E",
      gt: "\u003E",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\u00BD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "\u005E",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\uD835\uDD25",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\uD835\uDD59",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\uD835\uDCBD",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\u00CD",
      iacute: "\u00ED",
      ic: "\u2063",
      Icirc: "\u00CE",
      icirc: "\u00EE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\u00A1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\uD835\uDD26",
      Igrave: "\u00CC",
      igrave: "\u00EC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\uD835\uDD40",
      iopf: "\uD835\uDD5A",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\u00BF",
      Iscr: "\u2110",
      iscr: "\uD835\uDCBE",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\u00CF",
      iuml: "\u00EF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\uD835\uDD0D",
      jfr: "\uD835\uDD27",
      jmath: "\u0237",
      Jopf: "\uD835\uDD41",
      jopf: "\uD835\uDD5B",
      Jscr: "\uD835\uDCA5",
      jscr: "\uD835\uDCBF",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\uD835\uDD0E",
      kfr: "\uD835\uDD28",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\uD835\uDD42",
      kopf: "\uD835\uDD5C",
      Kscr: "\uD835\uDCA6",
      kscr: "\uD835\uDCC0",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\u00AB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "\u007B",
      lbrack: "\u005B",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "\u007B",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\uD835\uDD0F",
      lfr: "\uD835\uDD29",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\uD835\uDD43",
      lopf: "\uD835\uDD5D",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "\u005F",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "\u0028",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\uD835\uDCC1",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "\u005B",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "\u003C",
      lt: "\u003C",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\u00AF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\uD835\uDD10",
      mfr: "\uD835\uDD2A",
      mho: "\u2127",
      micro: "\u00B5",
      mid: "\u2223",
      midast: "\u002A",
      midcir: "\u2AF0",
      middot: "\u00B7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\uD835\uDD44",
      mopf: "\uD835\uDD5E",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\uD835\uDCC2",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\u00A0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\u000A",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\uD835\uDD11",
      nfr: "\uD835\uDD2B",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\u00A0",
      Nopf: "\u2115",
      nopf: "\uD835\uDD5F",
      Not: "\u2AEC",
      not: "\u00AC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\uD835\uDCA9",
      nscr: "\uD835\uDCC3",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\u00D1",
      ntilde: "\u00F1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "\u0023",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: "\u003E\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "\u003C\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\u00D3",
      oacute: "\u00F3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\u00D4",
      ocirc: "\u00F4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\uD835\uDD12",
      ofr: "\uD835\uDD2C",
      ogon: "\u02DB",
      Ograve: "\u00D2",
      ograve: "\u00F2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\uD835\uDD46",
      oopf: "\uD835\uDD60",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\u00AA",
      ordm: "\u00BA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\uD835\uDCAA",
      oscr: "\u2134",
      Oslash: "\u00D8",
      oslash: "\u00F8",
      osol: "\u2298",
      Otilde: "\u00D5",
      otilde: "\u00F5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\u00D6",
      ouml: "\u00F6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\u00B6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "\u0025",
      period: "\u002E",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\uD835\uDD13",
      pfr: "\uD835\uDD2D",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "\u002B",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\u00B1",
      plusmn: "\u00B1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\u00B1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\uD835\uDD61",
      pound: "\u00A3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\uD835\uDCAB",
      pscr: "\uD835\uDCC5",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\uD835\uDD14",
      qfr: "\uD835\uDD2E",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\uD835\uDD62",
      qprime: "\u2057",
      Qscr: "\uD835\uDCAC",
      qscr: "\uD835\uDCC6",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "\u003F",
      questeq: "\u225F",
      QUOT: "\u0022",
      quot: "\u0022",
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\u00BB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "\u007D",
      rbrack: "\u005D",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "\u007D",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\u00AE",
      reg: "\u00AE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\uD835\uDD2F",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\uD835\uDD63",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: "\u0029",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\uD835\uDCC7",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "\u005D",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\u00A7",
      semi: "\u003B",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\uD835\uDD16",
      sfr: "\uD835\uDD30",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\u00AD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "\u002F",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\uD835\uDD4A",
      sopf: "\uD835\uDD64",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\uD835\uDCAE",
      sscr: "\uD835\uDCC8",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\u00AF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\u00B9",
      sup2: "\u00B2",
      sup3: "\u00B3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\u00DF",
      Tab: "\u0009",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\uD835\uDD17",
      tfr: "\uD835\uDD31",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\u00DE",
      thorn: "\u00FE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\u00D7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\uD835\uDD4B",
      topf: "\uD835\uDD65",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\uD835\uDCAF",
      tscr: "\uD835\uDCC9",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\u00DA",
      uacute: "\u00FA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\u00DB",
      ucirc: "\u00FB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\uD835\uDD18",
      ufr: "\uD835\uDD32",
      Ugrave: "\u00D9",
      ugrave: "\u00F9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\u00A8",
      UnderBar: "\u005F",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\uD835\uDD4C",
      uopf: "\uD835\uDD66",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\uD835\uDCB0",
      uscr: "\uD835\uDCCA",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\u00DC",
      uuml: "\u00FC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "\u007C",
      Vert: "\u2016",
      vert: "\u007C",
      VerticalBar: "\u2223",
      VerticalLine: "\u007C",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\uD835\uDD19",
      vfr: "\uD835\uDD33",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\uD835\uDD4D",
      vopf: "\uD835\uDD67",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\uD835\uDCB1",
      vscr: "\uD835\uDCCB",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\uD835\uDD1A",
      wfr: "\uD835\uDD34",
      Wopf: "\uD835\uDD4E",
      wopf: "\uD835\uDD68",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\uD835\uDCB2",
      wscr: "\uD835\uDCCC",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\uD835\uDD1B",
      xfr: "\uD835\uDD35",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\uD835\uDD4F",
      xopf: "\uD835\uDD69",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\uD835\uDCB3",
      xscr: "\uD835\uDCCD",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\u00DD",
      yacute: "\u00FD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\u00A5",
      Yfr: "\uD835\uDD1C",
      yfr: "\uD835\uDD36",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\uD835\uDD50",
      yopf: "\uD835\uDD6A",
      Yscr: "\uD835\uDCB4",
      yscr: "\uD835\uDCCE",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\u00FF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\uD835\uDD37",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\uD835\uDD6B",
      Zscr: "\uD835\uDCB5",
      zscr: "\uD835\uDCCF",
      zwj: "\u200D",
      zwnj: "\u200C",
    });

    /**
     * @deprecated use `HTML_ENTITIES` instead
     * @see HTML_ENTITIES
     */
    exports.entityMap = exports.HTML_ENTITIES;

    /***/
  },

  /***/ 9213: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var dom = __nccwpck_require__(1389);
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = __nccwpck_require__(5072).DOMParser;

    /***/
  },

  /***/ 6058: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var NAMESPACE = __nccwpck_require__(9756).NAMESPACE;

    //[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
    //[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
    //[5]   	Name	   ::=   	NameStartChar (NameChar)*
    var nameStartChar =
      /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/; //\u10000-\uEFFFF
    var nameChar = new RegExp(
      "[\\-\\.0-9" +
        nameStartChar.source.slice(1, -1) +
        "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"
    );
    var tagNamePattern = new RegExp(
      "^" +
        nameStartChar.source +
        nameChar.source +
        "*(?::" +
        nameStartChar.source +
        nameChar.source +
        "*)?$"
    );
    //var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
    //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

    //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
    //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
    var S_TAG = 0; //tag name offerring
    var S_ATTR = 1; //attr name offerring
    var S_ATTR_SPACE = 2; //attr name end and space offer
    var S_EQ = 3; //=space?
    var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)
    var S_ATTR_END = 5; //attr value end and no space(quot end)
    var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)
    var S_TAG_CLOSE = 7; //closed el<el />

    /**
     * Creates an error that will not be caught by XMLReader aka the SAX parser.
     *
     * @param {string} message
     * @param {any?} locator Optional, can provide details about the location in the source
     * @constructor
     */
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;

    function XMLReader() {}

    XMLReader.prototype = {
      parse: function (source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, (defaultNSMap = {}));
        parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      },
    };
    function parse(
      source,
      defaultNSMapCopy,
      entityMap,
      domBuilder,
      errorHandler
    ) {
      function fixedFromCharCode(code) {
        // String.prototype.fromCharCode does not supports
        // > 2 bytes unicode chars directly
        if (code > 0xffff) {
          code -= 0x10000;
          var surrogate1 = 0xd800 + (code >> 10),
            surrogate2 = 0xdc00 + (code & 0x3ff);

          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a) {
        var k = a.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a);
          return a;
        }
      }
      function appendText(end) {
        //has some bugs
        if (end > start) {
          var xt = source
            .substring(start, end)
            .replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end - start);
          start = end;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
          //console.log('line++:',locator,startPos,endPos)
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;

      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source
                .substring(tagStart + 2, end)
                .replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error(
                  "end tag name: " +
                    tagName +
                    " is not complete:" +
                    config.tagName
                );
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error(
                  "end tag name: " + tagName + " maybe not complete"
                );
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach =
                endMatch ||
                (config.tagName &&
                  config.tagName.toLowerCase() == tagName.toLowerCase());
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (
                      Object.prototype.hasOwnProperty.call(localNSMap, prefix)
                    ) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError(
                    "end tag name: " +
                      tagName +
                      " is not match the current start tagName:" +
                      config.tagName
                  ); // No known test case
                }
              } else {
                parseStack.push(config);
              }

              end++;
              break;
            // end elment
            case "?": // <?...?>
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!": // <!doctype,<![CDATA,<!--
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              //elStartEnd
              var end = parseElementStartPart(
                source,
                tagStart,
                el,
                currentNSMap,
                entityReplacer,
                errorHandler
              );
              var len = el.length;

              if (
                !el.closed &&
                fixSelfClosed(source, end, el.tagName, closeMap)
              ) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                //try{//attribute position fixed
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }

              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(
                  source,
                  end,
                  el.tagName,
                  entityReplacer,
                  domBuilder
                );
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          //TODO: 这里有可能sax回退，有位置错误风险
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }

    /**
     * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
     * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
     */
    function parseElementStartPart(
      source,
      start,
      el,
      currentNSMap,
      entityReplacer,
      errorHandler
    ) {
      /**
       * @param {string} qname
       * @param {string} value
       * @param {number} startIndex
       */
      function addAttribute(qname, value, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG; //status
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              //attrName
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              //fatalError: equal must after attrName or space after attrName
              throw new Error("attribute equal must after attrName"); // No known test case
            }
            break;
          case "'":
          case '"':
            if (
              s === S_EQ ||
              s === S_ATTR //|| s == S_ATTR_SPACE
            ) {
              //equal
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                //fatalError: no end quot match
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning(
                'attribute "' + attrName + '" missed start quot(' + c + ")!!"
              );
              start = p + 1;
              s = S_ATTR_END;
            } else {
              //fatalError: no equal before
              throw new Error('attribute value must after "="'); // No known test case
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')"); // No known test case
            }
            break;
          case "": //end document
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break; //normal
              case S_ATTR_NOQUOT_VALUE: //Compatible state
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning(
                    'attribute "' + value + '" missed quot(")!'
                  );
                  addAttribute(attrName, value, start);
                } else {
                  if (
                    !NAMESPACE.isHTML(currentNSMap[""]) ||
                    !value.match(/^(?:disabled|checked|selected)$/i)
                  ) {
                    errorHandler.warning(
                      'attribute "' +
                        value +
                        '" missed value!! "' +
                        value +
                        '" instead!!'
                    );
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            //			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "\u0080":
            c = " ";
          default:
            if (c <= " ") {
              //space
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p)); //tagName
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning(
                    'attribute "' + value + '" missed quot(")!!'
                  );
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
                //case S_TAG_SPACE:
                //case S_EQ:
                //case S_ATTR_SPACE:
                //	void();break;
                //case S_TAG_CLOSE:
                //ignore warning
              }
            } else {
              //not space
              //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
              //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (
                    !NAMESPACE.isHTML(currentNSMap[""]) ||
                    !attrName.match(/^(?:disabled|checked|selected)$/i)
                  ) {
                    errorHandler.warning(
                      'attribute "' +
                        attrName +
                        '" missed value!! "' +
                        attrName +
                        '" instead2!!'
                    );
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning(
                    'attribute space is required"' + attrName + '"!!'
                  );
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error(
                    "elements closed character '/' and '>' must be connected to"
                  );
              }
            }
        } //end outer switch
        //console.log('p++',p)
        p++;
      }
    }
    /**
     * @return true if has new namespace define
     */
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = (a.prefix = qName.slice(0, nsp));
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        //can not set prefix,because prefix !== ''
        a.localName = localName;
        //prefix == null for no ns prefix attribute
        if (nsPrefix !== false) {
          //hack!!
          if (localNSMap == null) {
            localNSMap = {};
            //console.log(currentNSMap,0)
            _copy(currentNSMap, (currentNSMap = {}));
            //console.log(currentNSMap,1)
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          //no prefix attribute has no namespace
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];

            //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null; //important!!
        localName = el.localName = tagName;
      }
      //no prefix element has default namespace
      var ns = (el.uri = currentNSMap[prefix || ""]);
      domBuilder.startElement(ns, localName, tagName, el);
      //endPrefixMapping and startPrefixMapping have not any help for dom builder
      //localNSMap = null
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        //parseStack.push(el);
        return true;
      }
    }
    function parseHtmlSpecialContent(
      source,
      elStartEnd,
      tagName,
      entityReplacer,
      domBuilder
    ) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            //if(!/\]\]>/.test(text)){
            //lexHandler.startCDATA();
            domBuilder.characters(text, 0, text.length);
            //lexHandler.endCDATA();
            return elEndStart;
            //}
          } //}else{//text area
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
          //}
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      //if(tagName in closeMap){
      var pos = closeMap[tagName];
      if (pos == null) {
        //console.log(tagName)
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          //忘记闭合
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
      //}
    }

    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }

    function parseDCC(source, start, domBuilder, errorHandler) {
      //sure start with '<!'
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            //append comment source.substring(4,end)//<!--
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            //error
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          //<!DOCTYPE
          //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();

            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }

    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source
          .substring(start, end)
          .match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          //error
          return -1;
        }
      }
      return -1;
    }

    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function (tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function (qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName: qName, value: value, offset: offset };
      },
      length: 0,
      getLocalName: function (i) {
        return this[i].localName;
      },
      getLocator: function (i) {
        return this[i].locator;
      },
      getQName: function (i) {
        return this[i].qName;
      },
      getURI: function (i) {
        return this[i].uri;
      },
      getValue: function (i) {
        return this[i].value;
      },
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };

    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source); //skip <
      while ((match = reg.exec(source))) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }

    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;

    /***/
  },

  /***/ 6761: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const Utils = __nccwpck_require__(5182);
    const pth = __nccwpck_require__(1017);
    const ZipEntry = __nccwpck_require__(4057);
    const ZipFile = __nccwpck_require__(7744);

    const get_Bool = (val, def) => (typeof val === "boolean" ? val : def);
    const get_Str = (val, def) => (typeof val === "string" ? val : def);

    const defaultOptions = {
      // option "noSort" : if true it disables files sorting
      noSort: false,
      // read entries during load (initial loading may be slower)
      readEntries: false,
      // default method is none
      method: Utils.Constants.NONE,
      // file system
      fs: null,
    };

    module.exports = function (/**String*/ input, /** object */ options) {
      let inBuffer = null;

      // create object based default options, allowing them to be overwritten
      const opts = Object.assign(Object.create(null), defaultOptions);

      // test input variable
      if (input && "object" === typeof input) {
        // if value is not buffer we accept it to be object with options
        if (!(input instanceof Uint8Array)) {
          Object.assign(opts, input);
          input = opts.input ? opts.input : undefined;
          if (opts.input) delete opts.input;
        }

        // if input is buffer
        if (Buffer.isBuffer(input)) {
          inBuffer = input;
          opts.method = Utils.Constants.BUFFER;
          input = undefined;
        }
      }

      // assign options
      Object.assign(opts, options);

      // instanciate utils filesystem
      const filetools = new Utils(opts);

      // if input is file name we retrieve its content
      if (input && "string" === typeof input) {
        // load zip file
        if (filetools.fs.existsSync(input)) {
          opts.method = Utils.Constants.FILE;
          opts.filename = input;
          inBuffer = filetools.fs.readFileSync(input);
        } else {
          throw new Error(Utils.Errors.INVALID_FILENAME);
        }
      }

      // create variable
      const _zip = new ZipFile(inBuffer, opts);

      const { canonical, sanitize } = Utils;

      function getEntry(/**Object*/ entry) {
        if (entry && _zip) {
          var item;
          // If entry was given as a file name
          if (typeof entry === "string") item = _zip.getEntry(entry);
          // if entry was given as a ZipEntry object
          if (
            typeof entry === "object" &&
            typeof entry.entryName !== "undefined" &&
            typeof entry.header !== "undefined"
          )
            item = _zip.getEntry(entry.entryName);

          if (item) {
            return item;
          }
        }
        return null;
      }

      function fixPath(zipPath) {
        const { join, normalize, sep } = pth.posix;
        // convert windows file separators and normalize
        return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
      }

      return {
        /**
         * Extracts the given entry from the archive and returns the content as a Buffer object
         * @param entry ZipEntry object or String with the full path of the entry
         *
         * @return Buffer or Null in case of error
         */
        readFile: function (/**Object*/ entry, /*String, Buffer*/ pass) {
          var item = getEntry(entry);
          return (item && item.getData(pass)) || null;
        },

        /**
         * Asynchronous readFile
         * @param entry ZipEntry object or String with the full path of the entry
         * @param callback
         *
         * @return Buffer or Null in case of error
         */
        readFileAsync: function (/**Object*/ entry, /**Function*/ callback) {
          var item = getEntry(entry);
          if (item) {
            item.getDataAsync(callback);
          } else {
            callback(null, "getEntry failed for:" + entry);
          }
        },

        /**
         * Extracts the given entry from the archive and returns the content as plain text in the given encoding
         * @param entry ZipEntry object or String with the full path of the entry
         * @param encoding Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsText: function (/**Object*/ entry, /**String=*/ encoding) {
          var item = getEntry(entry);
          if (item) {
            var data = item.getData();
            if (data && data.length) {
              return data.toString(encoding || "utf8");
            }
          }
          return "";
        },

        /**
         * Asynchronous readAsText
         * @param entry ZipEntry object or String with the full path of the entry
         * @param callback
         * @param encoding Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsTextAsync: function (
          /**Object*/ entry,
          /**Function*/ callback,
          /**String=*/ encoding
        ) {
          var item = getEntry(entry);
          if (item) {
            item.getDataAsync(function (data, err) {
              if (err) {
                callback(data, err);
                return;
              }

              if (data && data.length) {
                callback(data.toString(encoding || "utf8"));
              } else {
                callback("");
              }
            });
          } else {
            callback("");
          }
        },

        /**
         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
         *
         * @param entry
         */
        deleteFile: function (/**Object*/ entry) {
          // @TODO: test deleteFile
          var item = getEntry(entry);
          if (item) {
            _zip.deleteEntry(item.entryName);
          }
        },

        /**
         * Adds a comment to the zip. The zip must be rewritten after adding the comment.
         *
         * @param comment
         */
        addZipComment: function (/**String*/ comment) {
          // @TODO: test addZipComment
          _zip.comment = comment;
        },

        /**
         * Returns the zip comment
         *
         * @return String
         */
        getZipComment: function () {
          return _zip.comment || "";
        },

        /**
         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
         * The comment cannot exceed 65535 characters in length
         *
         * @param entry
         * @param comment
         */
        addZipEntryComment: function (/**Object*/ entry, /**String*/ comment) {
          var item = getEntry(entry);
          if (item) {
            item.comment = comment;
          }
        },

        /**
         * Returns the comment of the specified entry
         *
         * @param entry
         * @return String
         */
        getZipEntryComment: function (/**Object*/ entry) {
          var item = getEntry(entry);
          if (item) {
            return item.comment || "";
          }
          return "";
        },

        /**
         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
         *
         * @param entry
         * @param content
         */
        updateFile: function (/**Object*/ entry, /**Buffer*/ content) {
          var item = getEntry(entry);
          if (item) {
            item.setData(content);
          }
        },

        /**
         * Adds a file from the disk to the archive
         *
         * @param localPath File to add to zip
         * @param zipPath Optional path inside the zip
         * @param zipName Optional name for the file
         */
        addLocalFile: function (
          /**String*/ localPath,
          /**String=*/ zipPath,
          /**String=*/ zipName,
          /**String*/ comment
        ) {
          if (filetools.fs.existsSync(localPath)) {
            // fix ZipPath
            zipPath = zipPath ? fixPath(zipPath) : "";

            // p - local file name
            var p = localPath.split("\\").join("/").split("/").pop();

            // add file name into zippath
            zipPath += zipName ? zipName : p;

            // read file attributes
            const _attr = filetools.fs.statSync(localPath);

            // add file into zip file
            this.addFile(
              zipPath,
              filetools.fs.readFileSync(localPath),
              comment,
              _attr
            );
          } else {
            throw new Error(
              Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath)
            );
          }
        },

        /**
         * Adds a local directory and all its nested files and directories to the archive
         *
         * @param localPath
         * @param zipPath optional path inside zip
         * @param filter optional RegExp or Function if files match will
         *               be included.
         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
         */
        addLocalFolder: function (
          /**String*/ localPath,
          /**String=*/ zipPath,
          /**=RegExp|Function*/ filter,
          /**=number|object*/ attr
        ) {
          // Prepare filter
          if (filter instanceof RegExp) {
            // if filter is RegExp wrap it
            filter = (function (rx) {
              return function (filename) {
                return rx.test(filename);
              };
            })(filter);
          } else if ("function" !== typeof filter) {
            // if filter is not function we will replace it
            filter = function () {
              return true;
            };
          }

          // fix ZipPath
          zipPath = zipPath ? fixPath(zipPath) : "";

          // normalize the path first
          localPath = pth.normalize(localPath);

          if (filetools.fs.existsSync(localPath)) {
            const items = filetools.findFiles(localPath);
            const self = this;

            if (items.length) {
              items.forEach(function (filepath) {
                var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                if (filter(p)) {
                  var stats = filetools.fs.statSync(filepath);
                  if (stats.isFile()) {
                    self.addFile(
                      zipPath + p,
                      filetools.fs.readFileSync(filepath),
                      "",
                      attr ? attr : stats
                    );
                  } else {
                    self.addFile(
                      zipPath + p + "/",
                      Buffer.alloc(0),
                      "",
                      attr ? attr : stats
                    );
                  }
                }
              });
            }
          } else {
            throw new Error(
              Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath)
            );
          }
        },

        /**
         * Asynchronous addLocalFile
         * @param localPath
         * @param callback
         * @param zipPath optional path inside zip
         * @param filter optional RegExp or Function if files match will
         *               be included.
         */
        addLocalFolderAsync: function (
          /*String*/ localPath,
          /*Function*/ callback,
          /*String*/ zipPath,
          /*RegExp|Function*/ filter
        ) {
          if (filter instanceof RegExp) {
            filter = (function (rx) {
              return function (filename) {
                return rx.test(filename);
              };
            })(filter);
          } else if ("function" !== typeof filter) {
            filter = function () {
              return true;
            };
          }

          // fix ZipPath
          zipPath = zipPath ? fixPath(zipPath) : "";

          // normalize the path first
          localPath = pth.normalize(localPath);

          var self = this;
          filetools.fs.open(localPath, "r", function (err) {
            if (err && err.code === "ENOENT") {
              callback(
                undefined,
                Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath)
              );
            } else if (err) {
              callback(undefined, err);
            } else {
              var items = filetools.findFiles(localPath);
              var i = -1;

              var next = function () {
                i += 1;
                if (i < items.length) {
                  var filepath = items[i];
                  var p = pth
                    .relative(localPath, filepath)
                    .split("\\")
                    .join("/"); //windows fix
                  p = p
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .replace(/[^\x20-\x7E]/g, ""); // accent fix
                  if (filter(p)) {
                    filetools.fs.stat(filepath, function (er0, stats) {
                      if (er0) callback(undefined, er0);
                      if (stats.isFile()) {
                        filetools.fs.readFile(filepath, function (er1, data) {
                          if (er1) {
                            callback(undefined, er1);
                          } else {
                            self.addFile(zipPath + p, data, "", stats);
                            next();
                          }
                        });
                      } else {
                        self.addFile(
                          zipPath + p + "/",
                          Buffer.alloc(0),
                          "",
                          stats
                        );
                        next();
                      }
                    });
                  } else {
                    process.nextTick(() => {
                      next();
                    });
                  }
                } else {
                  callback(true, undefined);
                }
              };

              next();
            }
          });
        },

        /**
         *
         * @param {string} localPath - path where files will be extracted
         * @param {object} props - optional properties
         * @param {string} props.zipPath - optional path inside zip
         * @param {regexp, function} props.filter - RegExp or Function if files match will be included.
         */
        addLocalFolderPromise: function (
          /*String*/ localPath,
          /* object */ props
        ) {
          return new Promise((resolve, reject) => {
            const { filter, zipPath } = Object.assign({}, props);
            this.addLocalFolderAsync(
              localPath,
              (done, err) => {
                if (err) reject(err);
                if (done) resolve(this);
              },
              zipPath,
              filter
            );
          });
        },

        /**
         * Allows you to create a entry (file or directory) in the zip file.
         * If you want to create a directory the entryName must end in / and a null buffer should be provided.
         * Comment and attributes are optional
         *
         * @param {string} entryName
         * @param {Buffer | string} content - file content as buffer or utf8 coded string
         * @param {string} comment - file comment
         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
         */
        addFile: function (
          /**String*/ entryName,
          /**Buffer*/ content,
          /**String*/ comment,
          /**Number*/ attr
        ) {
          let entry = getEntry(entryName);
          const update = entry != null;

          // prepare new entry
          if (!update) {
            entry = new ZipEntry();
            entry.entryName = entryName;
          }
          entry.comment = comment || "";

          const isStat =
            "object" === typeof attr && attr instanceof filetools.fs.Stats;

          // last modification time from file stats
          if (isStat) {
            entry.header.time = attr.mtime;
          }

          // Set file attribute
          var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)

          // extended attributes field for Unix
          // set file type either S_IFDIR / S_IFREG
          let unix = entry.isDirectory ? 0x4000 : 0x8000;

          if (isStat) {
            // File attributes from file stats
            unix |= 0xfff & attr.mode;
          } else if ("number" === typeof attr) {
            // attr from given attr values
            unix |= 0xfff & attr;
          } else {
            // Default values:
            unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)
          }

          fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes

          entry.attr = fileattr;

          entry.setData(content);
          if (!update) _zip.setEntry(entry);
        },

        /**
         * Returns an array of ZipEntry objects representing the files and folders inside the archive
         *
         * @return Array
         */
        getEntries: function () {
          return _zip ? _zip.entries : [];
        },

        /**
         * Returns a ZipEntry object representing the file or folder specified by ``name``.
         *
         * @param name
         * @return ZipEntry
         */
        getEntry: function (/**String*/ name) {
          return getEntry(name);
        },

        getEntryCount: function () {
          return _zip.getEntryCount();
        },

        forEach: function (callback) {
          return _zip.forEach(callback);
        },

        /**
         * Extracts the given entry to the given targetPath
         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
         *
         * @param entry ZipEntry object or String with the full path of the entry
         * @param targetPath Target folder where to write the file
         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
         *                          will be created in targetPath as well. Default is TRUE
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)
         *
         * @return Boolean
         */
        extractEntryTo: function (
          /**Object*/ entry,
          /**String*/ targetPath,
          /**Boolean*/ maintainEntryPath,
          /**Boolean*/ overwrite,
          /**Boolean*/ keepOriginalPermission,
          /**String**/ outFileName
        ) {
          overwrite = get_Bool(overwrite, false);
          keepOriginalPermission = get_Bool(keepOriginalPermission, false);
          maintainEntryPath = get_Bool(maintainEntryPath, true);
          outFileName = get_Str(
            outFileName,
            get_Str(keepOriginalPermission, undefined)
          );

          var item = getEntry(entry);
          if (!item) {
            throw new Error(Utils.Errors.NO_ENTRY);
          }

          var entryName = canonical(item.entryName);

          var target = sanitize(
            targetPath,
            outFileName && !item.isDirectory
              ? outFileName
              : maintainEntryPath
                ? entryName
                : pth.basename(entryName)
          );

          if (item.isDirectory) {
            var children = _zip.getEntryChildren(item);
            children.forEach(function (child) {
              if (child.isDirectory) return;
              var content = child.getData();
              if (!content) {
                throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
              }
              var name = canonical(child.entryName);
              var childName = sanitize(
                targetPath,
                maintainEntryPath ? name : pth.basename(name)
              );
              // The reverse operation for attr depend on method addFile()
              const fileAttr = keepOriginalPermission
                ? child.header.fileAttr
                : undefined;
              filetools.writeFileTo(childName, content, overwrite, fileAttr);
            });
            return true;
          }

          var content = item.getData();
          if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);

          if (filetools.fs.existsSync(target) && !overwrite) {
            throw new Error(Utils.Errors.CANT_OVERRIDE);
          }
          // The reverse operation for attr depend on method addFile()
          const fileAttr = keepOriginalPermission
            ? entry.header.fileAttr
            : undefined;
          filetools.writeFileTo(target, content, overwrite, fileAttr);

          return true;
        },

        /**
         * Test the archive
         *
         */
        test: function (pass) {
          if (!_zip) {
            return false;
          }

          for (var entry in _zip.entries) {
            try {
              if (entry.isDirectory) {
                continue;
              }
              var content = _zip.entries[entry].getData(pass);
              if (!content) {
                return false;
              }
            } catch (err) {
              return false;
            }
          }
          return true;
        },

        /**
         * Extracts the entire archive to the given location
         *
         * @param targetPath Target location
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         */
        extractAllTo: function (
          /**String*/ targetPath,
          /**Boolean*/ overwrite,
          /**Boolean*/ keepOriginalPermission,
          /*String, Buffer*/ pass
        ) {
          overwrite = get_Bool(overwrite, false);
          pass = get_Str(keepOriginalPermission, pass);
          keepOriginalPermission = get_Bool(keepOriginalPermission, false);
          if (!_zip) {
            throw new Error(Utils.Errors.NO_ZIP);
          }
          _zip.entries.forEach(function (entry) {
            var entryName = sanitize(
              targetPath,
              canonical(entry.entryName.toString())
            );
            if (entry.isDirectory) {
              filetools.makeDir(entryName);
              return;
            }
            var content = entry.getData(pass);
            if (!content) {
              throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
            }
            // The reverse operation for attr depend on method addFile()
            const fileAttr = keepOriginalPermission
              ? entry.header.fileAttr
              : undefined;
            filetools.writeFileTo(entryName, content, overwrite, fileAttr);
            try {
              filetools.fs.utimesSync(
                entryName,
                entry.header.time,
                entry.header.time
              );
            } catch (err) {
              throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
            }
          });
        },

        /**
         * Asynchronous extractAllTo
         *
         * @param targetPath Target location
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.
         */
        extractAllToAsync: function (
          /**String*/ targetPath,
          /**Boolean*/ overwrite,
          /**Boolean*/ keepOriginalPermission,
          /**Function*/ callback
        ) {
          overwrite = get_Bool(overwrite, false);
          if (typeof keepOriginalPermission === "function" && !callback)
            callback = keepOriginalPermission;
          keepOriginalPermission = get_Bool(keepOriginalPermission, false);
          if (!callback) {
            callback = function (err) {
              throw new Error(err);
            };
          }
          if (!_zip) {
            callback(new Error(Utils.Errors.NO_ZIP));
            return;
          }

          targetPath = pth.resolve(targetPath);
          // convert entryName to
          const getPath = (entry) =>
            sanitize(
              targetPath,
              pth.normalize(canonical(entry.entryName.toString()))
            );
          const getError = (msg, file) => new Error(msg + ': "' + file + '"');

          // separate directories from files
          const dirEntries = [];
          const fileEntries = new Set();
          _zip.entries.forEach((e) => {
            if (e.isDirectory) {
              dirEntries.push(e);
            } else {
              fileEntries.add(e);
            }
          });

          // Create directory entries first synchronously
          // this prevents race condition and assures folders are there before writing files
          for (const entry of dirEntries) {
            const dirPath = getPath(entry);
            // The reverse operation for attr depend on method addFile()
            const dirAttr = keepOriginalPermission
              ? entry.header.fileAttr
              : undefined;
            try {
              filetools.makeDir(dirPath);
              if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);
              // in unix timestamp will change if files are later added to folder, but still
              filetools.fs.utimesSync(
                dirPath,
                entry.header.time,
                entry.header.time
              );
            } catch (er) {
              callback(getError("Unable to create folder", dirPath));
            }
          }

          // callback wrapper, for some house keeping
          const done = () => {
            if (fileEntries.size === 0) {
              callback();
            }
          };

          // Extract file entries asynchronously
          for (const entry of fileEntries.values()) {
            const entryName = pth.normalize(
              canonical(entry.entryName.toString())
            );
            const filePath = sanitize(targetPath, entryName);
            entry.getDataAsync(function (content, err_1) {
              if (err_1) {
                callback(new Error(err_1));
                return;
              }
              if (!content) {
                callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));
              } else {
                // The reverse operation for attr depend on method addFile()
                const fileAttr = keepOriginalPermission
                  ? entry.header.fileAttr
                  : undefined;
                filetools.writeFileToAsync(
                  filePath,
                  content,
                  overwrite,
                  fileAttr,
                  function (succ) {
                    if (!succ) {
                      callback(getError("Unable to write file", filePath));
                      return;
                    }
                    filetools.fs.utimes(
                      filePath,
                      entry.header.time,
                      entry.header.time,
                      function (err_2) {
                        if (err_2) {
                          callback(getError("Unable to set times", filePath));
                          return;
                        }
                        fileEntries.delete(entry);
                        // call the callback if it was last entry
                        done();
                      }
                    );
                  }
                );
              }
            });
          }
          // call the callback if fileEntries was empty
          done();
        },

        /**
         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
         *
         * @param targetFileName
         * @param callback
         */
        writeZip: function (
          /**String*/ targetFileName,
          /**Function*/ callback
        ) {
          if (arguments.length === 1) {
            if (typeof targetFileName === "function") {
              callback = targetFileName;
              targetFileName = "";
            }
          }

          if (!targetFileName && opts.filename) {
            targetFileName = opts.filename;
          }
          if (!targetFileName) return;

          var zipData = _zip.compressToBuffer();
          if (zipData) {
            var ok = filetools.writeFileTo(targetFileName, zipData, true);
            if (typeof callback === "function")
              callback(!ok ? new Error("failed") : null, "");
          }
        },

        writeZipPromise: function (
          /**String*/ targetFileName,
          /* object */ props
        ) {
          const { overwrite, perm } = Object.assign({ overwrite: true }, props);

          return new Promise((resolve, reject) => {
            // find file name
            if (!targetFileName && opts.filename)
              targetFileName = opts.filename;
            if (!targetFileName) reject("ADM-ZIP: ZIP File Name Missing");

            this.toBufferPromise().then((zipData) => {
              const ret = (done) =>
                done
                  ? resolve(done)
                  : reject("ADM-ZIP: Wasn't able to write zip file");
              filetools.writeFileToAsync(
                targetFileName,
                zipData,
                overwrite,
                perm,
                ret
              );
            }, reject);
          });
        },

        toBufferPromise: function () {
          return new Promise((resolve, reject) => {
            _zip.toAsyncBuffer(resolve, reject);
          });
        },

        /**
         * Returns the content of the entire zip file as a Buffer object
         *
         * @return Buffer
         */
        toBuffer: function (
          /**Function=*/ onSuccess,
          /**Function=*/ onFail,
          /**Function=*/ onItemStart,
          /**Function=*/ onItemEnd
        ) {
          this.valueOf = 2;
          if (typeof onSuccess === "function") {
            _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
            return null;
          }
          return _zip.compressToBuffer();
        },
      };
    };

    /***/
  },

  /***/ 9032: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    var Utils = __nccwpck_require__(5182),
      Constants = Utils.Constants;

    /* The central directory file header */
    module.exports = function () {
      var _verMade = 20, // v2.0
        _version = 10, // v1.0
        _flags = 0,
        _method = 0,
        _time = 0,
        _crc = 0,
        _compressedSize = 0,
        _size = 0,
        _fnameLen = 0,
        _extraLen = 0,
        _comLen = 0,
        _diskStart = 0,
        _inattr = 0,
        _attr = 0,
        _offset = 0;

      _verMade |= Utils.isWin ? 0x0a00 : 0x0300;

      // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.
      // Without it file names may be corrupted for other apps when file names use unicode chars
      _flags |= Constants.FLG_EFS;

      var _dataHeader = {};

      function setTime(val) {
        val = new Date(val);
        _time =
          (((val.getFullYear() - 1980) & 0x7f) << 25) | // b09-16 years from 1980
          ((val.getMonth() + 1) << 21) | // b05-08 month
          (val.getDate() << 16) | // b00-04 hour
          // 2 bytes time
          (val.getHours() << 11) | // b11-15 hour
          (val.getMinutes() << 5) | // b05-10 minute
          (val.getSeconds() >> 1); // b00-04 seconds divided by 2
      }

      setTime(+new Date());

      return {
        get made() {
          return _verMade;
        },
        set made(val) {
          _verMade = val;
        },

        get version() {
          return _version;
        },
        set version(val) {
          _version = val;
        },

        get flags() {
          return _flags;
        },
        set flags(val) {
          _flags = val;
        },

        get method() {
          return _method;
        },
        set method(val) {
          switch (val) {
            case Constants.STORED:
              this.version = 10;
            case Constants.DEFLATED:
            default:
              this.version = 20;
          }
          _method = val;
        },

        get time() {
          return new Date(
            ((_time >> 25) & 0x7f) + 1980,
            ((_time >> 21) & 0x0f) - 1,
            (_time >> 16) & 0x1f,
            (_time >> 11) & 0x1f,
            (_time >> 5) & 0x3f,
            (_time & 0x1f) << 1
          );
        },
        set time(val) {
          setTime(val);
        },

        get crc() {
          return _crc;
        },
        set crc(val) {
          _crc = Math.max(0, val) >>> 0;
        },

        get compressedSize() {
          return _compressedSize;
        },
        set compressedSize(val) {
          _compressedSize = Math.max(0, val) >>> 0;
        },

        get size() {
          return _size;
        },
        set size(val) {
          _size = Math.max(0, val) >>> 0;
        },

        get fileNameLength() {
          return _fnameLen;
        },
        set fileNameLength(val) {
          _fnameLen = val;
        },

        get extraLength() {
          return _extraLen;
        },
        set extraLength(val) {
          _extraLen = val;
        },

        get commentLength() {
          return _comLen;
        },
        set commentLength(val) {
          _comLen = val;
        },

        get diskNumStart() {
          return _diskStart;
        },
        set diskNumStart(val) {
          _diskStart = Math.max(0, val) >>> 0;
        },

        get inAttr() {
          return _inattr;
        },
        set inAttr(val) {
          _inattr = Math.max(0, val) >>> 0;
        },

        get attr() {
          return _attr;
        },
        set attr(val) {
          _attr = Math.max(0, val) >>> 0;
        },

        // get Unix file permissions
        get fileAttr() {
          return _attr ? (((_attr >>> 0) | 0) >> 16) & 0xfff : 0;
        },

        get offset() {
          return _offset;
        },
        set offset(val) {
          _offset = Math.max(0, val) >>> 0;
        },

        get encripted() {
          return (_flags & 1) === 1;
        },

        get entryHeaderSize() {
          return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
        },

        get realDataOffset() {
          return (
            _offset +
            Constants.LOCHDR +
            _dataHeader.fnameLen +
            _dataHeader.extraLen
          );
        },

        get dataHeader() {
          return _dataHeader;
        },

        loadDataHeaderFromBinary: function (/*Buffer*/ input) {
          var data = input.slice(_offset, _offset + Constants.LOCHDR);
          // 30 bytes and should start with "PK\003\004"
          if (data.readUInt32LE(0) !== Constants.LOCSIG) {
            throw new Error(Utils.Errors.INVALID_LOC);
          }
          _dataHeader = {
            // version needed to extract
            version: data.readUInt16LE(Constants.LOCVER),
            // general purpose bit flag
            flags: data.readUInt16LE(Constants.LOCFLG),
            // compression method
            method: data.readUInt16LE(Constants.LOCHOW),
            // modification time (2 bytes time, 2 bytes date)
            time: data.readUInt32LE(Constants.LOCTIM),
            // uncompressed file crc-32 value
            crc: data.readUInt32LE(Constants.LOCCRC),
            // compressed size
            compressedSize: data.readUInt32LE(Constants.LOCSIZ),
            // uncompressed size
            size: data.readUInt32LE(Constants.LOCLEN),
            // filename length
            fnameLen: data.readUInt16LE(Constants.LOCNAM),
            // extra field length
            extraLen: data.readUInt16LE(Constants.LOCEXT),
          };
        },

        loadFromBinary: function (/*Buffer*/ data) {
          // data should be 46 bytes and start with "PK 01 02"
          if (
            data.length !== Constants.CENHDR ||
            data.readUInt32LE(0) !== Constants.CENSIG
          ) {
            throw new Error(Utils.Errors.INVALID_CEN);
          }
          // version made by
          _verMade = data.readUInt16LE(Constants.CENVEM);
          // version needed to extract
          _version = data.readUInt16LE(Constants.CENVER);
          // encrypt, decrypt flags
          _flags = data.readUInt16LE(Constants.CENFLG);
          // compression method
          _method = data.readUInt16LE(Constants.CENHOW);
          // modification time (2 bytes time, 2 bytes date)
          _time = data.readUInt32LE(Constants.CENTIM);
          // uncompressed file crc-32 value
          _crc = data.readUInt32LE(Constants.CENCRC);
          // compressed size
          _compressedSize = data.readUInt32LE(Constants.CENSIZ);
          // uncompressed size
          _size = data.readUInt32LE(Constants.CENLEN);
          // filename length
          _fnameLen = data.readUInt16LE(Constants.CENNAM);
          // extra field length
          _extraLen = data.readUInt16LE(Constants.CENEXT);
          // file comment length
          _comLen = data.readUInt16LE(Constants.CENCOM);
          // volume number start
          _diskStart = data.readUInt16LE(Constants.CENDSK);
          // internal file attributes
          _inattr = data.readUInt16LE(Constants.CENATT);
          // external file attributes
          _attr = data.readUInt32LE(Constants.CENATX);
          // LOC header offset
          _offset = data.readUInt32LE(Constants.CENOFF);
        },

        dataHeaderToBinary: function () {
          // LOC header size (30 bytes)
          var data = Buffer.alloc(Constants.LOCHDR);
          // "PK\003\004"
          data.writeUInt32LE(Constants.LOCSIG, 0);
          // version needed to extract
          data.writeUInt16LE(_version, Constants.LOCVER);
          // general purpose bit flag
          data.writeUInt16LE(_flags, Constants.LOCFLG);
          // compression method
          data.writeUInt16LE(_method, Constants.LOCHOW);
          // modification time (2 bytes time, 2 bytes date)
          data.writeUInt32LE(_time, Constants.LOCTIM);
          // uncompressed file crc-32 value
          data.writeUInt32LE(_crc, Constants.LOCCRC);
          // compressed size
          data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
          // uncompressed size
          data.writeUInt32LE(_size, Constants.LOCLEN);
          // filename length
          data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
          // extra field length
          data.writeUInt16LE(_extraLen, Constants.LOCEXT);
          return data;
        },

        entryHeaderToBinary: function () {
          // CEN header size (46 bytes)
          var data = Buffer.alloc(
            Constants.CENHDR + _fnameLen + _extraLen + _comLen
          );
          // "PK\001\002"
          data.writeUInt32LE(Constants.CENSIG, 0);
          // version made by
          data.writeUInt16LE(_verMade, Constants.CENVEM);
          // version needed to extract
          data.writeUInt16LE(_version, Constants.CENVER);
          // encrypt, decrypt flags
          data.writeUInt16LE(_flags, Constants.CENFLG);
          // compression method
          data.writeUInt16LE(_method, Constants.CENHOW);
          // modification time (2 bytes time, 2 bytes date)
          data.writeUInt32LE(_time, Constants.CENTIM);
          // uncompressed file crc-32 value
          data.writeUInt32LE(_crc, Constants.CENCRC);
          // compressed size
          data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
          // uncompressed size
          data.writeUInt32LE(_size, Constants.CENLEN);
          // filename length
          data.writeUInt16LE(_fnameLen, Constants.CENNAM);
          // extra field length
          data.writeUInt16LE(_extraLen, Constants.CENEXT);
          // file comment length
          data.writeUInt16LE(_comLen, Constants.CENCOM);
          // volume number start
          data.writeUInt16LE(_diskStart, Constants.CENDSK);
          // internal file attributes
          data.writeUInt16LE(_inattr, Constants.CENATT);
          // external file attributes
          data.writeUInt32LE(_attr, Constants.CENATX);
          // LOC header offset
          data.writeUInt32LE(_offset, Constants.CENOFF);
          // fill all with
          data.fill(0x00, Constants.CENHDR);
          return data;
        },

        toJSON: function () {
          const bytes = function (nr) {
            return nr + " bytes";
          };

          return {
            made: _verMade,
            version: _version,
            flags: _flags,
            method: Utils.methodToString(_method),
            time: this.time,
            crc: "0x" + _crc.toString(16).toUpperCase(),
            compressedSize: bytes(_compressedSize),
            size: bytes(_size),
            fileNameLength: bytes(_fnameLen),
            extraLength: bytes(_extraLen),
            commentLength: bytes(_comLen),
            diskNumStart: _diskStart,
            inAttr: _inattr,
            attr: _attr,
            offset: _offset,
            entryHeaderSize: bytes(
              Constants.CENHDR + _fnameLen + _extraLen + _comLen
            ),
          };
        },

        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        },
      };
    };

    /***/
  },

  /***/ 4958: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    exports.EntryHeader = __nccwpck_require__(9032);
    exports.MainHeader = __nccwpck_require__(8952);

    /***/
  },

  /***/ 8952: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    var Utils = __nccwpck_require__(5182),
      Constants = Utils.Constants;

    /* The entries in the end of central directory */
    module.exports = function () {
      var _volumeEntries = 0,
        _totalEntries = 0,
        _size = 0,
        _offset = 0,
        _commentLength = 0;

      return {
        get diskEntries() {
          return _volumeEntries;
        },
        set diskEntries(/*Number*/ val) {
          _volumeEntries = _totalEntries = val;
        },

        get totalEntries() {
          return _totalEntries;
        },
        set totalEntries(/*Number*/ val) {
          _totalEntries = _volumeEntries = val;
        },

        get size() {
          return _size;
        },
        set size(/*Number*/ val) {
          _size = val;
        },

        get offset() {
          return _offset;
        },
        set offset(/*Number*/ val) {
          _offset = val;
        },

        get commentLength() {
          return _commentLength;
        },
        set commentLength(/*Number*/ val) {
          _commentLength = val;
        },

        get mainHeaderSize() {
          return Constants.ENDHDR + _commentLength;
        },

        loadFromBinary: function (/*Buffer*/ data) {
          // data should be 22 bytes and start with "PK 05 06"
          // or be 56+ bytes and start with "PK 06 06" for Zip64
          if (
            (data.length !== Constants.ENDHDR ||
              data.readUInt32LE(0) !== Constants.ENDSIG) &&
            (data.length < Constants.ZIP64HDR ||
              data.readUInt32LE(0) !== Constants.ZIP64SIG)
          ) {
            throw new Error(Utils.Errors.INVALID_END);
          }

          if (data.readUInt32LE(0) === Constants.ENDSIG) {
            // number of entries on this volume
            _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
            // total number of entries
            _totalEntries = data.readUInt16LE(Constants.ENDTOT);
            // central directory size in bytes
            _size = data.readUInt32LE(Constants.ENDSIZ);
            // offset of first CEN header
            _offset = data.readUInt32LE(Constants.ENDOFF);
            // zip file comment length
            _commentLength = data.readUInt16LE(Constants.ENDCOM);
          } else {
            // number of entries on this volume
            _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
            // total number of entries
            _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
            // central directory size in bytes
            _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);
            // offset of first CEN header
            _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);

            _commentLength = 0;
          }
        },

        toBinary: function () {
          var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
          // "PK 05 06" signature
          b.writeUInt32LE(Constants.ENDSIG, 0);
          b.writeUInt32LE(0, 4);
          // number of entries on this volume
          b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
          // total number of entries
          b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
          // central directory size in bytes
          b.writeUInt32LE(_size, Constants.ENDSIZ);
          // offset of first CEN header
          b.writeUInt32LE(_offset, Constants.ENDOFF);
          // zip file comment length
          b.writeUInt16LE(_commentLength, Constants.ENDCOM);
          // fill comment memory with spaces so no garbage is left there
          b.fill(" ", Constants.ENDHDR);

          return b;
        },

        toJSON: function () {
          // creates 0x0000 style output
          const offset = function (nr, len) {
            let offs = nr.toString(16).toUpperCase();
            while (offs.length < len) offs = "0" + offs;
            return "0x" + offs;
          };

          return {
            diskEntries: _volumeEntries,
            totalEntries: _totalEntries,
            size: _size + " bytes",
            offset: offset(_offset, 4),
            commentLength: _commentLength,
          };
        },

        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        },
      };
    };
    // Misspelled

    /***/
  },

  /***/ 7686: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = function (/*Buffer*/ inbuf) {
      var zlib = __nccwpck_require__(9796);

      var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };

      return {
        deflate: function () {
          return zlib.deflateRawSync(inbuf, opts);
        },

        deflateAsync: function (/*Function*/ callback) {
          var tmp = zlib.createDeflateRaw(opts),
            parts = [],
            total = 0;
          tmp.on("data", function (data) {
            parts.push(data);
            total += data.length;
          });
          tmp.on("end", function () {
            var buf = Buffer.alloc(total),
              written = 0;
            buf.fill(0);
            for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              part.copy(buf, written);
              written += part.length;
            }
            callback && callback(buf);
          });
          tmp.end(inbuf);
        },
      };
    };

    /***/
  },

  /***/ 3928: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    exports.Deflater = __nccwpck_require__(7686);
    exports.Inflater = __nccwpck_require__(2153);
    exports.ZipCrypto = __nccwpck_require__(3228);

    /***/
  },

  /***/ 2153: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = function (/*Buffer*/ inbuf) {
      var zlib = __nccwpck_require__(9796);

      return {
        inflate: function () {
          return zlib.inflateRawSync(inbuf);
        },

        inflateAsync: function (/*Function*/ callback) {
          var tmp = zlib.createInflateRaw(),
            parts = [],
            total = 0;
          tmp.on("data", function (data) {
            parts.push(data);
            total += data.length;
          });
          tmp.on("end", function () {
            var buf = Buffer.alloc(total),
              written = 0;
            buf.fill(0);
            for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              part.copy(buf, written);
              written += part.length;
            }
            callback && callback(buf);
          });
          tmp.end(inbuf);
        },
      };
    };

    /***/
  },

  /***/ 3228: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // node crypt, we use it for generate salt
    // eslint-disable-next-line node/no-unsupported-features/node-builtins
    const { randomFillSync } = __nccwpck_require__(6113);

    // generate CRC32 lookup table
    const crctable = new Uint32Array(256).map((t, crc) => {
      for (let j = 0; j < 8; j++) {
        if (0 !== (crc & 1)) {
          crc = (crc >>> 1) ^ 0xedb88320;
        } else {
          crc >>>= 1;
        }
      }
      return crc >>> 0;
    });

    // C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)
    const uMul = (a, b) => Math.imul(a, b) >>> 0;

    // crc32 byte single update (actually same function is part of utils.crc32 function :) )
    const crc32update = (pCrc32, bval) => {
      return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);
    };

    // function for generating salt for encrytion header
    const genSalt = () => {
      if ("function" === typeof randomFillSync) {
        return randomFillSync(Buffer.alloc(12));
      } else {
        // fallback if function is not defined
        return genSalt.node();
      }
    };

    // salt generation with node random function (mainly as fallback)
    genSalt.node = () => {
      const salt = Buffer.alloc(12);
      const len = salt.length;
      for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;
      return salt;
    };

    // general config
    const config = {
      genSalt,
    };

    // Class Initkeys handles same basic ops with keys
    function Initkeys(pw) {
      const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
      this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);
      for (let i = 0; i < pass.length; i++) {
        this.updateKeys(pass[i]);
      }
    }

    Initkeys.prototype.updateKeys = function (byteValue) {
      const keys = this.keys;
      keys[0] = crc32update(keys[0], byteValue);
      keys[1] += keys[0] & 0xff;
      keys[1] = uMul(keys[1], 134775813) + 1;
      keys[2] = crc32update(keys[2], keys[1] >>> 24);
      return byteValue;
    };

    Initkeys.prototype.next = function () {
      const k = (this.keys[2] | 2) >>> 0; // key
      return (uMul(k, k ^ 1) >> 8) & 0xff; // decode
    };

    function make_decrypter(/*Buffer*/ pwd) {
      // 1. Stage initialize key
      const keys = new Initkeys(pwd);

      // return decrypter function
      return function (/*Buffer*/ data) {
        // result - we create new Buffer for results
        const result = Buffer.alloc(data.length);
        let pos = 0;
        // process input data
        for (let c of data) {
          //c ^= keys.next();
          //result[pos++] = c; // decode & Save Value
          result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte
        }
        return result;
      };
    }

    function make_encrypter(/*Buffer*/ pwd) {
      // 1. Stage initialize key
      const keys = new Initkeys(pwd);

      // return encrypting function, result and pos is here so we dont have to merge buffers later
      return function (
        /*Buffer*/ data,
        /*Buffer*/ result,
        /* Number */ pos = 0
      ) {
        // result - we create new Buffer for results
        if (!result) result = Buffer.alloc(data.length);
        // process input data
        for (let c of data) {
          const k = keys.next(); // save key byte
          result[pos++] = c ^ k; // save val
          keys.updateKeys(c); // update keys with decoded byte
        }
        return result;
      };
    }

    function decrypt(
      /*Buffer*/ data,
      /*Object*/ header,
      /*String, Buffer*/ pwd
    ) {
      if (!data || !Buffer.isBuffer(data) || data.length < 12) {
        return Buffer.alloc(0);
      }

      // 1. We Initialize and generate decrypting function
      const decrypter = make_decrypter(pwd);

      // 2. decrypt salt what is always 12 bytes and is a part of file content
      const salt = decrypter(data.slice(0, 12));

      // 3. does password meet expectations
      if (salt[11] !== header.crc >>> 24) {
        throw "ADM-ZIP: Wrong Password";
      }

      // 4. decode content
      return decrypter(data.slice(12));
    }

    // lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality
    function _salter(data) {
      if (Buffer.isBuffer(data) && data.length >= 12) {
        // be aware - currently salting buffer data is modified
        config.genSalt = function () {
          return data.slice(0, 12);
        };
      } else if (data === "node") {
        // test salt generation with node random function
        config.genSalt = genSalt.node;
      } else {
        // if value is not acceptable config gets reset.
        config.genSalt = genSalt;
      }
    }

    function encrypt(
      /*Buffer*/ data,
      /*Object*/ header,
      /*String, Buffer*/ pwd,
      /*Boolean*/ oldlike = false
    ) {
      // 1. test data if data is not Buffer we make buffer from it
      if (data == null) data = Buffer.alloc(0);
      // if data is not buffer be make buffer from it
      if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());

      // 2. We Initialize and generate encrypting function
      const encrypter = make_encrypter(pwd);

      // 3. generate salt (12-bytes of random data)
      const salt = config.genSalt();
      salt[11] = (header.crc >>> 24) & 0xff;

      // old implementations (before PKZip 2.04g) used two byte check
      if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;

      // 4. create output
      const result = Buffer.alloc(data.length + 12);
      encrypter(salt, result);

      // finally encode content
      return encrypter(data, result, 12);
    }

    module.exports = { decrypt, encrypt, _salter };

    /***/
  },

  /***/ 4522: /***/ (module) => {
    module.exports = {
      /* The local file header */
      LOCHDR: 30, // LOC header size
      LOCSIG: 0x04034b50, // "PK\003\004"
      LOCVER: 4, // version needed to extract
      LOCFLG: 6, // general purpose bit flag
      LOCHOW: 8, // compression method
      LOCTIM: 10, // modification time (2 bytes time, 2 bytes date)
      LOCCRC: 14, // uncompressed file crc-32 value
      LOCSIZ: 18, // compressed size
      LOCLEN: 22, // uncompressed size
      LOCNAM: 26, // filename length
      LOCEXT: 28, // extra field length

      /* The Data descriptor */
      EXTSIG: 0x08074b50, // "PK\007\008"
      EXTHDR: 16, // EXT header size
      EXTCRC: 4, // uncompressed file crc-32 value
      EXTSIZ: 8, // compressed size
      EXTLEN: 12, // uncompressed size

      /* The central directory file header */
      CENHDR: 46, // CEN header size
      CENSIG: 0x02014b50, // "PK\001\002"
      CENVEM: 4, // version made by
      CENVER: 6, // version needed to extract
      CENFLG: 8, // encrypt, decrypt flags
      CENHOW: 10, // compression method
      CENTIM: 12, // modification time (2 bytes time, 2 bytes date)
      CENCRC: 16, // uncompressed file crc-32 value
      CENSIZ: 20, // compressed size
      CENLEN: 24, // uncompressed size
      CENNAM: 28, // filename length
      CENEXT: 30, // extra field length
      CENCOM: 32, // file comment length
      CENDSK: 34, // volume number start
      CENATT: 36, // internal file attributes
      CENATX: 38, // external file attributes (host system dependent)
      CENOFF: 42, // LOC header offset

      /* The entries in the end of central directory */
      ENDHDR: 22, // END header size
      ENDSIG: 0x06054b50, // "PK\005\006"
      ENDSUB: 8, // number of entries on this disk
      ENDTOT: 10, // total number of entries
      ENDSIZ: 12, // central directory size in bytes
      ENDOFF: 16, // offset of first CEN header
      ENDCOM: 20, // zip file comment length

      END64HDR: 20, // zip64 END header size
      END64SIG: 0x07064b50, // zip64 Locator signature, "PK\006\007"
      END64START: 4, // number of the disk with the start of the zip64
      END64OFF: 8, // relative offset of the zip64 end of central directory
      END64NUMDISKS: 16, // total number of disks

      ZIP64SIG: 0x06064b50, // zip64 signature, "PK\006\006"
      ZIP64HDR: 56, // zip64 record minimum size
      ZIP64LEAD: 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
      ZIP64SIZE: 4, // zip64 size of the central directory record
      ZIP64VEM: 12, // zip64 version made by
      ZIP64VER: 14, // zip64 version needed to extract
      ZIP64DSK: 16, // zip64 number of this disk
      ZIP64DSKDIR: 20, // number of the disk with the start of the record directory
      ZIP64SUB: 24, // number of entries on this disk
      ZIP64TOT: 32, // total number of entries
      ZIP64SIZB: 40, // zip64 central directory size in bytes
      ZIP64OFF: 48, // offset of start of central directory with respect to the starting disk number
      ZIP64EXTRA: 56, // extensible data sector

      /* Compression methods */
      STORED: 0, // no compression
      SHRUNK: 1, // shrunk
      REDUCED1: 2, // reduced with compression factor 1
      REDUCED2: 3, // reduced with compression factor 2
      REDUCED3: 4, // reduced with compression factor 3
      REDUCED4: 5, // reduced with compression factor 4
      IMPLODED: 6, // imploded
      // 7 reserved for Tokenizing compression algorithm
      DEFLATED: 8, // deflated
      ENHANCED_DEFLATED: 9, // enhanced deflated
      PKWARE: 10, // PKWare DCL imploded
      // 11 reserved by PKWARE
      BZIP2: 12, //  compressed using BZIP2
      // 13 reserved by PKWARE
      LZMA: 14, // LZMA
      // 15-17 reserved by PKWARE
      IBM_TERSE: 18, // compressed using IBM TERSE
      IBM_LZ77: 19, // IBM LZ77 z
      AES_ENCRYPT: 99, // WinZIP AES encryption method

      /* General purpose bit flag */
      // values can obtained with expression 2**bitnr
      FLG_ENC: 1, // Bit 0: encrypted file
      FLG_COMP1: 2, // Bit 1, compression option
      FLG_COMP2: 4, // Bit 2, compression option
      FLG_DESC: 8, // Bit 3, data descriptor
      FLG_ENH: 16, // Bit 4, enhanced deflating
      FLG_PATCH: 32, // Bit 5, indicates that the file is compressed patched data.
      FLG_STR: 64, // Bit 6, strong encryption (patented)
      // Bits 7-10: Currently unused.
      FLG_EFS: 2048, // Bit 11: Language encoding flag (EFS)
      // Bit 12: Reserved by PKWARE for enhanced compression.
      // Bit 13: encrypted the Central Directory (patented).
      // Bits 14-15: Reserved by PKWARE.
      FLG_MSK: 4096, // mask header values

      /* Load type */
      FILE: 2,
      BUFFER: 1,
      NONE: 0,

      /* 4.5 Extensible data fields */
      EF_ID: 0,
      EF_SIZE: 2,

      /* Header IDs */
      ID_ZIP64: 0x0001,
      ID_AVINFO: 0x0007,
      ID_PFS: 0x0008,
      ID_OS2: 0x0009,
      ID_NTFS: 0x000a,
      ID_OPENVMS: 0x000c,
      ID_UNIX: 0x000d,
      ID_FORK: 0x000e,
      ID_PATCH: 0x000f,
      ID_X509_PKCS7: 0x0014,
      ID_X509_CERTID_F: 0x0015,
      ID_X509_CERTID_C: 0x0016,
      ID_STRONGENC: 0x0017,
      ID_RECORD_MGT: 0x0018,
      ID_X509_PKCS7_RL: 0x0019,
      ID_IBM1: 0x0065,
      ID_IBM2: 0x0066,
      ID_POSZIP: 0x4690,

      EF_ZIP64_OR_32: 0xffffffff,
      EF_ZIP64_OR_16: 0xffff,
      EF_ZIP64_SUNCOMP: 0,
      EF_ZIP64_SCOMP: 8,
      EF_ZIP64_RHO: 16,
      EF_ZIP64_DSN: 24,
    };

    /***/
  },

  /***/ 1255: /***/ (module) => {
    module.exports = {
      /* Header error messages */
      INVALID_LOC: "Invalid LOC header (bad signature)",
      INVALID_CEN: "Invalid CEN header (bad signature)",
      INVALID_END: "Invalid END header (bad signature)",

      /* ZipEntry error messages*/
      NO_DATA: "Nothing to decompress",
      BAD_CRC: "CRC32 checksum failed",
      FILE_IN_THE_WAY: "There is a file in the way: %s",
      UNKNOWN_METHOD: "Invalid/unsupported compression method",

      /* Inflater error messages */
      AVAIL_DATA: "inflate::Available inflate data did not terminate",
      INVALID_DISTANCE:
        "inflate::Invalid literal/length or distance code in fixed or dynamic block",
      TO_MANY_CODES:
        "inflate::Dynamic block code description: too many length or distance codes",
      INVALID_REPEAT_LEN:
        "inflate::Dynamic block code description: repeat more than specified lengths",
      INVALID_REPEAT_FIRST:
        "inflate::Dynamic block code description: repeat lengths with no first length",
      INCOMPLETE_CODES:
        "inflate::Dynamic block code description: code lengths codes incomplete",
      INVALID_DYN_DISTANCE:
        "inflate::Dynamic block code description: invalid distance code lengths",
      INVALID_CODES_LEN:
        "inflate::Dynamic block code description: invalid literal/length code lengths",
      INVALID_STORE_BLOCK:
        "inflate::Stored block length did not match one's complement",
      INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",

      /* ADM-ZIP error messages */
      CANT_EXTRACT_FILE: "Could not extract the file",
      CANT_OVERRIDE: "Target file already exists",
      NO_ZIP: "No zip file was loaded",
      NO_ENTRY: "Entry doesn't exist",
      DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
      FILE_NOT_FOUND: "File not found: %s",
      NOT_IMPLEMENTED: "Not implemented",
      INVALID_FILENAME: "Invalid filename",
      INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
    };

    /***/
  },

  /***/ 8321: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(2895).require();
    const pth = __nccwpck_require__(1017);

    fs.existsSync = fs.existsSync || pth.existsSync;

    module.exports = function (/*String*/ path) {
      var _path = path || "",
        _obj = newAttr(),
        _stat = null;

      function newAttr() {
        return {
          directory: false,
          readonly: false,
          hidden: false,
          executable: false,
          mtime: 0,
          atime: 0,
        };
      }

      if (_path && fs.existsSync(_path)) {
        _stat = fs.statSync(_path);
        _obj.directory = _stat.isDirectory();
        _obj.mtime = _stat.mtime;
        _obj.atime = _stat.atime;
        _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner
        _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right
        _obj.hidden = pth.basename(_path)[0] === ".";
      } else {
        console.warn("Invalid path: " + _path);
      }

      return {
        get directory() {
          return _obj.directory;
        },

        get readOnly() {
          return _obj.readonly;
        },

        get hidden() {
          return _obj.hidden;
        },

        get mtime() {
          return _obj.mtime;
        },

        get atime() {
          return _obj.atime;
        },

        get executable() {
          return _obj.executable;
        },

        decodeAttributes: function () {},

        encodeAttributes: function () {},

        toJSON: function () {
          return {
            path: _path,
            isDirectory: _obj.directory,
            isReadOnly: _obj.readonly,
            isHidden: _obj.hidden,
            isExecutable: _obj.executable,
            mTime: _obj.mtime,
            aTime: _obj.atime,
          };
        },

        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        },
      };
    };

    /***/
  },

  /***/ 2895: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    exports.require = function () {
      if (
        typeof process === "object" &&
        process.versions &&
        process.versions["electron"]
      ) {
        try {
          const originalFs = __nccwpck_require__(2941);
          if (Object.keys(originalFs).length > 0) {
            return originalFs;
          }
        } catch (e) {}
      }
      return __nccwpck_require__(7147);
    };

    /***/
  },

  /***/ 5182: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = __nccwpck_require__(1291);
    module.exports.Constants = __nccwpck_require__(4522);
    module.exports.Errors = __nccwpck_require__(1255);
    module.exports.FileAttr = __nccwpck_require__(8321);

    /***/
  },

  /***/ 1291: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fsystem = __nccwpck_require__(2895).require();
    const pth = __nccwpck_require__(1017);
    const Constants = __nccwpck_require__(4522);
    const Errors = __nccwpck_require__(1255);
    const isWin = typeof process === "object" && "win32" === process.platform;

    const is_Obj = (obj) => obj && typeof obj === "object";

    // generate CRC32 lookup table
    const crcTable = new Uint32Array(256).map((t, c) => {
      for (let k = 0; k < 8; k++) {
        if ((c & 1) !== 0) {
          c = 0xedb88320 ^ (c >>> 1);
        } else {
          c >>>= 1;
        }
      }
      return c >>> 0;
    });

    // UTILS functions

    function Utils(opts) {
      this.sep = pth.sep;
      this.fs = fsystem;

      if (is_Obj(opts)) {
        // custom filesystem
        if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
          this.fs = opts.fs;
        }
      }
    }

    module.exports = Utils;

    // INSTANCED functions

    Utils.prototype.makeDir = function (/*String*/ folder) {
      const self = this;

      // Sync - make directories tree
      function mkdirSync(/*String*/ fpath) {
        let resolvedPath = fpath.split(self.sep)[0];
        fpath.split(self.sep).forEach(function (name) {
          if (!name || name.substr(-1, 1) === ":") return;
          resolvedPath += self.sep + name;
          var stat;
          try {
            stat = self.fs.statSync(resolvedPath);
          } catch (e) {
            self.fs.mkdirSync(resolvedPath);
          }
          if (stat && stat.isFile())
            throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
        });
      }

      mkdirSync(folder);
    };

    Utils.prototype.writeFileTo = function (
      /*String*/ path,
      /*Buffer*/ content,
      /*Boolean*/ overwrite,
      /*Number*/ attr
    ) {
      const self = this;
      if (self.fs.existsSync(path)) {
        if (!overwrite) return false; // cannot overwrite

        var stat = self.fs.statSync(path);
        if (stat.isDirectory()) {
          return false;
        }
      }
      var folder = pth.dirname(path);
      if (!self.fs.existsSync(folder)) {
        self.makeDir(folder);
      }

      var fd;
      try {
        fd = self.fs.openSync(path, "w", 438); // 0666
      } catch (e) {
        self.fs.chmodSync(path, 438);
        fd = self.fs.openSync(path, "w", 438);
      }
      if (fd) {
        try {
          self.fs.writeSync(fd, content, 0, content.length, 0);
        } finally {
          self.fs.closeSync(fd);
        }
      }
      self.fs.chmodSync(path, attr || 438);
      return true;
    };

    Utils.prototype.writeFileToAsync = function (
      /*String*/ path,
      /*Buffer*/ content,
      /*Boolean*/ overwrite,
      /*Number*/ attr,
      /*Function*/ callback
    ) {
      if (typeof attr === "function") {
        callback = attr;
        attr = undefined;
      }

      const self = this;

      self.fs.exists(path, function (exist) {
        if (exist && !overwrite) return callback(false);

        self.fs.stat(path, function (err, stat) {
          if (exist && stat.isDirectory()) {
            return callback(false);
          }

          var folder = pth.dirname(path);
          self.fs.exists(folder, function (exists) {
            if (!exists) self.makeDir(folder);

            self.fs.open(path, "w", 438, function (err, fd) {
              if (err) {
                self.fs.chmod(path, 438, function () {
                  self.fs.open(path, "w", 438, function (err, fd) {
                    self.fs.write(
                      fd,
                      content,
                      0,
                      content.length,
                      0,
                      function () {
                        self.fs.close(fd, function () {
                          self.fs.chmod(path, attr || 438, function () {
                            callback(true);
                          });
                        });
                      }
                    );
                  });
                });
              } else if (fd) {
                self.fs.write(fd, content, 0, content.length, 0, function () {
                  self.fs.close(fd, function () {
                    self.fs.chmod(path, attr || 438, function () {
                      callback(true);
                    });
                  });
                });
              } else {
                self.fs.chmod(path, attr || 438, function () {
                  callback(true);
                });
              }
            });
          });
        });
      });
    };

    Utils.prototype.findFiles = function (/*String*/ path) {
      const self = this;

      function findSync(
        /*String*/ dir,
        /*RegExp*/ pattern,
        /*Boolean*/ recursive
      ) {
        if (typeof pattern === "boolean") {
          recursive = pattern;
          pattern = undefined;
        }
        let files = [];
        self.fs.readdirSync(dir).forEach(function (file) {
          var path = pth.join(dir, file);

          if (self.fs.statSync(path).isDirectory() && recursive)
            files = files.concat(findSync(path, pattern, recursive));

          if (!pattern || pattern.test(path)) {
            files.push(
              pth.normalize(path) +
                (self.fs.statSync(path).isDirectory() ? self.sep : "")
            );
          }
        });
        return files;
      }

      return findSync(path, undefined, true);
    };

    Utils.prototype.getAttributes = function () {};

    Utils.prototype.setAttributes = function () {};

    // STATIC functions

    // crc32 single update (it is part of crc32)
    Utils.crc32update = function (crc, byte) {
      return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);
    };

    Utils.crc32 = function (buf) {
      if (typeof buf === "string") {
        buf = Buffer.from(buf, "utf8");
      }
      // Generate crcTable
      if (!crcTable.length) genCRCTable();

      let len = buf.length;
      let crc = ~0;
      for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);
      // xor and cast as uint32 number
      return ~crc >>> 0;
    };

    Utils.methodToString = function (/*Number*/ method) {
      switch (method) {
        case Constants.STORED:
          return "STORED (" + method + ")";
        case Constants.DEFLATED:
          return "DEFLATED (" + method + ")";
        default:
          return "UNSUPPORTED (" + method + ")";
      }
    };

    // removes ".." style path elements
    Utils.canonical = function (/*string*/ path) {
      if (!path) return "";
      // trick normalize think path is absolute
      var safeSuffix = pth.posix.normalize("/" + path.split("\\").join("/"));
      return pth.join(".", safeSuffix);
    };

    // make abolute paths taking prefix as root folder
    Utils.sanitize = function (/*string*/ prefix, /*string*/ name) {
      prefix = pth.resolve(pth.normalize(prefix));
      var parts = name.split("/");
      for (var i = 0, l = parts.length; i < l; i++) {
        var path = pth.normalize(
          pth.join(prefix, parts.slice(i, l).join(pth.sep))
        );
        if (path.indexOf(prefix) === 0) {
          return path;
        }
      }
      return pth.normalize(pth.join(prefix, pth.basename(name)));
    };

    // converts buffer, Uint8Array, string types to buffer
    Utils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input) {
      if (Buffer.isBuffer(input)) {
        return input;
      } else if (input instanceof Uint8Array) {
        return Buffer.from(input);
      } else {
        // expect string all other values are invalid and return empty buffer
        return typeof input === "string"
          ? Buffer.from(input, "utf8")
          : Buffer.alloc(0);
      }
    };

    Utils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {
      var slice = Buffer.from(buffer.slice(index, index + 8));
      slice.swap64();

      return parseInt(`0x${slice.toString("hex")}`);
    };

    Utils.isWin = isWin; // Do we have windows system
    Utils.crcTable = crcTable;

    /***/
  },

  /***/ 4057: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    var Utils = __nccwpck_require__(5182),
      Headers = __nccwpck_require__(4958),
      Constants = Utils.Constants,
      Methods = __nccwpck_require__(3928);

    module.exports = function (/*Buffer*/ input) {
      var _entryHeader = new Headers.EntryHeader(),
        _entryName = Buffer.alloc(0),
        _comment = Buffer.alloc(0),
        _isDirectory = false,
        uncompressedData = null,
        _extra = Buffer.alloc(0);

      function getCompressedDataFromZip() {
        if (!input || !Buffer.isBuffer(input)) {
          return Buffer.alloc(0);
        }
        _entryHeader.loadDataHeaderFromBinary(input);
        return input.slice(
          _entryHeader.realDataOffset,
          _entryHeader.realDataOffset + _entryHeader.compressedSize
        );
      }

      function crc32OK(data) {
        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
        if ((_entryHeader.flags & 0x8) !== 0x8) {
          if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {
            return false;
          }
        } else {
          // @TODO: load and check data descriptor header
          // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure
          // (optionally preceded by a 4-byte signature) immediately after the compressed data:
        }
        return true;
      }

      function decompress(
        /*Boolean*/ async,
        /*Function*/ callback,
        /*String, Buffer*/ pass
      ) {
        if (typeof callback === "undefined" && typeof async === "string") {
          pass = async;
          async = void 0;
        }
        if (_isDirectory) {
          if (async && callback) {
            callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
          }
          return Buffer.alloc(0);
        }

        var compressedData = getCompressedDataFromZip();

        if (compressedData.length === 0) {
          // File is empty, nothing to decompress.
          if (async && callback) callback(compressedData);
          return compressedData;
        }

        if (_entryHeader.encripted) {
          if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
            throw new Error("ADM-ZIP: Incompatible password parameter");
          }
          compressedData = Methods.ZipCrypto.decrypt(
            compressedData,
            _entryHeader,
            pass
          );
        }

        var data = Buffer.alloc(_entryHeader.size);

        switch (_entryHeader.method) {
          case Utils.Constants.STORED:
            compressedData.copy(data);
            if (!crc32OK(data)) {
              if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error
              throw new Error(Utils.Errors.BAD_CRC);
            } else {
              //si added otherwise did not seem to return data.
              if (async && callback) callback(data);
              return data;
            }
          case Utils.Constants.DEFLATED:
            var inflater = new Methods.Inflater(compressedData);
            if (!async) {
              const result = inflater.inflate(data);
              result.copy(data, 0);
              if (!crc32OK(data)) {
                throw new Error(
                  Utils.Errors.BAD_CRC + " " + _entryName.toString()
                );
              }
              return data;
            } else {
              inflater.inflateAsync(function (result) {
                result.copy(result, 0);
                if (callback) {
                  if (!crc32OK(result)) {
                    callback(result, Utils.Errors.BAD_CRC); //si added error
                  } else {
                    callback(result);
                  }
                }
              });
            }
            break;
          default:
            if (async && callback)
              callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);
            throw new Error(Utils.Errors.UNKNOWN_METHOD);
        }
      }

      function compress(/*Boolean*/ async, /*Function*/ callback) {
        if (
          (!uncompressedData || !uncompressedData.length) &&
          Buffer.isBuffer(input)
        ) {
          // no data set or the data wasn't changed to require recompression
          if (async && callback) callback(getCompressedDataFromZip());
          return getCompressedDataFromZip();
        }

        if (uncompressedData.length && !_isDirectory) {
          var compressedData;
          // Local file header
          switch (_entryHeader.method) {
            case Utils.Constants.STORED:
              _entryHeader.compressedSize = _entryHeader.size;

              compressedData = Buffer.alloc(uncompressedData.length);
              uncompressedData.copy(compressedData);

              if (async && callback) callback(compressedData);
              return compressedData;
            default:
            case Utils.Constants.DEFLATED:
              var deflater = new Methods.Deflater(uncompressedData);
              if (!async) {
                var deflated = deflater.deflate();
                _entryHeader.compressedSize = deflated.length;
                return deflated;
              } else {
                deflater.deflateAsync(function (data) {
                  compressedData = Buffer.alloc(data.length);
                  _entryHeader.compressedSize = data.length;
                  data.copy(compressedData);
                  callback && callback(compressedData);
                });
              }
              deflater = null;
              break;
          }
        } else if (async && callback) {
          callback(Buffer.alloc(0));
        } else {
          return Buffer.alloc(0);
        }
      }

      function readUInt64LE(buffer, offset) {
        return (
          (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset)
        );
      }

      function parseExtra(data) {
        var offset = 0;
        var signature, size, part;
        while (offset < data.length) {
          signature = data.readUInt16LE(offset);
          offset += 2;
          size = data.readUInt16LE(offset);
          offset += 2;
          part = data.slice(offset, offset + size);
          offset += size;
          if (Constants.ID_ZIP64 === signature) {
            parseZip64ExtendedInformation(part);
          }
        }
      }

      //Override header field values with values from the ZIP64 extra field
      function parseZip64ExtendedInformation(data) {
        var size, compressedSize, offset, diskNumStart;

        if (data.length >= Constants.EF_ZIP64_SCOMP) {
          size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
          if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {
            _entryHeader.size = size;
          }
        }
        if (data.length >= Constants.EF_ZIP64_RHO) {
          compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
          if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
            _entryHeader.compressedSize = compressedSize;
          }
        }
        if (data.length >= Constants.EF_ZIP64_DSN) {
          offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
          if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
            _entryHeader.offset = offset;
          }
        }
        if (data.length >= Constants.EF_ZIP64_DSN + 4) {
          diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
          if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
            _entryHeader.diskNumStart = diskNumStart;
          }
        }
      }

      return {
        get entryName() {
          return _entryName.toString();
        },
        get rawEntryName() {
          return _entryName;
        },
        set entryName(val) {
          _entryName = Utils.toBuffer(val);
          var lastChar = _entryName[_entryName.length - 1];
          _isDirectory = lastChar === 47 || lastChar === 92;
          _entryHeader.fileNameLength = _entryName.length;
        },

        get extra() {
          return _extra;
        },
        set extra(val) {
          _extra = val;
          _entryHeader.extraLength = val.length;
          parseExtra(val);
        },

        get comment() {
          return _comment.toString();
        },
        set comment(val) {
          _comment = Utils.toBuffer(val);
          _entryHeader.commentLength = _comment.length;
        },

        get name() {
          var n = _entryName.toString();
          return _isDirectory
            ? n
                .substr(n.length - 1)
                .split("/")
                .pop()
            : n.split("/").pop();
        },
        get isDirectory() {
          return _isDirectory;
        },

        getCompressedData: function () {
          return compress(false, null);
        },

        getCompressedDataAsync: function (/*Function*/ callback) {
          compress(true, callback);
        },

        setData: function (value) {
          uncompressedData = Utils.toBuffer(value);
          if (!_isDirectory && uncompressedData.length) {
            _entryHeader.size = uncompressedData.length;
            _entryHeader.method = Utils.Constants.DEFLATED;
            _entryHeader.crc = Utils.crc32(value);
            _entryHeader.changed = true;
          } else {
            // folders and blank files should be stored
            _entryHeader.method = Utils.Constants.STORED;
          }
        },

        getData: function (pass) {
          if (_entryHeader.changed) {
            return uncompressedData;
          } else {
            return decompress(false, null, pass);
          }
        },

        getDataAsync: function (/*Function*/ callback, pass) {
          if (_entryHeader.changed) {
            callback(uncompressedData);
          } else {
            decompress(true, callback, pass);
          }
        },

        set attr(attr) {
          _entryHeader.attr = attr;
        },
        get attr() {
          return _entryHeader.attr;
        },

        set header(/*Buffer*/ data) {
          _entryHeader.loadFromBinary(data);
        },

        get header() {
          return _entryHeader;
        },

        packHeader: function () {
          // 1. create header (buffer)
          var header = _entryHeader.entryHeaderToBinary();
          var addpos = Utils.Constants.CENHDR;
          // 2. add file name
          _entryName.copy(header, addpos);
          addpos += _entryName.length;
          // 3. add extra data
          if (_entryHeader.extraLength) {
            _extra.copy(header, addpos);
            addpos += _entryHeader.extraLength;
          }
          // 4. add file comment
          if (_entryHeader.commentLength) {
            _comment.copy(header, addpos);
          }
          return header;
        },

        toJSON: function () {
          const bytes = function (nr) {
            return "<" + ((nr && nr.length + " bytes buffer") || "null") + ">";
          };

          return {
            entryName: this.entryName,
            name: this.name,
            comment: this.comment,
            isDirectory: this.isDirectory,
            header: _entryHeader.toJSON(),
            compressedData: bytes(input),
            data: bytes(uncompressedData),
          };
        },

        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        },
      };
    };

    /***/
  },

  /***/ 7744: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const ZipEntry = __nccwpck_require__(4057);
    const Headers = __nccwpck_require__(4958);
    const Utils = __nccwpck_require__(5182);

    module.exports = function (
      /*Buffer|null*/ inBuffer,
      /** object */ options
    ) {
      var entryList = [],
        entryTable = {},
        _comment = Buffer.alloc(0),
        mainHeader = new Headers.MainHeader(),
        loadedEntries = false;

      // assign options
      const opts = Object.assign(Object.create(null), options);

      const { noSort } = opts;

      if (inBuffer) {
        // is a memory buffer
        readMainHeader(opts.readEntries);
      } else {
        // none. is a new file
        loadedEntries = true;
      }

      function iterateEntries(callback) {
        const totalEntries = mainHeader.diskEntries; // total number of entries
        let index = mainHeader.offset; // offset of first CEN header

        for (let i = 0; i < totalEntries; i++) {
          let tmp = index;
          const entry = new ZipEntry(inBuffer);

          entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));
          entry.entryName = inBuffer.slice(
            tmp,
            (tmp += entry.header.fileNameLength)
          );

          index += entry.header.entryHeaderSize;

          callback(entry);
        }
      }

      function readEntries() {
        loadedEntries = true;
        entryTable = {};
        entryList = new Array(mainHeader.diskEntries); // total number of entries
        var index = mainHeader.offset; // offset of first CEN header
        for (var i = 0; i < entryList.length; i++) {
          var tmp = index,
            entry = new ZipEntry(inBuffer);
          entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));

          entry.entryName = inBuffer.slice(
            tmp,
            (tmp += entry.header.fileNameLength)
          );

          if (entry.header.extraLength) {
            entry.extra = inBuffer.slice(
              tmp,
              (tmp += entry.header.extraLength)
            );
          }

          if (entry.header.commentLength)
            entry.comment = inBuffer.slice(
              tmp,
              tmp + entry.header.commentLength
            );

          index += entry.header.entryHeaderSize;

          entryList[i] = entry;
          entryTable[entry.entryName] = entry;
        }
      }

      function readMainHeader(/*Boolean*/ readNow) {
        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size
          max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length
          n = max,
          endStart = inBuffer.length,
          endOffset = -1, // Start offset of the END header
          commentEnd = 0;

        for (i; i >= n; i--) {
          if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'
          if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {
            // "PK\005\006"
            endOffset = i;
            commentEnd = i;
            endStart = i + Utils.Constants.ENDHDR;
            // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature
            n = i - Utils.Constants.END64HDR;
            continue;
          }

          if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {
            // Found a zip64 signature, let's continue reading the whole zip64 record
            n = max;
            continue;
          }

          if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {
            // Found the zip64 record, let's determine it's size
            endOffset = i;
            endStart =
              i +
              Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) +
              Utils.Constants.ZIP64LEAD;
            break;
          }
        }

        if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);

        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
        if (mainHeader.commentLength) {
          _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
        }
        if (readNow) readEntries();
      }

      function sortEntries() {
        if (entryList.length > 1 && !noSort) {
          entryList.sort((a, b) =>
            a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase())
          );
        }
      }

      return {
        /**
         * Returns an array of ZipEntry objects existent in the current opened archive
         * @return Array
         */
        get entries() {
          if (!loadedEntries) {
            readEntries();
          }
          return entryList;
        },

        /**
         * Archive comment
         * @return {String}
         */
        get comment() {
          return _comment.toString();
        },
        set comment(val) {
          _comment = Utils.toBuffer(val);
          mainHeader.commentLength = _comment.length;
        },

        getEntryCount: function () {
          if (!loadedEntries) {
            return mainHeader.diskEntries;
          }

          return entryList.length;
        },

        forEach: function (callback) {
          if (!loadedEntries) {
            iterateEntries(callback);
            return;
          }

          entryList.forEach(callback);
        },

        /**
         * Returns a reference to the entry with the given name or null if entry is inexistent
         *
         * @param entryName
         * @return ZipEntry
         */
        getEntry: function (/*String*/ entryName) {
          if (!loadedEntries) {
            readEntries();
          }
          return entryTable[entryName] || null;
        },

        /**
         * Adds the given entry to the entry list
         *
         * @param entry
         */
        setEntry: function (/*ZipEntry*/ entry) {
          if (!loadedEntries) {
            readEntries();
          }
          entryList.push(entry);
          entryTable[entry.entryName] = entry;
          mainHeader.totalEntries = entryList.length;
        },

        /**
         * Removes the entry with the given name from the entry list.
         *
         * If the entry is a directory, then all nested files and directories will be removed
         * @param entryName
         */
        deleteEntry: function (/*String*/ entryName) {
          if (!loadedEntries) {
            readEntries();
          }
          var entry = entryTable[entryName];
          if (entry && entry.isDirectory) {
            var _self = this;
            this.getEntryChildren(entry).forEach(function (child) {
              if (child.entryName !== entryName) {
                _self.deleteEntry(child.entryName);
              }
            });
          }
          entryList.splice(entryList.indexOf(entry), 1);
          delete entryTable[entryName];
          mainHeader.totalEntries = entryList.length;
        },

        /**
         *  Iterates and returns all nested files and directories of the given entry
         *
         * @param entry
         * @return Array
         */
        getEntryChildren: function (/*ZipEntry*/ entry) {
          if (!loadedEntries) {
            readEntries();
          }
          if (entry && entry.isDirectory) {
            const list = [];
            const name = entry.entryName;
            const len = name.length;

            entryList.forEach(function (zipEntry) {
              if (zipEntry.entryName.substr(0, len) === name) {
                list.push(zipEntry);
              }
            });
            return list;
          }
          return [];
        },

        /**
         * Returns the zip file
         *
         * @return Buffer
         */
        compressToBuffer: function () {
          if (!loadedEntries) {
            readEntries();
          }
          sortEntries();

          const dataBlock = [];
          const entryHeaders = [];
          let totalSize = 0;
          let dindex = 0;

          mainHeader.size = 0;
          mainHeader.offset = 0;

          for (const entry of entryList) {
            // compress data and set local and entry header accordingly. Reason why is called first
            const compressedData = entry.getCompressedData();
            // 1. construct data header
            entry.header.offset = dindex;
            const dataHeader = entry.header.dataHeaderToBinary();
            const entryNameLen = entry.rawEntryName.length;
            // 1.2. postheader - data after data header
            const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);
            entry.rawEntryName.copy(postHeader, 0);
            postHeader.copy(entry.extra, entryNameLen);

            // 2. offsets
            const dataLength =
              dataHeader.length + postHeader.length + compressedData.length;
            dindex += dataLength;

            // 3. store values in sequence
            dataBlock.push(dataHeader);
            dataBlock.push(postHeader);
            dataBlock.push(compressedData);

            // 4. construct entry header
            const entryHeader = entry.packHeader();
            entryHeaders.push(entryHeader);
            // 5. update main header
            mainHeader.size += entryHeader.length;
            totalSize += dataLength + entryHeader.length;
          }

          totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
          // point to end of data and beginning of central directory first record
          mainHeader.offset = dindex;

          dindex = 0;
          const outBuffer = Buffer.alloc(totalSize);
          // write data blocks
          for (const content of dataBlock) {
            content.copy(outBuffer, dindex);
            dindex += content.length;
          }

          // write central directory entries
          for (const content of entryHeaders) {
            content.copy(outBuffer, dindex);
            dindex += content.length;
          }

          // write main header
          const mh = mainHeader.toBinary();
          if (_comment) {
            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
          }
          mh.copy(outBuffer, dindex);

          return outBuffer;
        },

        toAsyncBuffer: function (
          /*Function*/ onSuccess,
          /*Function*/ onFail,
          /*Function*/ onItemStart,
          /*Function*/ onItemEnd
        ) {
          try {
            if (!loadedEntries) {
              readEntries();
            }
            sortEntries();

            const dataBlock = [];
            const entryHeaders = [];
            let totalSize = 0;
            let dindex = 0;

            mainHeader.size = 0;
            mainHeader.offset = 0;

            const compress2Buffer = function (entryLists) {
              if (entryLists.length) {
                const entry = entryLists.pop();
                const name = entry.entryName + entry.extra.toString();
                if (onItemStart) onItemStart(name);
                entry.getCompressedDataAsync(function (compressedData) {
                  if (onItemEnd) onItemEnd(name);

                  entry.header.offset = dindex;
                  // data header
                  const dataHeader = entry.header.dataHeaderToBinary();
                  const postHeader = Buffer.alloc(name.length, name);
                  const dataLength =
                    dataHeader.length +
                    postHeader.length +
                    compressedData.length;

                  dindex += dataLength;

                  dataBlock.push(dataHeader);
                  dataBlock.push(postHeader);
                  dataBlock.push(compressedData);

                  const entryHeader = entry.packHeader();
                  entryHeaders.push(entryHeader);
                  mainHeader.size += entryHeader.length;
                  totalSize += dataLength + entryHeader.length;

                  compress2Buffer(entryLists);
                });
              } else {
                totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                // point to end of data and beginning of central directory first record
                mainHeader.offset = dindex;

                dindex = 0;
                const outBuffer = Buffer.alloc(totalSize);
                dataBlock.forEach(function (content) {
                  content.copy(outBuffer, dindex); // write data blocks
                  dindex += content.length;
                });
                entryHeaders.forEach(function (content) {
                  content.copy(outBuffer, dindex); // write central directory entries
                  dindex += content.length;
                });

                const mh = mainHeader.toBinary();
                if (_comment) {
                  _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
                }

                mh.copy(outBuffer, dindex); // write main header

                onSuccess(outBuffer);
              }
            };

            compress2Buffer(entryList);
          } catch (e) {
            onFail(e);
          }
        },
      };
    };

    /***/
  },

  /***/ 6463: /***/ (__unused_webpack_module, exports) => {
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

    var code =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;

    function getLens(b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len;

      var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

      return [validLen, placeHoldersLen];
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }

    function _byteLength(b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }

    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

      var curByte = 0;

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

      var i;
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = (tmp >> 16) & 0xff;
        arr[curByte++] = (tmp >> 8) & 0xff;
        arr[curByte++] = tmp & 0xff;
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[curByte++] = tmp & 0xff;
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 0xff;
        arr[curByte++] = tmp & 0xff;
      }

      return arr;
    }

    function tripletToBase64(num) {
      return (
        lookup[(num >> 18) & 0x3f] +
        lookup[(num >> 12) & 0x3f] +
        lookup[(num >> 6) & 0x3f] +
        lookup[num & 0x3f]
      );
    }

    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xff0000) +
          ((uint8[i + 1] << 8) & 0xff00) +
          (uint8[i + 2] & 0xff);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }

    function fromByteArray(uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(
          encodeChunk(
            uint8,
            i,
            i + maxChunkLength > len2 ? len2 : i + maxChunkLength
          )
        );
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(
          lookup[tmp >> 10] +
            lookup[(tmp >> 4) & 0x3f] +
            lookup[(tmp << 2) & 0x3f] +
            "="
        );
      }

      return parts.join("");
    }

    /***/
  },

  /***/ 8222: /***/ (module, exports, __nccwpck_require__) => {
    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;

      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
          );
        }
      };
    })();

    /**
     * Colors.
     */

    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33",
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (
        typeof window !== "undefined" &&
        window.process &&
        (window.process.type === "renderer" || window.process.__nwjs)
      ) {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (
        typeof navigator !== "undefined" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ) {
        return false;
      }

      // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (
        (typeof document !== "undefined" &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        // Is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== "undefined" &&
          window.console &&
          (window.console.firebug ||
            (window.console.exception && window.console.table))) ||
        // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) ||
        // Double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        args[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");

      // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || (() => {});

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = __nccwpck_require__(6243)(exports);

    const { formatters } = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };

    /***/
  },

  /***/ 6243: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = __nccwpck_require__(900);
      createDebug.destroy = destroy;

      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });

      /**
       * The currently active debug mode names, and names to skip.
       */

      createDebug.names = [];
      createDebug.skips = [];

      /**
       * Map of special "%n" handling functions, for the debug "format" argument.
       *
       * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
       */
      createDebug.formatters = {};

      /**
       * Selects a color for a debug namespace
       * @param {String} namespace The namespace string for the debug instance to be colored
       * @return {Number|String} An ANSI color code for the given namespace
       * @api private
       */
      function selectColor(namespace) {
        let hash = 0;

        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;

      /**
       * Create a debugger with the given `namespace`.
       *
       * @param {String} namespace
       * @return {Function}
       * @api public
       */
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;

        function debug(...args) {
          // Disabled?
          if (!debug.enabled) {
            return;
          }

          const self = debug;

          // Set `diff` timestamp
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;

          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== "string") {
            // Anything else let's inspect with %O
            args.unshift("%O");
          }

          // Apply any `formatters` transformations
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            // If we encounter an escaped % then don't increase the array index
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);

              // Now we need to remove `args[index]` since it's inlined in the `format`
              args.splice(index, 1);
              index--;
            }
            return match;
          });

          // Apply env-specific formatting (colors, etc.)
          createDebug.formatArgs.call(self, args);

          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }

            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          },
        });

        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }

        return debug;
      }

      function extend(namespace, delimiter) {
        const newDebug = createDebug(
          this.namespace +
            (typeof delimiter === "undefined" ? ":" : delimiter) +
            namespace
        );
        newDebug.log = this.log;
        return newDebug;
      }

      /**
       * Enables a debug mode by namespaces. This can include modes
       * separated by a colon and wildcards.
       *
       * @param {String} namespaces
       * @api public
       */
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;

        createDebug.names = [];
        createDebug.skips = [];

        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(
          /[\s,]+/
        );
        const len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            // ignore empty strings
            continue;
          }

          namespaces = split[i].replace(/\*/g, ".*?");

          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }

      /**
       * Disable debug output.
       *
       * @return {String} namespaces
       * @api public
       */
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips
            .map(toNamespace)
            .map((namespace) => "-" + namespace),
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }

      /**
       * Returns true if the given mode name is enabled, false otherwise.
       *
       * @param {String} name
       * @return {Boolean}
       * @api public
       */
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }

        let i;
        let len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }

      /**
       * Convert regexp to namespace
       *
       * @param {RegExp} regxep
       * @return {String} namespace
       * @api private
       */
      function toNamespace(regexp) {
        return regexp
          .toString()
          .substring(2, regexp.toString().length - 2)
          .replace(/\.\*\?$/, "*");
      }

      /**
       * Coerce `val`.
       *
       * @param {Mixed} val
       * @return {Mixed}
       * @api private
       */
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }

      /**
       * XXX DO NOT USE. This is a temporary stub function.
       * XXX It WILL be removed in the next major release.
       */
      function destroy() {
        console.warn(
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
        );
      }

      createDebug.enable(createDebug.load());

      return createDebug;
    }

    module.exports = setup;

    /***/
  },

  /***/ 8237: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /**
     * Detect Electron renderer / nwjs process, which is node, but we should
     * treat as a browser.
     */

    if (
      typeof process === "undefined" ||
      process.type === "renderer" ||
      process.browser === true ||
      process.__nwjs
    ) {
      module.exports = __nccwpck_require__(8222);
    } else {
      module.exports = __nccwpck_require__(4874);
    }

    /***/
  },

  /***/ 4874: /***/ (module, exports, __nccwpck_require__) => {
    /**
     * Module dependencies.
     */

    const tty = __nccwpck_require__(6224);
    const util = __nccwpck_require__(3837);

    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {},
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      const supportsColor = __nccwpck_require__(9318);

      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,
          63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113,
          128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167,
          168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199,
          200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
        ];
      }
    } catch (error) {
      // Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env)
      .filter((key) => {
        return /^debug_/i.test(key);
      })
      .reduce((obj, key) => {
        // Camel-case
        const prop = key
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });

        // Coerce string value into JS value
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }

        obj[prop] = val;
        return obj;
      }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return "colors" in exports.inspectOpts
        ? Boolean(exports.inspectOpts.colors)
        : tty.isatty(process.stderr.fd);
    }

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      const { namespace: name, useColors } = this;

      if (useColors) {
        const c = this.color;
        const colorCode = "\u001B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;

        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(
          colorCode + "m+" + module.exports.humanize(this.diff) + "\u001B[0m"
        );
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }

    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }

    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};

      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    module.exports = __nccwpck_require__(6243)(exports);

    const { formatters } = module.exports;

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util
        .inspect(v, this.inspectOpts)
        .split("\n")
        .map((str) => str.trim())
        .join(" ");
    };

    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };

    /***/
  },

  /***/ 2603: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const validator = __nccwpck_require__(1739);
    const XMLParser = __nccwpck_require__(2380);
    const XMLBuilder = __nccwpck_require__(660);

    module.exports = {
      XMLParser: XMLParser,
      XMLValidator: validator,
      XMLBuilder: XMLBuilder,
    };

    /***/
  },

  /***/ 8280: /***/ (__unused_webpack_module, exports) => {
    const nameStartChar =
      ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    const nameChar =
      nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    const nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    const regexName = new RegExp("^" + nameRegexp + "$");

    const getAllMatches = function (string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };

    const isName = function (string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };

    exports.isExist = function (v) {
      return typeof v !== "undefined";
    };

    exports.isEmptyObject = function (obj) {
      return Object.keys(obj).length === 0;
    };

    /**
     * Copy all the properties of a into b.
     * @param {*} target
     * @param {*} a
     */
    exports.merge = function (target, a, arrayMode) {
      if (a) {
        const keys = Object.keys(a); // will return an array of own properties
        const len = keys.length; //don't make it inline
        for (let i = 0; i < len; i++) {
          if (arrayMode === "strict") {
            target[keys[i]] = [a[keys[i]]];
          } else {
            target[keys[i]] = a[keys[i]];
          }
        }
      }
    };
    /* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

    exports.getValue = function (v) {
      if (exports.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };

    // const fakeCall = function(a) {return a;};
    // const fakeCallNoReturn = function() {};

    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;

    /***/
  },

  /***/ 1739: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    const util = __nccwpck_require__(8280);

    const defaultOptions = {
      allowBooleanAttributes: false, //A tag can have attributes without any value
      unpairedTags: [],
    };

    //const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
    exports.validate = function (xmlData, options) {
      options = Object.assign({}, defaultOptions, options);

      //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
      //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
      //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
      const tags = [];
      let tagFound = false;

      //indicates that the root tag has been closed (aka. depth 0 has been reached)
      let reachedRoot = false;

      if (xmlData[0] === "\ufeff") {
        // check for byte order mark (BOM)
        xmlData = xmlData.substr(1);
      }

      for (let i = 0; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
          i += 2;
          i = readPI(xmlData, i);
          if (i.err) return i;
        } else if (xmlData[i] === "<") {
          //starting of tag
          //read until you reach to '>' avoiding any '>' in attribute value
          let tagStartPos = i;
          i++;

          if (xmlData[i] === "!") {
            i = readCommentAndCDATA(xmlData, i);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i] === "/") {
              //closing tag
              closingTag = true;
              i++;
            }
            //read tagname
            let tagName = "";
            for (
              ;
              i < xmlData.length &&
              xmlData[i] !== ">" &&
              xmlData[i] !== " " &&
              xmlData[i] !== "\t" &&
              xmlData[i] !== "\n" &&
              xmlData[i] !== "\r";
              i++
            ) {
              tagName += xmlData[i];
            }
            tagName = tagName.trim();
            //console.log(tagName);

            if (tagName[tagName.length - 1] === "/") {
              //self closing tag without attributes
              tagName = tagName.substring(0, tagName.length - 1);
              //continue;
              i--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject(
                "InvalidTag",
                msg,
                getLineNumberForPosition(xmlData, i)
              );
            }

            const result = readAttributeStr(xmlData, i);
            if (result === false) {
              return getErrorObject(
                "InvalidAttr",
                "Attributes for '" + tagName + "' have open quote.",
                getLineNumberForPosition(xmlData, i)
              );
            }
            let attrStr = result.value;
            i = result.index;

            if (attrStr[attrStr.length - 1] === "/") {
              //self closing tag
              const attrStrStart = i - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
                //continue; //text may presents after self closing tag
              } else {
                //the result from the nested function returns the position of the error within the attribute
                //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                //this gives us the absolute index in the entire xml, which we can use to find the line at last
                return getErrorObject(
                  isValid.err.code,
                  isValid.err.msg,
                  getLineNumberForPosition(
                    xmlData,
                    attrStrStart + isValid.err.line
                  )
                );
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject(
                  "InvalidTag",
                  "Closing tag '" + tagName + "' doesn't have proper closing.",
                  getLineNumberForPosition(xmlData, i)
                );
              } else if (attrStr.trim().length > 0) {
                return getErrorObject(
                  "InvalidTag",
                  "Closing tag '" +
                    tagName +
                    "' can't have attributes or invalid starting.",
                  getLineNumberForPosition(xmlData, tagStartPos)
                );
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(
                    xmlData,
                    otg.tagStartPos
                  );
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" +
                      otg.tagName +
                      "' (opened in line " +
                      openPos.line +
                      ", col " +
                      openPos.col +
                      ") instead of closing tag '" +
                      tagName +
                      "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }

                //when there are no more tags, we reached the root level.
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                //the result from the nested function returns the position of the error within the attribute
                //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                //this gives us the absolute index in the entire xml, which we can use to find the line at last
                return getErrorObject(
                  isValid.err.code,
                  isValid.err.msg,
                  getLineNumberForPosition(
                    xmlData,
                    i - attrStr.length + isValid.err.line
                  )
                );
              }

              //if the root level has been reached before ...
              if (reachedRoot === true) {
                return getErrorObject(
                  "InvalidXml",
                  "Multiple possible root nodes found.",
                  getLineNumberForPosition(xmlData, i)
                );
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                //don't push into stack
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }

            //skip tag text value
            //It may include comments and CDATA value
            for (i++; i < xmlData.length; i++) {
              if (xmlData[i] === "<") {
                if (xmlData[i + 1] === "!") {
                  //comment or CADATA
                  i++;
                  i = readCommentAndCDATA(xmlData, i);
                  continue;
                } else if (xmlData[i + 1] === "?") {
                  i = readPI(xmlData, ++i);
                  if (i.err) return i;
                } else {
                  break;
                }
              } else if (xmlData[i] === "&") {
                const afterAmp = validateAmpersand(xmlData, i);
                if (afterAmp == -1)
                  return getErrorObject(
                    "InvalidChar",
                    "char '&' is not expected.",
                    getLineNumberForPosition(xmlData, i)
                  );
                i = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                  return getErrorObject(
                    "InvalidXml",
                    "Extra text at the end",
                    getLineNumberForPosition(xmlData, i)
                  );
                }
              }
            } //end of reading tag text value
            if (xmlData[i] === "<") {
              i--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i])) {
            continue;
          }
          return getErrorObject(
            "InvalidChar",
            "char '" + xmlData[i] + "' is not expected.",
            getLineNumberForPosition(xmlData, i)
          );
        }
      }

      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject(
          "InvalidTag",
          "Unclosed tag '" + tags[0].tagName + "'.",
          getLineNumberForPosition(xmlData, tags[0].tagStartPos)
        );
      } else if (tags.length > 0) {
        return getErrorObject(
          "InvalidXml",
          "Invalid '" +
            JSON.stringify(
              tags.map((t) => t.tagName),
              null,
              4
            ).replace(/\r?\n/g, "") +
            "' found.",
          { line: 1, col: 1 }
        );
      }

      return true;
    };

    function isWhiteSpace(char) {
      return char === " " || char === "\t" || char === "\n" || char === "\r";
    }
    /**
     * Read Processing insstructions and skip
     * @param {*} xmlData
     * @param {*} i
     */
    function readPI(xmlData, i) {
      const start = i;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] == "?" || xmlData[i] == " ") {
          //tagname
          const tagname = xmlData.substr(start, i - start);
          if (i > 5 && tagname === "xml") {
            return getErrorObject(
              "InvalidXml",
              "XML declaration allowed only at the start of the document.",
              getLineNumberForPosition(xmlData, i)
            );
          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
            //check if valid attribut string
            i++;
            break;
          } else {
            continue;
          }
        }
      }
      return i;
    }

    function readCommentAndCDATA(xmlData, i) {
      if (
        xmlData.length > i + 5 &&
        xmlData[i + 1] === "-" &&
        xmlData[i + 2] === "-"
      ) {
        //comment
        for (i += 3; i < xmlData.length; i++) {
          if (
            xmlData[i] === "-" &&
            xmlData[i + 1] === "-" &&
            xmlData[i + 2] === ">"
          ) {
            i += 2;
            break;
          }
        }
      } else if (
        xmlData.length > i + 8 &&
        xmlData[i + 1] === "D" &&
        xmlData[i + 2] === "O" &&
        xmlData[i + 3] === "C" &&
        xmlData[i + 4] === "T" &&
        xmlData[i + 5] === "Y" &&
        xmlData[i + 6] === "P" &&
        xmlData[i + 7] === "E"
      ) {
        let angleBracketsCount = 1;
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (
        xmlData.length > i + 9 &&
        xmlData[i + 1] === "[" &&
        xmlData[i + 2] === "C" &&
        xmlData[i + 3] === "D" &&
        xmlData[i + 4] === "A" &&
        xmlData[i + 5] === "T" &&
        xmlData[i + 6] === "A" &&
        xmlData[i + 7] === "["
      ) {
        for (i += 8; i < xmlData.length; i++) {
          if (
            xmlData[i] === "]" &&
            xmlData[i + 1] === "]" &&
            xmlData[i + 2] === ">"
          ) {
            i += 2;
            break;
          }
        }
      }

      return i;
    }

    const doubleQuote = '"';
    const singleQuote = "'";

    /**
     * Keep reading xmlData until '<' is found outside the attribute value.
     * @param {string} xmlData
     * @param {number} i
     */
    function readAttributeStr(xmlData, i) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i];
          } else if (startChar !== xmlData[i]) {
            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
          } else {
            startChar = "";
          }
        } else if (xmlData[i] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i];
      }
      if (startChar !== "") {
        return false;
      }

      return {
        value: attrStr,
        index: i,
        tagClosed: tagClosed,
      };
    }

    /**
     * Select all the attributes whether valid or invalid.
     */
    const validAttrStrRegxp = new RegExp(
      "(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?",
      "g"
    );

    //attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

    function validateAttributeString(attrStr, options) {
      //console.log("start:"+attrStr+":end");

      //if(attrStr.trim().length === 0) return true; //empty string

      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};

      for (let i = 0; i < matches.length; i++) {
        if (matches[i][1].length === 0) {
          //nospace before attribute name: a="sd"b="saf"
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + matches[i][2] + "' has no space in starting.",
            getPositionFromMatch(matches[i])
          );
        } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + matches[i][2] + "' is without value.",
            getPositionFromMatch(matches[i])
          );
        } else if (
          matches[i][3] === undefined &&
          !options.allowBooleanAttributes
        ) {
          //independent attribute: ab
          return getErrorObject(
            "InvalidAttr",
            "boolean attribute '" + matches[i][2] + "' is not allowed.",
            getPositionFromMatch(matches[i])
          );
        }
        /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
        const attrName = matches[i][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + attrName + "' is an invalid name.",
            getPositionFromMatch(matches[i])
          );
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          //check for duplicate attribute.
          attrNames[attrName] = 1;
        } else {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + attrName + "' is repeated.",
            getPositionFromMatch(matches[i])
          );
        }
      }

      return true;
    }

    function validateNumberAmpersand(xmlData, i) {
      let re = /\d/;
      if (xmlData[i] === "x") {
        i++;
        re = /[\da-fA-F]/;
      }
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === ";") return i;
        if (!xmlData[i].match(re)) break;
      }
      return -1;
    }

    function validateAmpersand(xmlData, i) {
      // https://www.w3.org/TR/xml/#dt-charref
      i++;
      if (xmlData[i] === ";") return -1;
      if (xmlData[i] === "#") {
        i++;
        return validateNumberAmpersand(xmlData, i);
      }
      let count = 0;
      for (; i < xmlData.length; i++, count++) {
        if (xmlData[i].match(/\w/) && count < 20) continue;
        if (xmlData[i] === ";") break;
        return -1;
      }
      return i;
    }

    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code: code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col,
        },
      };
    }

    function validateAttrName(attrName) {
      return util.isName(attrName);
    }

    // const startsWithXML = /^xml/i;

    function validateTagName(tagname) {
      return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
    }

    //this function returns the line number for the character at the given index
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,

        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1,
      };
    }

    //this function returns the position of the first character of match within attrStr
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }

    /***/
  },

  /***/ 660: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    //parse Empty Node as self closing node
    const buildFromOrderedJs = __nccwpck_require__(2462);

    const defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function (key, a) {
        return a;
      },
      attributeValueProcessor: function (attrName, a) {
        return a;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" }, //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" },
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false,
    };

    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function (/*a*/) {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }

      this.processTextOrObjNode = processTextOrObjNode;

      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function () {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }

    Builder.prototype.build = function (jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (
          Array.isArray(jObj) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1
        ) {
          jObj = {
            [this.options.arrayNodeName]: jObj,
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };

    Builder.prototype.j2x = function (jObj, level) {
      let attrStr = "";
      let val = "";
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
        if (typeof jObj[key] === "undefined") {
          // supress undefined node only if it is not an attribute
          if (this.isAttribute(key)) {
            val += "";
          }
        } else if (jObj[key] === null) {
          // null attribute should be ignored by the attribute list, but should not cause the tag closing
          if (this.isAttribute(key)) {
            val += "";
          } else if (key[0] === "?") {
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          //premitive type
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            //tag value
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          //repeated nodes
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
              // supress undefined node
            } else if (item === null) {
              if (key[0] === "?")
                val +=
                  this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val +=
                  this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val += listTagVal;
        } else {
          //nested node
          if (
            this.options.attributesGroupName &&
            key === this.options.attributesGroupName
          ) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr: attrStr, val: val };
    };

    Builder.prototype.buildAttrPairStr = function (attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else return " " + attrName + '="' + val + '"';
    };

    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (
        object[this.options.textNodeName] !== undefined &&
        Object.keys(object).length === 1
      ) {
        return this.buildTextValNode(
          object[this.options.textNodeName],
          key,
          result.attrStr,
          level
        );
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }

    Builder.prototype.buildObjectNode = function (val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?")
          return (
            this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar
          );
        else {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            this.closeTag(key) +
            this.tagEndChar
          );
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";

        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }

        // attrStr is an empty string in case the attribute came as undefined or null
        if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            piClosingChar +
            ">" +
            val +
            tagEndExp
          );
        } else if (
          this.options.commentPropName !== false &&
          key === this.options.commentPropName &&
          piClosingChar.length === 0
        ) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            piClosingChar +
            this.tagEndChar +
            val +
            this.indentate(level) +
            tagEndExp
          );
        }
      }
    };

    Builder.prototype.closeTag = function (key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        //unpaired
        if (!this.options.suppressUnpairedNode) closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        //empty
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };

    function buildEmptyObjNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildObjectNode(val, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return (
            this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar
          );
        else {
          return (
            this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar
          );
          // return this.buildTagStr(level,key, attrStr);
        }
      }
    }

    Builder.prototype.buildTextValNode = function (val, key, attrStr, level) {
      if (
        this.options.cdataPropName !== false &&
        key === this.options.cdataPropName
      ) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (
        this.options.commentPropName !== false &&
        key === this.options.commentPropName
      ) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        //PI tag
        return (
          this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar
        );
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);

        if (textValue === "") {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            this.closeTag(key) +
            this.tagEndChar
          );
        } else {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            ">" +
            textValue +
            "</" +
            key +
            this.tagEndChar
          );
        }
      }
    };

    Builder.prototype.replaceEntitiesValue = function (textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i = 0; i < this.options.entities.length; i++) {
          const entity = this.options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };

    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }

    function isAttribute(name /*, options*/) {
      if (
        name.startsWith(this.options.attributeNamePrefix) &&
        name !== this.options.textNodeName
      ) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }

    module.exports = Builder;

    /***/
  },

  /***/ 2462: /***/ (module) => {
    const EOL = "\n";

    /**
     *
     * @param {array} jArray
     * @param {any} options
     * @returns
     */
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }

    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;

      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if (tagName === undefined) continue;

        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr +=
            indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName =
            piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(
          tagObj[tagName],
          options,
          newJPath,
          newIdentation
        );
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
          else xmlStr += tagStart + "/>";
        } else if (
          (!tagValue || tagValue.length === 0) &&
          options.suppressEmptyNode
        ) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (
            tagValue &&
            indentation !== "" &&
            (tagValue.includes("/>") || tagValue.includes("</"))
          ) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }

      return xmlStr;
    }

    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
      }
    }

    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr)) continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }

    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (
          options.stopNodes[index] === jPath ||
          options.stopNodes[index] === "*." + tagName
        )
          return true;
      }
      return false;
    }

    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
          const entity = options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;

    /***/
  },

  /***/ 6072: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const util = __nccwpck_require__(8280);

    //TODO: handle comments
    function readDocType(xmlData, i) {
      const entities = {};
      if (
        xmlData[i + 3] === "O" &&
        xmlData[i + 4] === "C" &&
        xmlData[i + 5] === "T" &&
        xmlData[i + 6] === "Y" &&
        xmlData[i + 7] === "P" &&
        xmlData[i + 8] === "E"
      ) {
        i = i + 9;
        let angleBracketsCount = 1;
        let hasBody = false,
          comment = false;
        let exp = "";
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<" && !comment) {
            //Determine the tag type
            if (hasBody && isEntity(xmlData, i)) {
              i += 7;
              [entityName, val, i] = readEntityExp(xmlData, i + 1);
              if (val.indexOf("&") === -1)
                //Parameter entities are not supported
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val: val,
                };
            } else if (hasBody && isElement(xmlData, i))
              i += 8; //Not supported
            else if (hasBody && isAttlist(xmlData, i))
              i += 8; //Not supported
            else if (hasBody && isNotation(xmlData, i))
              i += 9; //Not supported
            else if (isComment) comment = true;
            else throw new Error("Invalid DOCTYPE");

            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i] === ">") {
            //Read tag content
            if (comment) {
              if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i };
    }

    function readEntityExp(xmlData, i) {
      //External entities are not supported
      //    <!ENTITY ext SYSTEM "http://normal-website.com" >

      //Parameter entities are not supported
      //    <!ENTITY entityname "&anotherElement;">

      //Internal entities are supported
      //    <!ENTITY entityname "replacement text">

      //read EntityName
      let entityName = "";
      for (
        ;
        i < xmlData.length && xmlData[i] !== "'" && xmlData[i] !== '"';
        i++
      ) {
        // if(xmlData[i] === " ") continue;
        // else
        entityName += xmlData[i];
      }
      entityName = entityName.trim();
      if (entityName.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");

      //read Entity Value
      const startChar = xmlData[i++];
      let val = "";
      for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
        val += xmlData[i];
      }
      return [entityName, val, i];
    }

    function isComment(xmlData, i) {
      if (
        xmlData[i + 1] === "!" &&
        xmlData[i + 2] === "-" &&
        xmlData[i + 3] === "-"
      )
        return true;
      return false;
    }
    function isEntity(xmlData, i) {
      if (
        xmlData[i + 1] === "!" &&
        xmlData[i + 2] === "E" &&
        xmlData[i + 3] === "N" &&
        xmlData[i + 4] === "T" &&
        xmlData[i + 5] === "I" &&
        xmlData[i + 6] === "T" &&
        xmlData[i + 7] === "Y"
      )
        return true;
      return false;
    }
    function isElement(xmlData, i) {
      if (
        xmlData[i + 1] === "!" &&
        xmlData[i + 2] === "E" &&
        xmlData[i + 3] === "L" &&
        xmlData[i + 4] === "E" &&
        xmlData[i + 5] === "M" &&
        xmlData[i + 6] === "E" &&
        xmlData[i + 7] === "N" &&
        xmlData[i + 8] === "T"
      )
        return true;
      return false;
    }

    function isAttlist(xmlData, i) {
      if (
        xmlData[i + 1] === "!" &&
        xmlData[i + 2] === "A" &&
        xmlData[i + 3] === "T" &&
        xmlData[i + 4] === "T" &&
        xmlData[i + 5] === "L" &&
        xmlData[i + 6] === "I" &&
        xmlData[i + 7] === "S" &&
        xmlData[i + 8] === "T"
      )
        return true;
      return false;
    }
    function isNotation(xmlData, i) {
      if (
        xmlData[i + 1] === "!" &&
        xmlData[i + 2] === "N" &&
        xmlData[i + 3] === "O" &&
        xmlData[i + 4] === "T" &&
        xmlData[i + 5] === "A" &&
        xmlData[i + 6] === "T" &&
        xmlData[i + 7] === "I" &&
        xmlData[i + 8] === "O" &&
        xmlData[i + 9] === "N"
      )
        return true;
      return false;
    }

    function validateEntityName(name) {
      if (util.isName(name)) return name;
      else throw new Error(`Invalid entity name ${name}`);
    }

    module.exports = readDocType;

    /***/
  },

  /***/ 6993: /***/ (__unused_webpack_module, exports) => {
    const defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false, // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false, //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true, //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true,
      },
      tagValueProcessor: function (tagName, val) {
        return val;
      },
      attributeValueProcessor: function (attrName, val) {
        return val;
      },
      stopNodes: [], //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function (tagName, jPath, attrs) {
        return tagName;
      },
      // skipEmptyListItem: false
    };

    const buildOptions = function (options) {
      return Object.assign({}, defaultOptions, options);
    };

    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;

    /***/
  },

  /***/ 5832: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    ///@ts-check

    const util = __nccwpck_require__(8280);
    const xmlNode = __nccwpck_require__(7462);
    const readDocType = __nccwpck_require__(6072);
    const toNumber = __nccwpck_require__(4526);

    // const regx =
    //   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
    //   .replace(/NAME/g, util.nameRegexp);

    //const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
    //const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

    class OrderedObjParser {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
          gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
          lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
          quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          space: { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          cent: { regex: /&(cent|#162);/g, val: "¢" },
          pound: { regex: /&(pound|#163);/g, val: "£" },
          yen: { regex: /&(yen|#165);/g, val: "¥" },
          euro: { regex: /&(euro|#8364);/g, val: "€" },
          copyright: { regex: /&(copy|#169);/g, val: "©" },
          reg: { regex: /&(reg|#174);/g, val: "®" },
          inr: { regex: /&(inr|#8377);/g, val: "₹" },
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    }

    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i = 0; i < entKeys.length; i++) {
        const ent = entKeys[i];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent],
        };
      }
    }

    /**
     * @param {string} val
     * @param {string} tagName
     * @param {string} jPath
     * @param {boolean} dontTrim
     * @param {boolean} hasAttributes
     * @param {boolean} isLeafNode
     * @param {boolean} escapeEntities
     */
    function parseTextData(
      val,
      tagName,
      jPath,
      dontTrim,
      hasAttributes,
      isLeafNode,
      escapeEntities
    ) {
      if (val !== undefined) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities) val = this.replaceEntitiesValue(val);

          const newval = this.options.tagValueProcessor(
            tagName,
            val,
            jPath,
            hasAttributes,
            isLeafNode
          );
          if (newval === null || newval === undefined) {
            //don't parse
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            //overwrite
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(
              val,
              this.options.parseTagValue,
              this.options.numberParseOptions
            );
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(
                val,
                this.options.parseTagValue,
                this.options.numberParseOptions
              );
            } else {
              return val;
            }
          }
        }
      }
    }

    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }

    //TODO: change regex to capture NS
    //const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
    const attrsRegx = new RegExp(
      "([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?",
      "gm"
    );

    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        // attrStr = attrStr.replace(/\r?\n/g, ' ');
        //attrStr = attrStr || attrStr.trim();

        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length; //don't make it inline
        const attrs = {};
        for (let i = 0; i < len; i++) {
          const attrName = this.resolveNameSpace(matches[i][1]);
          let oldVal = matches[i][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__") aName = "#__proto__";
            if (oldVal !== undefined) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(
                attrName,
                oldVal,
                jPath
              );
              if (newVal === null || newVal === undefined) {
                //don't parse
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                //overwrite
                attrs[aName] = newVal;
              } else {
                //parse
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }

    const parseXml = function (xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i = 0; i < xmlData.length; i++) {
        //for each char in XML data
        const ch = xmlData[i];
        if (ch === "<") {
          // const nextIndex = i+1;
          // const _2ndChar = xmlData[nextIndex];
          if (xmlData[i + 1] === "/") {
            //Closing Tag
            const closeIndex = findClosingIndex(
              xmlData,
              ">",
              i,
              "Closing Tag is not closed."
            );
            let tagName = xmlData.substring(i + 2, closeIndex).trim();

            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }

            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }

            //check if last tag of nested tag was unpaired tag
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(
                `Unpaired tag can not be used as closing tag: </${tagName}>`
              );
            }
            let propIndex = 0;
            if (
              lastTagName &&
              this.options.unpairedTags.indexOf(lastTagName) !== -1
            ) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);

            currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope
            textData = "";
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            let tagData = readTagExp(xmlData, i, false, "?>");
            if (!tagData) throw new Error("Pi Tag is not closed.");

            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (
              (this.options.ignoreDeclaration && tagData.tagName === "?xml") ||
              this.options.ignorePiTags
            ) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");

              if (
                tagData.tagName !== tagData.tagExp &&
                tagData.attrExpPresent
              ) {
                childNode[":@"] = this.buildAttributesMap(
                  tagData.tagExp,
                  jPath,
                  tagData.tagName
                );
              }
              this.addChild(currentNode, childNode, jPath);
            }

            i = tagData.closeIndex + 1;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const endIndex = findClosingIndex(
              xmlData,
              "-->",
              i + 4,
              "Comment is not closed."
            );
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i + 4, endIndex - 2);

              textData = this.saveTextToParentTag(textData, currentNode, jPath);

              currentNode.add(this.options.commentPropName, [
                { [this.options.textNodeName]: comment },
              ]);
            }
            i = endIndex;
          } else if (xmlData.substr(i + 1, 2) === "!D") {
            const result = readDocType(xmlData, i);
            this.docTypeEntities = result.entities;
            i = result.i;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex =
              findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i + 9, closeIndex);

            textData = this.saveTextToParentTag(textData, currentNode, jPath);

            let val = this.parseTextData(
              tagExp,
              currentNode.tagname,
              jPath,
              true,
              false,
              true,
              true
            );
            if (val == undefined) val = "";

            //cdata should be set even if it is 0 length string
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [
                { [this.options.textNodeName]: tagExp },
              ]);
            } else {
              currentNode.add(this.options.textNodeName, val);
            }

            i = closeIndex + 2;
          } else {
            //Opening tag
            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;

            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            //save text as child node
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                //when nested tag is found
                textData = this.saveTextToParentTag(
                  textData,
                  currentNode,
                  jPath,
                  false
                );
              }
            }

            //check if last tag was unpaired tag
            const lastTag = currentNode;
            if (
              lastTag &&
              this.options.unpairedTags.indexOf(lastTag.tagname) !== -1
            ) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              //self-closing tag
              if (
                tagExp.length > 0 &&
                tagExp.lastIndexOf("/") === tagExp.length - 1
              ) {
                i = result.closeIndex;
              }
              //unpaired tag
              else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i = result.closeIndex;
              }
              //normal tag
              else {
                //read until closing tag is found
                const result = this.readStopNodeData(
                  xmlData,
                  rawTagName,
                  closeIndex + 1
                );
                if (!result) throw new Error(`Unexpected end of ${rawTagName}`);
                i = result.i;
                tagContent = result.tagContent;
              }

              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(
                  tagExp,
                  jPath,
                  tagName
                );
              }
              if (tagContent) {
                tagContent = this.parseTextData(
                  tagContent,
                  tagName,
                  jPath,
                  true,
                  attrExpPresent,
                  true,
                  true
                );
              }

              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);

              this.addChild(currentNode, childNode, jPath);
            } else {
              //selfClosing tag
              if (
                tagExp.length > 0 &&
                tagExp.lastIndexOf("/") === tagExp.length - 1
              ) {
                if (tagName[tagName.length - 1] === "/") {
                  //remove trailing '/'
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }

                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }

                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(
                    tagExp,
                    jPath,
                    tagName
                  );
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              }
              //opening tag
              else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);

                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(
                    tagExp,
                    jPath,
                    tagName
                  );
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i = closeIndex;
            }
          }
        } else {
          textData += xmlData[i];
        }
      }
      return xmlObj.child;
    };

    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(
        childNode.tagname,
        jPath,
        childNode[":@"]
      );
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }

    const replaceEntitiesValue = function (val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        //store previously collected data as textNode
        if (isLeafNode === undefined)
          isLeafNode = Object.keys(currentNode.child).length === 0;

        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"]
            ? Object.keys(currentNode[":@"]).length !== 0
            : false,
          isLeafNode
        );

        if (textData !== undefined && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }

    //TODO: use jPath to simplify the logic
    /**
     *
     * @param {string[]} stopNodes
     * @param {string} jPath
     * @param {string} currentTagName
     */
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
      }
      return false;
    }

    /**
     * Returns the tag Expression and where it is ending handling single-double quotes situation
     * @param {string} xmlData
     * @param {number} i starting index
     * @returns
     */
    function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary) attrBoundary = ""; //reset
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index: index,
              };
            }
          } else {
            return {
              data: tagExp,
              index: index,
            };
          }
        } else if (ch === "\t") {
          ch = " ";
        }
        tagExp += ch;
      }
    }

    function findClosingIndex(xmlData, str, i, errMsg) {
      const closingIndex = xmlData.indexOf(str, i);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }

    function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
      if (!result) return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        //separate tag name and attributes expression
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }

      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }

      return {
        tagName: tagName,
        tagExp: tagExp,
        closeIndex: closeIndex,
        attrExpPresent: attrExpPresent,
        rawTagName: rawTagName,
      };
    }
    /**
     * find paired tag for a stop node
     * @param {string} xmlData
     * @param {string} tagName
     * @param {number} i
     */
    function readStopNodeData(xmlData, tagName, i) {
      const startIndex = i;
      // Starting at 1 since we already have an open tag
      let openTagCount = 1;

      for (; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          if (xmlData[i + 1] === "/") {
            //close tag
            const closeIndex = findClosingIndex(
              xmlData,
              ">",
              i,
              `${tagName} is not closed`
            );
            let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i),
                  i: closeIndex,
                };
              }
            }
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            const closeIndex = findClosingIndex(
              xmlData,
              "?>",
              i + 1,
              "StopNode is not closed."
            );
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(
              xmlData,
              "-->",
              i + 3,
              "StopNode is not closed."
            );
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex =
              findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") -
              2;
            i = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i, ">");

            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (
                openTagName === tagName &&
                tagData.tagExp[tagData.tagExp.length - 1] !== "/"
              ) {
                openTagCount++;
              }
              i = tagData.closeIndex;
            }
          }
        }
      } //end for loop
    }

    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        //console.log(options)
        const newval = val.trim();
        if (newval === "true") return true;
        else if (newval === "false") return false;
        else return toNumber(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }

    module.exports = OrderedObjParser;

    /***/
  },

  /***/ 2380: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { buildOptions } = __nccwpck_require__(6993);
    const OrderedObjParser = __nccwpck_require__(5832);
    const { prettify } = __nccwpck_require__(2882);
    const validator = __nccwpck_require__(1739);

    class XMLParser {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object
       * @param {string|Buffer} xmlData
       * @param {boolean|Object} validationOption
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true) validationOption = {}; //validate with default options

          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(
              `${result.err.msg}:${result.err.line}:${result.err.col}`
            );
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === undefined)
          return orderedResult;
        else return prettify(orderedResult, this.options);
      }

      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key
       * @param {string} value
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'"
          );
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    }

    module.exports = XMLParser;

    /***/
  },

  /***/ 2882: /***/ (__unused_webpack_module, exports) => {
    /**
     *
     * @param {array} node
     * @param {any} options
     * @returns
     */
    function prettify(node, options) {
      return compress(node, options);
    }

    /**
     *
     * @param {array} arr
     * @param {object} options
     * @param {string} jPath
     * @returns object
     */
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === undefined) newJpath = property;
        else newJpath = jPath + "." + property;

        if (property === options.textNodeName) {
          if (text === undefined) text = tagObj[property];
          else text += "" + tagObj[property];
        } else if (property === undefined) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);

          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (
            Object.keys(val).length === 1 &&
            val[options.textNodeName] !== undefined &&
            !options.alwaysCreateTextNode
          ) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
            else val = "";
          }

          if (
            compressedObj[property] !== undefined &&
            compressedObj.hasOwnProperty(property)
          ) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            //TODO: if a node is not an array, then check if it should be an array
            //also determine if it is a leaf node
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
      if (typeof text === "string") {
        if (text.length > 0) compressedObj[options.textNodeName] = text;
      } else if (text !== undefined) compressedObj[options.textNodeName] = text;
      return compressedObj;
    }

    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
      }
    }

    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length; //don't make it inline
        for (let i = 0; i < len; i++) {
          const atrrName = keys[i];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }

    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;

      if (propCount === 0) {
        return true;
      }

      if (
        propCount === 1 &&
        (obj[textNodeName] ||
          typeof obj[textNodeName] === "boolean" ||
          obj[textNodeName] === 0)
      ) {
        return true;
      }

      return false;
    }
    exports.prettify = prettify;

    /***/
  },

  /***/ 7462: /***/ (module) => {
    class XmlNode {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = []; //nested tags, text, cdata, comments in order
        this[":@"] = {}; //attributes map
      }
      add(key, val) {
        // this.child.push( {name : key, val: val, isCdata: isCdata });
        if (key === "__proto__") key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    }

    module.exports = XmlNode;

    /***/
  },

  /***/ 9618: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const mkdirsSync = __nccwpck_require__(8605).mkdirsSync;
    const utimesMillisSync = __nccwpck_require__(2548).utimesMillisSync;
    const stat = __nccwpck_require__(3901);

    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }

      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true; // default to true for now
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

      // Warn about using preserveTimestamps on 32-bit node
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" +
            "\tsee https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }

      const { srcStat, destStat } = stat.checkPathsSync(
        src,
        dest,
        "copy",
        opts
      );
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path.dirname(dest);
      if (!fs.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }

    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
      const srcStat = statSync(src);

      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (
        srcStat.isFile() ||
        srcStat.isCharacterDevice() ||
        srcStat.isBlockDevice()
      )
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }

    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }

    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }

    function copyFile(srcStat, src, dest, opts) {
      fs.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }

    function handleTimestamps(srcMode, src, dest) {
      // Make sure the file is writable before setting the timestamp
      // otherwise open fails with EPERM when invoked with 'r+'
      // (through utimes call)
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }

    function fileIsNotWritable(srcMode) {
      return (srcMode & 0o200) === 0;
    }

    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 0o200);
    }

    function setDestMode(dest, srcMode) {
      return fs.chmodSync(dest, srcMode);
    }

    function setDestTimestamps(src, dest) {
      // The initial srcStat.atime cannot be trusted
      // because it is modified by the read(2) system call
      // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
      const updatedSrcStat = fs.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }

    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }

    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }

    function copyDir(src, dest, opts) {
      fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }

    function copyDirItem(item, src, dest, opts) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }

    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }

      if (!destStat) {
        return fs.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs.readlinkSync(dest);
        } catch (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(
            `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
          );
        }

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(
            `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
          );
        }
        return copyLink(resolvedSrc, dest);
      }
    }

    function copyLink(resolvedSrc, dest) {
      fs.unlinkSync(dest);
      return fs.symlinkSync(resolvedSrc, dest);
    }

    module.exports = copySync;

    /***/
  },

  /***/ 8834: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(1176);
    const path = __nccwpck_require__(1017);
    const { mkdirs } = __nccwpck_require__(8605);
    const { pathExists } = __nccwpck_require__(3835);
    const { utimesMillis } = __nccwpck_require__(2548);
    const stat = __nccwpck_require__(3901);

    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }

      opts.clobber = "clobber" in opts ? !!opts.clobber : true; // default to true for now
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

      // Warn about using preserveTimestamps on 32-bit node
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" +
            "\tsee https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }

      const { srcStat, destStat } = await stat.checkPaths(
        src,
        dest,
        "copy",
        opts
      );

      await stat.checkParentPaths(src, srcStat, dest, "copy");

      const include = await runFilter(src, dest, opts);

      if (!include) return;

      // check if the parent of dest exists, and create it if it doesn't exist
      const destParent = path.dirname(dest);
      const dirExists = await pathExists(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }

      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }

    async function runFilter(src, dest, opts) {
      if (!opts.filter) return true;
      return opts.filter(src, dest);
    }

    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs.stat : fs.lstat;
      const srcStat = await statFn(src);

      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);

      if (
        srcStat.isFile() ||
        srcStat.isCharacterDevice() ||
        srcStat.isBlockDevice()
      )
        return onFile(srcStat, destStat, src, dest, opts);

      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }

    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);

      if (opts.overwrite) {
        await fs.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }

    async function copyFile(srcStat, src, dest, opts) {
      await fs.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        // Make sure the file is writable before setting the timestamp
        // otherwise open fails with EPERM when invoked with 'r+'
        // (through utimes call)
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }

        // Set timestamps and mode correspondingly

        // Note that The initial srcStat.atime cannot be trusted
        // because it is modified by the read(2) system call
        // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
        const updatedSrcStat = await fs.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }

      return fs.chmod(dest, srcStat.mode);
    }

    function fileIsNotWritable(srcMode) {
      return (srcMode & 0o200) === 0;
    }

    function makeFileWritable(dest, srcMode) {
      return fs.chmod(dest, srcMode | 0o200);
    }

    async function onDir(srcStat, destStat, src, dest, opts) {
      // the dest directory might not exist, create it
      if (!destStat) {
        await fs.mkdir(dest);
      }

      const items = await fs.readdir(src);

      // loop through the files in the current directory to copy everything
      await Promise.all(
        items.map(async (item) => {
          const srcItem = path.join(src, item);
          const destItem = path.join(dest, item);

          // skip the item if it is matches by the filter function
          const include = await runFilter(srcItem, destItem, opts);
          if (!include) return;

          const { destStat } = await stat.checkPaths(
            srcItem,
            destItem,
            "copy",
            opts
          );

          // If the item is a copyable file, `getStatsAndPerformCopy` will copy it
          // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively
          return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);
        })
      );

      if (!destStat) {
        await fs.chmod(dest, srcStat.mode);
      }
    }

    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs.symlink(resolvedSrc, dest);
      }

      let resolvedDest = null;
      try {
        resolvedDest = await fs.readlink(dest);
      } catch (e) {
        // dest exists and is a regular file or directory,
        // Windows may throw UNKNOWN error. If dest already exists,
        // fs throws error anyway, so no need to guard against it here.
        if (e.code === "EINVAL" || e.code === "UNKNOWN")
          return fs.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(
          `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
        );
      }

      // do not copy if src is a subdir of dest since unlinking
      // dest in this case would result in removing src contents
      // and therefore a broken symlink would be created.
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(
          `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
        );
      }

      // copy the link
      await fs.unlink(dest);
      return fs.symlink(resolvedSrc, dest);
    }

    module.exports = copy;

    /***/
  },

  /***/ 1335: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    module.exports = {
      copy: u(__nccwpck_require__(8834)),
      copySync: __nccwpck_require__(9618),
    };

    /***/
  },

  /***/ 6970: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const fs = __nccwpck_require__(1176);
    const path = __nccwpck_require__(1017);
    const mkdir = __nccwpck_require__(8605);
    const remove = __nccwpck_require__(7357);

    const emptyDir = u(async function emptyDir(dir) {
      let items;
      try {
        items = await fs.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }

      return Promise.all(
        items.map((item) => remove.remove(path.join(dir, item)))
      );
    });

    function emptyDirSync(dir) {
      let items;
      try {
        items = fs.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }

      items.forEach((item) => {
        item = path.join(dir, item);
        remove.removeSync(item);
      });
    }

    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir,
    };

    /***/
  },

  /***/ 2164: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(1176);
    const mkdir = __nccwpck_require__(8605);

    async function createFile(file) {
      let stats;
      try {
        stats = await fs.stat(file);
      } catch {}
      if (stats && stats.isFile()) return;

      const dir = path.dirname(file);

      let dirStats = null;
      try {
        dirStats = await fs.stat(dir);
      } catch (err) {
        // if the directory doesn't exist, make it
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }

      if (dirStats.isDirectory()) {
        await fs.writeFile(file, "");
      } else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        await fs.readdir(dir);
      }
    }

    function createFileSync(file) {
      let stats;
      try {
        stats = fs.statSync(file);
      } catch {}
      if (stats && stats.isFile()) return;

      const dir = path.dirname(file);
      try {
        if (!fs.statSync(dir).isDirectory()) {
          // parent is not a directory
          // This is just to cause an internal ENOTDIR error to be thrown
          fs.readdirSync(dir);
        }
      } catch (err) {
        // If the stat call above failed because the directory doesn't exist, create it
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }

      fs.writeFileSync(file, "");
    }

    module.exports = {
      createFile: u(createFile),
      createFileSync,
    };

    /***/
  },

  /***/ 55: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { createFile, createFileSync } = __nccwpck_require__(2164);
    const { createLink, createLinkSync } = __nccwpck_require__(3797);
    const { createSymlink, createSymlinkSync } = __nccwpck_require__(2549);

    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync,
    };

    /***/
  },

  /***/ 3797: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(1176);
    const mkdir = __nccwpck_require__(8605);
    const { pathExists } = __nccwpck_require__(3835);
    const { areIdentical } = __nccwpck_require__(3901);

    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs.lstat(dstpath);
      } catch {
        // ignore error
      }

      let srcStat;
      try {
        srcStat = await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }

      if (dstStat && areIdentical(srcStat, dstStat)) return;

      const dir = path.dirname(dstpath);

      const dirExists = await pathExists(dir);

      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }

      await fs.link(srcpath, dstpath);
    }

    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs.lstatSync(dstpath);
      } catch {}

      try {
        const srcStat = fs.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }

      const dir = path.dirname(dstpath);
      const dirExists = fs.existsSync(dir);
      if (dirExists) return fs.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);

      return fs.linkSync(srcpath, dstpath);
    }

    module.exports = {
      createLink: u(createLink),
      createLinkSync,
    };

    /***/
  },

  /***/ 3727: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(1176);
    const { pathExists } = __nccwpck_require__(3835);

    const u = __nccwpck_require__(9046).fromPromise;

    /**
     * Function that returns two types of paths, one relative to symlink, and one
     * relative to the current working directory. Checks if path is absolute or
     * relative. If the path is relative, this function checks if the path is
     * relative to symlink or relative to current working directory. This is an
     * initiative to find a smarter `srcpath` to supply when building symlinks.
     * This allows you to determine which path to use out of one of three possible
     * types of source paths. The first is an absolute path. This is detected by
     * `path.isAbsolute()`. When an absolute path is provided, it is checked to
     * see if it exists. If it does it's used, if not an error is returned
     * (callback)/ thrown (sync). The other two options for `srcpath` are a
     * relative url. By default Node's `fs.symlink` works by creating a symlink
     * using `dstpath` and expects the `srcpath` to be relative to the newly
     * created symlink. If you provide a `srcpath` that does not exist on the file
     * system it results in a broken symlink. To minimize this, the function
     * checks to see if the 'relative to symlink' source file exists, and if it
     * does it will use it. If it does not, it checks if there's a file that
     * exists that is relative to the current working directory, if does its used.
     * This preserves the expectations of the original fs.symlink spec and adds
     * the ability to pass in `relative to current working direcotry` paths.
     */

    async function symlinkPaths(srcpath, dstpath) {
      if (path.isAbsolute(srcpath)) {
        try {
          await fs.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }

        return {
          toCwd: srcpath,
          toDst: srcpath,
        };
      }

      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);

      const exists = await pathExists(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath,
        };
      }

      try {
        await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }

      return {
        toCwd: srcpath,
        toDst: path.relative(dstdir, srcpath),
      };
    }

    function symlinkPathsSync(srcpath, dstpath) {
      if (path.isAbsolute(srcpath)) {
        const exists = fs.existsSync(srcpath);
        if (!exists) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath,
        };
      }

      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      const exists = fs.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath,
        };
      }

      const srcExists = fs.existsSync(srcpath);
      if (!srcExists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path.relative(dstdir, srcpath),
      };
    }

    module.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync,
    };

    /***/
  },

  /***/ 8254: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(1176);
    const u = __nccwpck_require__(9046).fromPromise;

    async function symlinkType(srcpath, type) {
      if (type) return type;

      let stats;
      try {
        stats = await fs.lstat(srcpath);
      } catch {
        return "file";
      }

      return stats && stats.isDirectory() ? "dir" : "file";
    }

    function symlinkTypeSync(srcpath, type) {
      if (type) return type;

      let stats;
      try {
        stats = fs.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }

    module.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync,
    };

    /***/
  },

  /***/ 2549: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const path = __nccwpck_require__(1017);
    const fs = __nccwpck_require__(1176);

    const { mkdirs, mkdirsSync } = __nccwpck_require__(8605);

    const { symlinkPaths, symlinkPathsSync } = __nccwpck_require__(3727);
    const { symlinkType, symlinkTypeSync } = __nccwpck_require__(8254);

    const { pathExists } = __nccwpck_require__(3835);

    const { areIdentical } = __nccwpck_require__(3901);

    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs.lstat(dstpath);
      } catch {}

      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs.stat(srcpath),
          fs.stat(dstpath),
        ]);

        if (areIdentical(srcStat, dstStat)) return;
      }

      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path.dirname(dstpath);

      if (!(await pathExists(dir))) {
        await mkdirs(dir);
      }

      return fs.symlink(srcpath, dstpath, toType);
    }

    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs.lstatSync(dstpath);
      } catch {}
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs.statSync(srcpath);
        const dstStat = fs.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }

      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      const exists = fs.existsSync(dir);
      if (exists) return fs.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs.symlinkSync(srcpath, dstpath, type);
    }

    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync,
    };

    /***/
  },

  /***/ 1176: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    // This is adapted from https://github.com/normalize/mz
    // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
    const u = __nccwpck_require__(9046).fromCallback;
    const fs = __nccwpck_require__(7758);

    const api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile",
    ].filter((key) => {
      // Some commands are not available on some systems. Ex:
      // fs.cp was added in Node.js v16.7.0
      // fs.lchown is not available on at least some Linux
      return typeof fs[key] === "function";
    });

    // Export cloned fs:
    Object.assign(exports, fs);

    // Universalify async methods:
    api.forEach((method) => {
      exports[method] = u(fs[method]);
    });

    // We differ from mz/fs in that we still ship the old, broken, fs.exists()
    // since we are a drop-in replacement for the native module
    exports.exists = function (filename, callback) {
      if (typeof callback === "function") {
        return fs.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs.exists(filename, resolve);
      });
    };

    // fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args

    exports.read = function (fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs.read(
          fd,
          buffer,
          offset,
          length,
          position,
          (err, bytesRead, buffer) => {
            if (err) return reject(err);
            resolve({ bytesRead, buffer });
          }
        );
      });
    };

    // Function signature can be
    // fs.write(fd, buffer[, offset[, length[, position]]], callback)
    // OR
    // fs.write(fd, string[, position[, encoding]], callback)
    // We need to handle both cases, so we use ...args
    exports.write = function (fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.write(fd, buffer, ...args);
      }

      return new Promise((resolve, reject) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer });
        });
      });
    };

    // Function signature is
    // s.readv(fd, buffers[, position], callback)
    // We need to handle the optional arg, so we use ...args
    exports.readv = function (fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.readv(fd, buffers, ...args);
      }

      return new Promise((resolve, reject) => {
        fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffers });
        });
      });
    };

    // Function signature is
    // s.writev(fd, buffers[, position], callback)
    // We need to handle the optional arg, so we use ...args
    exports.writev = function (fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.writev(fd, buffers, ...args);
      }

      return new Promise((resolve, reject) => {
        fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers });
        });
      });
    };

    // fs.realpath.native sometimes not available if fs is monkey-patched
    if (typeof fs.realpath.native === "function") {
      exports.realpath.native = u(fs.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }

    /***/
  },

  /***/ 5630: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = {
      // Export promiseified graceful-fs:
      ...__nccwpck_require__(1176),
      // Export extra methods:
      ...__nccwpck_require__(1335),
      ...__nccwpck_require__(6970),
      ...__nccwpck_require__(55),
      ...__nccwpck_require__(213),
      ...__nccwpck_require__(8605),
      ...__nccwpck_require__(1497),
      ...__nccwpck_require__(1832),
      ...__nccwpck_require__(3835),
      ...__nccwpck_require__(7357),
    };

    /***/
  },

  /***/ 213: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const jsonFile = __nccwpck_require__(8970);

    jsonFile.outputJson = u(__nccwpck_require__(531));
    jsonFile.outputJsonSync = __nccwpck_require__(9421);
    // aliases
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;

    module.exports = jsonFile;

    /***/
  },

  /***/ 8970: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const jsonFile = __nccwpck_require__(6160);

    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync,
    };

    /***/
  },

  /***/ 9421: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { stringify } = __nccwpck_require__(5902);
    const { outputFileSync } = __nccwpck_require__(1832);

    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);

      outputFileSync(file, str, options);
    }

    module.exports = outputJsonSync;

    /***/
  },

  /***/ 531: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { stringify } = __nccwpck_require__(5902);
    const { outputFile } = __nccwpck_require__(1832);

    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);

      await outputFile(file, str, options);
    }

    module.exports = outputJson;

    /***/
  },

  /***/ 8605: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const { makeDir: _makeDir, makeDirSync } = __nccwpck_require__(2751);
    const makeDir = u(_makeDir);

    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync,
    };

    /***/
  },

  /***/ 2751: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(1176);
    const { checkPath } = __nccwpck_require__(9907);

    const getMode = (options) => {
      const defaults = { mode: 0o777 };
      if (typeof options === "number") return options;
      return { ...defaults, ...options }.mode;
    };

    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);

      return fs.mkdir(dir, {
        mode: getMode(options),
        recursive: true,
      });
    };

    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);

      return fs.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true,
      });
    };

    /***/
  },

  /***/ 9907: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // Adapted from https://github.com/sindresorhus/make-dir
    // Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    const path = __nccwpck_require__(1017);

    // https://github.com/nodejs/node/issues/8987
    // https://github.com/libuv/libuv/pull/1088
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(
          pth.replace(path.parse(pth).root, "")
        );

        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };

    /***/
  },

  /***/ 1497: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    module.exports = {
      move: u(__nccwpck_require__(2231)),
      moveSync: __nccwpck_require__(2047),
    };

    /***/
  },

  /***/ 2047: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const path = __nccwpck_require__(1017);
    const copySync = __nccwpck_require__(1335).copySync;
    const removeSync = __nccwpck_require__(7357).removeSync;
    const mkdirpSync = __nccwpck_require__(8605).mkdirpSync;
    const stat = __nccwpck_require__(3901);

    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;

      const { srcStat, isChangingCase = false } = stat.checkPathsSync(
        src,
        dest,
        "move",
        opts
      );
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }

    function isParentRoot(dest) {
      const parent = path.dirname(dest);
      const parsedPath = path.parse(parent);
      return parsedPath.root === parent;
    }

    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }

    function rename(src, dest, overwrite) {
      try {
        fs.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }

    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true,
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }

    module.exports = moveSync;

    /***/
  },

  /***/ 2231: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(1176);
    const path = __nccwpck_require__(1017);
    const { copy } = __nccwpck_require__(1335);
    const { remove } = __nccwpck_require__(7357);
    const { mkdirp } = __nccwpck_require__(8605);
    const { pathExists } = __nccwpck_require__(3835);
    const stat = __nccwpck_require__(3901);

    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;

      const { srcStat, isChangingCase = false } = await stat.checkPaths(
        src,
        dest,
        "move",
        opts
      );

      await stat.checkParentPaths(src, srcStat, dest, "move");

      // If the parent of dest is not root, make sure it exists before proceeding
      const destParent = path.dirname(dest);
      const parsedParentPath = path.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }

      return doRename(src, dest, overwrite, isChangingCase);
    }

    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists(dest)) {
          throw new Error("dest already exists.");
        }
      }

      try {
        // Try w/ rename first, and try copy + remove if EXDEV
        await fs.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }

    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true,
      };

      await copy(src, dest, opts);
      return remove(src);
    }

    module.exports = move;

    /***/
  },

  /***/ 1832: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const fs = __nccwpck_require__(1176);
    const path = __nccwpck_require__(1017);
    const mkdir = __nccwpck_require__(8605);
    const pathExists = __nccwpck_require__(3835).pathExists;

    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path.dirname(file);

      if (!(await pathExists(dir))) {
        await mkdir.mkdirs(dir);
      }

      return fs.writeFile(file, data, encoding);
    }

    function outputFileSync(file, ...args) {
      const dir = path.dirname(file);
      if (!fs.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }

      fs.writeFileSync(file, ...args);
    }

    module.exports = {
      outputFile: u(outputFile),
      outputFileSync,
    };

    /***/
  },

  /***/ 3835: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const u = __nccwpck_require__(9046).fromPromise;
    const fs = __nccwpck_require__(1176);

    function pathExists(path) {
      return fs
        .access(path)
        .then(() => true)
        .catch(() => false);
    }

    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs.existsSync,
    };

    /***/
  },

  /***/ 7357: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(7758);
    const u = __nccwpck_require__(9046).fromCallback;

    function remove(path, callback) {
      fs.rm(path, { recursive: true, force: true }, callback);
    }

    function removeSync(path) {
      fs.rmSync(path, { recursive: true, force: true });
    }

    module.exports = {
      remove: u(remove),
      removeSync,
    };

    /***/
  },

  /***/ 3901: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(1176);
    const path = __nccwpck_require__(1017);
    const u = __nccwpck_require__(9046).fromPromise;

    function getStats(src, dest, opts) {
      const statFunc = opts.dereference
        ? (file) => fs.stat(file, { bigint: true })
        : (file) => fs.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        }),
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }

    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference
        ? (file) => fs.statSync(file, { bigint: true })
        : (file) => fs.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }

    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (
            funcName === "move" &&
            srcBaseName !== destBaseName &&
            srcBaseName.toLowerCase() === destBaseName.toLowerCase()
          ) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
          );
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite directory '${dest}' with non-directory '${src}'.`
          );
        }
      }

      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }

      return { srcStat, destStat };
    }

    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);

      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (
            funcName === "move" &&
            srcBaseName !== destBaseName &&
            srcBaseName.toLowerCase() === destBaseName.toLowerCase()
          ) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
          );
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite directory '${dest}' with non-directory '${src}'.`
          );
        }
      }

      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }

    // recursively check if dest parent is a subdirectory of src.
    // It works for all file types including symlinks since it
    // checks the src and dest inodes. It starts from the deepest
    // parent and stops once it reaches the src parent or the root path.
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (
        destParent === srcParent ||
        destParent === path.parse(destParent).root
      )
        return;

      let destStat;
      try {
        destStat = await fs.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }

      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }

      return checkParentPaths(src, srcStat, destParent, funcName);
    }

    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (
        destParent === srcParent ||
        destParent === path.parse(destParent).root
      )
        return;
      let destStat;
      try {
        destStat = fs.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }

    function areIdentical(srcStat, destStat) {
      return (
        destStat.ino &&
        destStat.dev &&
        destStat.ino === srcStat.ino &&
        destStat.dev === srcStat.dev
      );
    }

    // return true if dest is a subdir of src, otherwise false.
    // It only checks the path strings.
    function isSrcSubdir(src, dest) {
      const srcArr = path
        .resolve(src)
        .split(path.sep)
        .filter((i) => i);
      const destArr = path
        .resolve(dest)
        .split(path.sep)
        .filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }

    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }

    module.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical,
    };

    /***/
  },

  /***/ 2548: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const fs = __nccwpck_require__(1176);
    const u = __nccwpck_require__(9046).fromPromise;

    async function utimesMillis(path, atime, mtime) {
      // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
      const fd = await fs.open(path, "r+");

      let closeErr = null;

      try {
        await fs.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }

      if (closeErr) {
        throw closeErr;
      }
    }

    function utimesMillisSync(path, atime, mtime) {
      const fd = fs.openSync(path, "r+");
      fs.futimesSync(fd, atime, mtime);
      return fs.closeSync(fd);
    }

    module.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync,
    };

    /***/
  },

  /***/ 8173: /***/ (module) => {
    module.exports = clone;

    var getPrototypeOf =
      Object.getPrototypeOf ||
      function (obj) {
        return obj.__proto__;
      };

    function clone(obj) {
      if (obj === null || typeof obj !== "object") return obj;

      if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) };
      else var copy = Object.create(null);

      Object.getOwnPropertyNames(obj).forEach(function (key) {
        Object.defineProperty(
          copy,
          key,
          Object.getOwnPropertyDescriptor(obj, key)
        );
      });

      return copy;
    }

    /***/
  },

  /***/ 7758: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    var fs = __nccwpck_require__(7147);
    var polyfills = __nccwpck_require__(263);
    var legacy = __nccwpck_require__(3086);
    var clone = __nccwpck_require__(8173);

    var util = __nccwpck_require__(3837);

    /* istanbul ignore next - node 0.x polyfill */
    var gracefulQueue;
    var previousSymbol;

    /* istanbul ignore else - node 0.x polyfill */
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      // This is used in testing by future versions
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }

    function noop() {}

    function publishQueue(context, queue) {
      Object.defineProperty(context, gracefulQueue, {
        get: function () {
          return queue;
        },
      });
    }

    var debug = noop;
    if (util.debuglog) debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function () {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };

    // Once time initialization
    if (!fs[gracefulQueue]) {
      // This queue can be shared by multiple loaded instances
      var queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);

      // Patch fs.close/closeSync to shared queue version, because we need
      // to retry() whenever a close happens *anywhere* in the program.
      // This is essential when multiple graceful-fs instances are
      // in play at the same time.
      fs.close = (function (fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function (err) {
            // This function uses the graceful-fs shared queue
            if (!err) {
              resetQueue();
            }

            if (typeof cb === "function") cb.apply(this, arguments);
          });
        }

        Object.defineProperty(close, previousSymbol, {
          value: fs$close,
        });
        return close;
      })(fs.close);

      fs.closeSync = (function (fs$closeSync) {
        function closeSync(fd) {
          // This function uses the graceful-fs shared queue
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }

        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync,
        });
        return closeSync;
      })(fs.closeSync);

      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function () {
          debug(fs[gracefulQueue]);
          __nccwpck_require__(9491).equal(fs[gracefulQueue].length, 0);
        });
      }
    }

    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }

    module.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module.exports = patch(fs);
      fs.__patched = true;
    }

    function patch(fs) {
      // Everything that references the open() function needs to be in here
      polyfills(fs);
      fs.gracefulify = patch;

      fs.createReadStream = createReadStream;
      fs.createWriteStream = createWriteStream;
      var fs$readFile = fs.readFile;
      fs.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function") (cb = options), (options = null);

        return go$readFile(path, options, cb);

        function go$readFile(path, options, cb, startTime) {
          return fs$readFile(path, options, function (err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readFile,
                [path, options, cb],
                err,
                startTime || Date.now(),
                Date.now(),
              ]);
            else {
              if (typeof cb === "function") cb.apply(this, arguments);
            }
          });
        }
      }

      var fs$writeFile = fs.writeFile;
      fs.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function") (cb = options), (options = null);

        return go$writeFile(path, data, options, cb);

        function go$writeFile(path, data, options, cb, startTime) {
          return fs$writeFile(path, data, options, function (err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$writeFile,
                [path, data, options, cb],
                err,
                startTime || Date.now(),
                Date.now(),
              ]);
            else {
              if (typeof cb === "function") cb.apply(this, arguments);
            }
          });
        }
      }

      var fs$appendFile = fs.appendFile;
      if (fs$appendFile) fs.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function") (cb = options), (options = null);

        return go$appendFile(path, data, options, cb);

        function go$appendFile(path, data, options, cb, startTime) {
          return fs$appendFile(path, data, options, function (err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$appendFile,
                [path, data, options, cb],
                err,
                startTime || Date.now(),
                Date.now(),
              ]);
            else {
              if (typeof cb === "function") cb.apply(this, arguments);
            }
          });
        }
      }

      var fs$copyFile = fs.copyFile;
      if (fs$copyFile) fs.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);

        function go$copyFile(src, dest, flags, cb, startTime) {
          return fs$copyFile(src, dest, flags, function (err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$copyFile,
                [src, dest, flags, cb],
                err,
                startTime || Date.now(),
                Date.now(),
              ]);
            else {
              if (typeof cb === "function") cb.apply(this, arguments);
            }
          });
        }
      }

      var fs$readdir = fs.readdir;
      fs.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function") (cb = options), (options = null);

        var go$readdir = noReaddirOptionVersions.test(process.version)
          ? function go$readdir(path, options, cb, startTime) {
              return fs$readdir(
                path,
                fs$readdirCallback(path, options, cb, startTime)
              );
            }
          : function go$readdir(path, options, cb, startTime) {
              return fs$readdir(
                path,
                options,
                fs$readdirCallback(path, options, cb, startTime)
              );
            };

        return go$readdir(path, options, cb);

        function fs$readdirCallback(path, options, cb, startTime) {
          return function (err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path, options, cb],
                err,
                startTime || Date.now(),
                Date.now(),
              ]);
            else {
              if (files && files.sort) files.sort();

              if (typeof cb === "function") cb.call(this, err, files);
            }
          };
        }
      }

      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }

      var fs$ReadStream = fs.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }

      var fs$WriteStream = fs.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }

      Object.defineProperty(fs, "ReadStream", {
        get: function () {
          return ReadStream;
        },
        set: function (val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true,
      });
      Object.defineProperty(fs, "WriteStream", {
        get: function () {
          return WriteStream;
        },
        set: function (val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true,
      });

      // legacy names
      var FileReadStream = ReadStream;
      Object.defineProperty(fs, "FileReadStream", {
        get: function () {
          return FileReadStream;
        },
        set: function (val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true,
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs, "FileWriteStream", {
        get: function () {
          return FileWriteStream;
        },
        set: function (val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true,
      });

      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(
            Object.create(ReadStream.prototype),
            arguments
          );
      }

      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            if (that.autoClose) that.destroy();

            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }

      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(
            Object.create(WriteStream.prototype),
            arguments
          );
      }

      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }

      function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
      }

      function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
      }

      var fs$open = fs.open;
      fs.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function") (cb = mode), (mode = null);

        return go$open(path, flags, mode, cb);

        function go$open(path, flags, mode, cb, startTime) {
          return fs$open(path, flags, mode, function (err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$open,
                [path, flags, mode, cb],
                err,
                startTime || Date.now(),
                Date.now(),
              ]);
            else {
              if (typeof cb === "function") cb.apply(this, arguments);
            }
          });
        }
      }

      return fs;
    }

    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }

    // keep track of the timeout between retry() calls
    var retryTimer;

    // reset the startTime and lastTime to now
    // this resets the start of the 60 second overall timeout as well as the
    // delay between attempts so that we'll retry these jobs sooner
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now; // startTime
          fs[gracefulQueue][i][4] = now; // lastTime
        }
      }
      // call retry to make sure we're actively processing the queue
      retry();
    }

    function retry() {
      // clear the timer and remove it to help prevent unintended concurrency
      clearTimeout(retryTimer);
      retryTimer = undefined;

      if (fs[gracefulQueue].length === 0) return;

      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      // these items may be unset if they were added by an older graceful-fs
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];

      // if we don't have a startTime we have no way of knowing if we've waited
      // long enough, so go ahead and retry this item now
      if (startTime === undefined) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function") cb.call(null, err);
      } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          // if we can't do this job yet, push it to the end of the queue
          // and let the next iteration check again
          fs[gracefulQueue].push(elem);
        }
      }

      // schedule our next run if one isn't already scheduled
      if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
      }
    }

    /***/
  },

  /***/ 3086: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    var Stream = __nccwpck_require__(2781).Stream;

    module.exports = legacy;

    function legacy(fs) {
      return {
        ReadStream: ReadStream,
        WriteStream: WriteStream,
      };

      function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);

        Stream.call(this);

        var self = this;

        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;

        this.flags = "r";
        this.mode = 438; /*=0666*/
        this.bufferSize = 64 * 1024;

        options = options || {};

        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }

        if (this.encoding) this.setEncoding(this.encoding);

        if (this.start !== undefined) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === undefined) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }

          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }

          this.pos = this.start;
        }

        if (this.fd !== null) {
          process.nextTick(function () {
            self._read();
          });
          return;
        }

        fs.open(this.path, this.flags, this.mode, function (err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }

          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }

      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);

        Stream.call(this);

        this.path = path;
        this.fd = null;
        this.writable = true;

        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438; /*=0666*/
        this.bytesWritten = 0;

        options = options || {};

        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }

        if (this.start !== undefined) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }

          this.pos = this.start;
        }

        this.busy = false;
        this._queue = [];

        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([
            this._open,
            this.path,
            this.flags,
            this.mode,
            undefined,
          ]);
          this.flush();
        }
      }
    }

    /***/
  },

  /***/ 263: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    var constants = __nccwpck_require__(2057);

    var origCwd = process.cwd;
    var cwd = null;

    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

    process.cwd = function () {
      if (!cwd) cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {}

    // This check is needed until node.js 12 is required
    if (typeof process.chdir === "function") {
      var chdir = process.chdir;
      process.chdir = function (d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }

    module.exports = patch;

    function patch(fs) {
      // (re-)implement some things that are known busted or missing.

      // lchmod, broken prior to 0.6.2
      // back-port the fix here.
      if (
        constants.hasOwnProperty("O_SYMLINK") &&
        process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)
      ) {
        patchLchmod(fs);
      }

      // lutimes implementation, or no-op
      if (!fs.lutimes) {
        patchLutimes(fs);
      }

      // https://github.com/isaacs/node-graceful-fs/issues/4
      // Chown should not fail on einval or eperm if non-root.
      // It should not fail on enosys ever, as this just indicates
      // that a fs doesn't support the intended operation.

      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);

      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);

      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);

      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);

      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);

      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);

      // if lchmod/lchown do not exist, then make them no-ops
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function (path, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function () {};
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function (path, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function () {};
      }

      // on Windows, A/V software can lock the directory, causing this
      // to fail with an EACCES or EPERM if the directory contains newly
      // created files.  Try again on failure, for up to 60 seconds.

      // Set the timeout this long because some Windows Anti-Virus, such as Parity
      // bit9, may lock files for up to a minute, causing npm package install
      // failures. Also, take care to yield the scheduler. Windows scheduling gives
      // CPU to a busy looping process, which can cause the program causing the lock
      // contention to be starved of CPU by node, so the contention doesn't resolve.
      if (platform === "win32") {
        fs.rename =
          typeof fs.rename !== "function"
            ? fs.rename
            : (function (fs$rename) {
                function rename(from, to, cb) {
                  var start = Date.now();
                  var backoff = 0;
                  fs$rename(from, to, function CB(er) {
                    if (
                      er &&
                      (er.code === "EACCES" ||
                        er.code === "EPERM" ||
                        er.code === "EBUSY") &&
                      Date.now() - start < 60000
                    ) {
                      setTimeout(function () {
                        fs.stat(to, function (stater, st) {
                          if (stater && stater.code === "ENOENT")
                            fs$rename(from, to, CB);
                          else cb(er);
                        });
                      }, backoff);
                      if (backoff < 100) backoff += 10;
                      return;
                    }
                    if (cb) cb(er);
                  });
                }
                if (Object.setPrototypeOf)
                  Object.setPrototypeOf(rename, fs$rename);
                return rename;
              })(fs.rename);
      }

      // if read() returns EAGAIN, then just try it again.
      fs.read =
        typeof fs.read !== "function"
          ? fs.read
          : (function (fs$read) {
              function read(fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === "function") {
                  var eagCounter = 0;
                  callback = function (er, _, __) {
                    if (er && er.code === "EAGAIN" && eagCounter < 10) {
                      eagCounter++;
                      return fs$read.call(
                        fs,
                        fd,
                        buffer,
                        offset,
                        length,
                        position,
                        callback
                      );
                    }
                    callback_.apply(this, arguments);
                  };
                }
                return fs$read.call(
                  fs,
                  fd,
                  buffer,
                  offset,
                  length,
                  position,
                  callback
                );
              }

              // This ensures `util.promisify` works as it does for native `fs.read`.
              if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
              return read;
            })(fs.read);

      fs.readSync =
        typeof fs.readSync !== "function"
          ? fs.readSync
          : (function (fs$readSync) {
              return function (fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while (true) {
                  try {
                    return fs$readSync.call(
                      fs,
                      fd,
                      buffer,
                      offset,
                      length,
                      position
                    );
                  } catch (er) {
                    if (er.code === "EAGAIN" && eagCounter < 10) {
                      eagCounter++;
                      continue;
                    }
                    throw er;
                  }
                }
              };
            })(fs.readSync);

      function patchLchmod(fs) {
        fs.lchmod = function (path, mode, callback) {
          fs.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function (err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              // prefer to return the chmod error, if one occurs,
              // but still try to close, and report closing errors if they occur.
              fs.fchmod(fd, mode, function (err) {
                fs.close(fd, function (err2) {
                  if (callback) callback(err || err2);
                });
              });
            }
          );
        };

        fs.lchmodSync = function (path, mode) {
          var fd = fs.openSync(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode
          );

          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          var threw = true;
          var ret;
          try {
            ret = fs.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs.closeSync(fd);
              } catch (er) {}
            } else {
              fs.closeSync(fd);
            }
          }
          return ret;
        };
      }

      function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
          fs.lutimes = function (path, at, mt, cb) {
            fs.open(path, constants.O_SYMLINK, function (er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs.futimes(fd, at, mt, function (er) {
                fs.close(fd, function (er2) {
                  if (cb) cb(er || er2);
                });
              });
            });
          };

          fs.lutimesSync = function (path, at, mt) {
            var fd = fs.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs.closeSync(fd);
                } catch (er) {}
              } else {
                fs.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs.futimes) {
          fs.lutimes = function (_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs.lutimesSync = function () {};
        }
      }

      function chmodFix(orig) {
        if (!orig) return orig;
        return function (target, mode, cb) {
          return orig.call(fs, target, mode, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }

      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function (target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }

      function chownFix(orig) {
        if (!orig) return orig;
        return function (target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }

      function chownFixSync(orig) {
        if (!orig) return orig;
        return function (target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }

      function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function (target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 0x100000000;
              if (stats.gid < 0) stats.gid += 0x100000000;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options
            ? orig.call(fs, target, options, callback)
            : orig.call(fs, target, callback);
        };
      }

      function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function (target, options) {
          var stats = options
            ? orig.call(fs, target, options)
            : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 0x100000000;
            if (stats.gid < 0) stats.gid += 0x100000000;
          }
          return stats;
        };
      }

      // ENOSYS means that the fs doesn't support the op. Just ignore
      // that, because it doesn't matter.
      //
      // if there's no getuid, or if getuid() is something other
      // than 0, and the error is EINVAL or EPERM, then just ignore
      // it.
      //
      // This specific case is a silent failure in cp, install, tar,
      // and most other unix tools that manage permissions.
      //
      // When running as root, or if other types of errors are
      // encountered, then it's strict.
      function chownErOk(er) {
        if (!er) return true;

        if (er.code === "ENOSYS") return true;

        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }

        return false;
      }
    }

    /***/
  },

  /***/ 1621: /***/ (module) => {
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return (
        position !== -1 &&
        (terminatorPosition === -1 || position < terminatorPosition)
      );
    };

    /***/
  },

  /***/ 6904: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const parse = __nccwpck_require__(7583);
    const stringify = __nccwpck_require__(749);

    const JSON5 = {
      parse,
      stringify,
    };

    module.exports = JSON5;

    /***/
  },

  /***/ 7583: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const util = __nccwpck_require__(7393);

    let source;
    let parseState;
    let stack;
    let pos;
    let line;
    let column;
    let token;
    let key;
    let root;

    module.exports = function parse(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = undefined;
      key = undefined;
      root = undefined;

      do {
        token = lex();

        // This code is unreachable.
        // if (!parseStates[parseState]) {
        //     throw invalidParseState()
        // }

        parseStates[parseState]();
      } while (token.type !== "eof");

      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }

      return root;
    };

    function internalize(holder, name, reviver) {
      const value = holder[name];
      if (value != null && typeof value === "object") {
        if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            const key = String(i);
            const replacement = internalize(value, key, reviver);
            if (replacement === undefined) {
              delete value[key];
            } else {
              Object.defineProperty(value, key, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true,
              });
            }
          }
        } else {
          for (const key in value) {
            const replacement = internalize(value, key, reviver);
            if (replacement === undefined) {
              delete value[key];
            } else {
              Object.defineProperty(value, key, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true,
              });
            }
          }
        }
      }

      return reviver.call(holder, name, value);
    }

    let lexState;
    let buffer;
    let doubleQuote;
    let sign;
    let c;

    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      sign = 1;

      for (;;) {
        c = peek();

        // This code is unreachable.
        // if (!lexStates[lexState]) {
        //     throw invalidLexState(lexState)
        // }

        const token = lexStates[lexState]();
        if (token) {
          return token;
        }
      }
    }

    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }

    function read() {
      const c = peek();

      if (c === "\n") {
        line++;
        column = 0;
      } else if (c) {
        column += c.length;
      } else {
        column++;
      }

      if (c) {
        pos += c.length;
      }

      return c;
    }

    const lexStates = {
      default() {
        switch (c) {
          case "\t":
          case "\v":
          case "\f":
          case " ":
          case "\u00A0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;

          case "/":
            read();
            lexState = "comment";
            return;

          case undefined:
            read();
            return newToken("eof");
        }

        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }

        // This code is unreachable.
        // if (!lexStates[parseState]) {
        //     throw invalidLexState(parseState)
        // }

        return lexStates[parseState]();
      },

      comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;

          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }

        throw invalidChar(read());
      },

      multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;

          case undefined:
            throw invalidChar(read());
        }

        read();
      },

      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;

          case "/":
            read();
            lexState = "default";
            return;

          case undefined:
            throw invalidChar(read());
        }

        read();
        lexState = "multiLineComment";
      },

      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;

          case undefined:
            read();
            return newToken("eof");
        }

        read();
      },

      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());

          case "n":
            read();
            literal("ull");
            return newToken("null", null);

          case "t":
            read();
            literal("rue");
            return newToken("boolean", true);

          case "f":
            read();
            literal("alse");
            return newToken("boolean", false);

          case "-":
          case "+":
            if (read() === "-") {
              sign = -1;
            }

            lexState = "sign";
            return;

          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;

          case "0":
            buffer = read();
            lexState = "zero";
            return;

          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;

          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", Infinity);

          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);

          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }

        throw invalidChar(read());
      },

      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }

        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;

          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }

            break;
        }

        buffer += u;
        lexState = "identifierName";
      },

      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;

          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }

        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }

        return newToken("identifier", buffer);
      },

      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }

        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;

          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }

            break;
        }

        buffer += u;
        lexState = "identifierName";
      },

      sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;

          case "0":
            buffer = read();
            lexState = "zero";
            return;

          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;

          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);

          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
        }

        throw invalidChar(read());
      },

      zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;

          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;

          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }

        return newToken("numeric", sign * 0);
      },

      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;

          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }

        if (util.isDigit(c)) {
          buffer += read();
          return;
        }

        return newToken("numeric", sign * Number(buffer));
      },

      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }

        throw invalidChar(read());
      },

      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }

        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }

        return newToken("numeric", sign * Number(buffer));
      },

      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }

        if (util.isDigit(c)) {
          buffer += read();
          return;
        }

        return newToken("numeric", sign * Number(buffer));
      },

      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }

        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }

        throw invalidChar(read());
      },

      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }

        throw invalidChar(read());
      },

      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }

        return newToken("numeric", sign * Number(buffer));
      },

      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }

        throw invalidChar(read());
      },

      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }

        return newToken("numeric", sign * Number(buffer));
      },

      string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape();
            return;

          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }

            buffer += read();
            return;

          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }

            buffer += read();
            return;

          case "\n":
          case "\r":
            throw invalidChar(read());

          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;

          case undefined:
            throw invalidChar(read());
        }

        buffer += read();
      },

      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());

          // This code is unreachable since the default lexState handles eof.
          // case undefined:
          //     return newToken('eof')
        }

        lexState = "value";
      },

      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;

          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;

          case "}":
            return newToken("punctuator", read());

          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }

        if (util.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }

        throw invalidChar(read());
      },

      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }

        throw invalidChar(read());
      },

      beforePropertyValue() {
        lexState = "value";
      },

      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }

        throw invalidChar(read());
      },

      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }

        lexState = "value";
      },

      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }

        throw invalidChar(read());
      },

      end() {
        // This code is unreachable since it's handled by the default lexState.
        // if (c === undefined) {
        //     read()
        //     return newToken('eof')
        // }

        throw invalidChar(read());
      },
    };

    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column,
      };
    }

    function literal(s) {
      for (const c of s) {
        const p = peek();

        if (p !== c) {
          throw invalidChar(read());
        }

        read();
      }
    }

    function escape() {
      const c = peek();
      switch (c) {
        case "b":
          read();
          return "\b";

        case "f":
          read();
          return "\f";

        case "n":
          read();
          return "\n";

        case "r":
          read();
          return "\r";

        case "t":
          read();
          return "\t";

        case "v":
          read();
          return "\v";

        case "0":
          read();
          if (util.isDigit(peek())) {
            throw invalidChar(read());
          }

          return "\0";

        case "x":
          read();
          return hexEscape();

        case "u":
          read();
          return unicodeEscape();

        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";

        case "\r":
          read();
          if (peek() === "\n") {
            read();
          }

          return "";

        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());

        case undefined:
          throw invalidChar(read());
      }

      return read();
    }

    function hexEscape() {
      let buffer = "";
      let c = peek();

      if (!util.isHexDigit(c)) {
        throw invalidChar(read());
      }

      buffer += read();

      c = peek();
      if (!util.isHexDigit(c)) {
        throw invalidChar(read());
      }

      buffer += read();

      return String.fromCodePoint(parseInt(buffer, 16));
    }

    function unicodeEscape() {
      let buffer = "";
      let count = 4;

      while (count-- > 0) {
        const c = peek();
        if (!util.isHexDigit(c)) {
          throw invalidChar(read());
        }

        buffer += read();
      }

      return String.fromCodePoint(parseInt(buffer, 16));
    }

    const parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }

        push();
      },

      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;

          case "punctuator":
            // This code is unreachable since it's handled by the lexState.
            // if (token.value !== '}') {
            //     throw invalidToken()
            // }

            pop();
            return;

          case "eof":
            throw invalidEOF();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
      },

      afterPropertyName() {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator' || token.value !== ':') {
        //     throw invalidToken()
        // }

        if (token.type === "eof") {
          throw invalidEOF();
        }

        parseState = "beforePropertyValue";
      },

      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }

        push();
      },

      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }

        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }

        push();
      },

      afterPropertyValue() {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }

        if (token.type === "eof") {
          throw invalidEOF();
        }

        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;

          case "}":
            pop();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
      },

      afterArrayValue() {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }

        if (token.type === "eof") {
          throw invalidEOF();
        }

        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;

          case "]":
            pop();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
      },

      end() {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'eof') {
        //     throw invalidToken()
        // }
      },
    };

    function push() {
      let value;

      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;

            case "[":
              value = [];
              break;
          }

          break;

        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;

        // This code is unreachable.
        // default:
        //     throw invalidToken()
      }

      if (root === undefined) {
        root = value;
      } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          Object.defineProperty(parent, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true,
          });
        }
      }

      if (value !== null && typeof value === "object") {
        stack.push(value);

        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        const current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }

    function pop() {
      stack.pop();

      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }

    // This code is unreachable.
    // function invalidParseState () {
    //     return new Error(`JSON5: invalid parse state '${parseState}'`)
    // }

    // This code is unreachable.
    // function invalidLexState (state) {
    //     return new Error(`JSON5: invalid lex state '${state}'`)
    // }

    function invalidChar(c) {
      if (c === undefined) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
      }

      return syntaxError(
        `JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`
      );
    }

    function invalidEOF() {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }

    // This code is unreachable.
    // function invalidToken () {
    //     if (token.type === 'eof') {
    //         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
    //     }

    //     const c = String.fromCodePoint(token.value.codePointAt(0))
    //     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
    // }

    function invalidIdentifier() {
      column -= 5;
      return syntaxError(
        `JSON5: invalid identifier character at ${line}:${column}`
      );
    }

    function separatorChar(c) {
      console.warn(
        `JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`
      );
    }

    function formatChar(c) {
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "\t": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029",
      };

      if (replacements[c]) {
        return replacements[c];
      }

      if (c < " ") {
        const hexString = c.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }

      return c;
    }

    function syntaxError(message) {
      const err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }

    /***/
  },

  /***/ 749: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const util = __nccwpck_require__(7393);

    module.exports = function stringify(value, replacer, space) {
      const stack = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote;

      if (
        replacer != null &&
        typeof replacer === "object" &&
        !Array.isArray(replacer)
      ) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }

      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
          let item;

          if (typeof v === "string") {
            item = v;
          } else if (
            typeof v === "number" ||
            v instanceof String ||
            v instanceof Number
          ) {
            item = String(v);
          }

          if (item !== undefined && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }

      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }

      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }

      return serializeProperty("", { "": value });

      function serializeProperty(key, holder) {
        let value = holder[key];
        if (value != null) {
          if (typeof value.toJSON5 === "function") {
            value = value.toJSON5(key);
          } else if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
          }
        }

        if (replacerFunc) {
          value = replacerFunc.call(holder, key, value);
        }

        if (value instanceof Number) {
          value = Number(value);
        } else if (value instanceof String) {
          value = String(value);
        } else if (value instanceof Boolean) {
          value = value.valueOf();
        }

        switch (value) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }

        if (typeof value === "string") {
          return quoteString(value, false);
        }

        if (typeof value === "number") {
          return String(value);
        }

        if (typeof value === "object") {
          return Array.isArray(value)
            ? serializeArray(value)
            : serializeObject(value);
        }

        return undefined;
      }

      function quoteString(value) {
        const quotes = {
          "'": 0.1,
          '"': 0.2,
        };

        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "\t": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029",
        };

        let product = "";

        for (let i = 0; i < value.length; i++) {
          const c = value[i];
          switch (c) {
            case "'":
            case '"':
              quotes[c]++;
              product += c;
              continue;

            case "\0":
              if (util.isDigit(value[i + 1])) {
                product += "\\x00";
                continue;
              }
          }

          if (replacements[c]) {
            product += replacements[c];
            continue;
          }

          if (c < " ") {
            let hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }

          product += c;
        }

        const quoteChar =
          quote ||
          Object.keys(quotes).reduce((a, b) => (quotes[a] < quotes[b] ? a : b));

        product = product.replace(
          new RegExp(quoteChar, "g"),
          replacements[quoteChar]
        );

        return quoteChar + product + quoteChar;
      }

      function serializeObject(value) {
        if (stack.indexOf(value) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }

        stack.push(value);

        let stepback = indent;
        indent = indent + gap;

        let keys = propertyList || Object.keys(value);
        let partial = [];
        for (const key of keys) {
          const propertyString = serializeProperty(key, value);
          if (propertyString !== undefined) {
            let member = serializeKey(key) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial.push(member);
          }
        }

        let final;
        if (partial.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }

        stack.pop();
        indent = stepback;
        return final;
      }

      function serializeKey(key) {
        if (key.length === 0) {
          return quoteString(key, true);
        }

        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key, true);
        }

        for (let i = firstChar.length; i < key.length; i++) {
          if (
            !util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))
          ) {
            return quoteString(key, true);
          }
        }

        return key;
      }

      function serializeArray(value) {
        if (stack.indexOf(value) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }

        stack.push(value);

        let stepback = indent;
        indent = indent + gap;

        let partial = [];
        for (let i = 0; i < value.length; i++) {
          const propertyString = serializeProperty(String(i), value);
          partial.push(propertyString !== undefined ? propertyString : "null");
        }

        let final;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }

        stack.pop();
        indent = stepback;
        return final;
      }
    };

    /***/
  },

  /***/ 1927: /***/ (module) => {
    // This is a generated file. Do not edit.
    module.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module.exports.ID_Start =
      /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module.exports.ID_Continue =
      /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

    /***/
  },

  /***/ 7393: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const unicode = __nccwpck_require__(1927);

    module.exports = {
      isSpaceSeparator(c) {
        return typeof c === "string" && unicode.Space_Separator.test(c);
      },

      isIdStartChar(c) {
        return (
          typeof c === "string" &&
          ((c >= "a" && c <= "z") ||
            (c >= "A" && c <= "Z") ||
            c === "$" ||
            c === "_" ||
            unicode.ID_Start.test(c))
        );
      },

      isIdContinueChar(c) {
        return (
          typeof c === "string" &&
          ((c >= "a" && c <= "z") ||
            (c >= "A" && c <= "Z") ||
            (c >= "0" && c <= "9") ||
            c === "$" ||
            c === "_" ||
            c === "\u200C" ||
            c === "\u200D" ||
            unicode.ID_Continue.test(c))
        );
      },

      isDigit(c) {
        return typeof c === "string" && /[0-9]/.test(c);
      },

      isHexDigit(c) {
        return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
      },
    };

    /***/
  },

  /***/ 6160: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    let _fs;
    try {
      _fs = __nccwpck_require__(7758);
    } catch (_) {
      _fs = __nccwpck_require__(7147);
    }
    const universalify = __nccwpck_require__(9046);
    const { stringify, stripBom } = __nccwpck_require__(5902);

    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }

      const fs = options.fs || _fs;

      const shouldThrow = "throws" in options ? options.throws : true;

      let data = await universalify.fromCallback(fs.readFile)(file, options);

      data = stripBom(data);

      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }

      return obj;
    }

    const readFile = universalify.fromPromise(_readFile);

    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }

      const fs = options.fs || _fs;

      const shouldThrow = "throws" in options ? options.throws : true;

      try {
        let content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }

    async function _writeFile(file, obj, options = {}) {
      const fs = options.fs || _fs;

      const str = stringify(obj, options);

      await universalify.fromCallback(fs.writeFile)(file, str, options);
    }

    const writeFile = universalify.fromPromise(_writeFile);

    function writeFileSync(file, obj, options = {}) {
      const fs = options.fs || _fs;

      const str = stringify(obj, options);
      // not sure if fs.writeFileSync returns anything, but just in case
      return fs.writeFileSync(file, str, options);
    }

    const jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync,
    };

    module.exports = jsonfile;

    /***/
  },

  /***/ 5902: /***/ (module) => {
    function stringify(
      obj,
      { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}
    ) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);

      return str.replace(/\n/g, EOL) + EOF;
    }

    function stripBom(content) {
      // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }

    module.exports = { stringify, stripBom };

    /***/
  },

  /***/ 900: /***/ (module) => {
    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    module.exports = function (val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }

    /***/
  },

  /***/ 7760: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = __nccwpck_require__(1267),
          port = new MessageChannel().port1,
          ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" &&
          (globalThis.DOMException = err.constructor);
      }
    }

    module.exports = globalThis.DOMException;

    /***/
  },

  /***/ 1933: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    /**
     * Parser functions.
     */

    var parserFunctions = __nccwpck_require__(8068);
    Object.keys(parserFunctions).forEach(function (k) {
      exports[k] = parserFunctions[k];
    });

    /**
     * Builder functions.
     */

    var builderFunctions = __nccwpck_require__(9979);
    Object.keys(builderFunctions).forEach(function (k) {
      exports[k] = builderFunctions[k];
    });

    /***/
  },

  /***/ 9979: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    /**
     * Module dependencies.
     */

    var base64 = __nccwpck_require__(6463);
    var xmlbuilder = __nccwpck_require__(2958);

    /**
     * Module exports.
     */

    exports.build = build;

    /**
     * Accepts a `Date` instance and returns an ISO date string.
     *
     * @param {Date} d - Date instance to serialize
     * @returns {String} ISO date string representation of `d`
     * @api private
     */

    function ISODateString(d) {
      function pad(n) {
        return n < 10 ? "0" + n : n;
      }
      return (
        d.getUTCFullYear() +
        "-" +
        pad(d.getUTCMonth() + 1) +
        "-" +
        pad(d.getUTCDate()) +
        "T" +
        pad(d.getUTCHours()) +
        ":" +
        pad(d.getUTCMinutes()) +
        ":" +
        pad(d.getUTCSeconds()) +
        "Z"
      );
    }

    /**
     * Returns the internal "type" of `obj` via the
     * `Object.prototype.toString()` trick.
     *
     * @param {Mixed} obj - any value
     * @returns {String} the internal "type" name
     * @api private
     */

    var toString = Object.prototype.toString;
    function type(obj) {
      var m = toString.call(obj).match(/\[object (.*)\]/);
      return m ? m[1] : m;
    }

    /**
     * Generate an XML plist string from the input object `obj`.
     *
     * @param {Object} obj - the object to convert
     * @param {Object} [opts] - optional options object
     * @returns {String} converted plist XML string
     * @api public
     */

    function build(obj, opts) {
      var XMLHDR = {
        version: "1.0",
        encoding: "UTF-8",
      };

      var XMLDTD = {
        pubid: "-//Apple//DTD PLIST 1.0//EN",
        sysid: "http://www.apple.com/DTDs/PropertyList-1.0.dtd",
      };

      var doc = xmlbuilder.create("plist");

      doc.dec(XMLHDR.version, XMLHDR.encoding, XMLHDR.standalone);
      doc.dtd(XMLDTD.pubid, XMLDTD.sysid);
      doc.att("version", "1.0");

      walk_obj(obj, doc);

      if (!opts) opts = {};
      // default `pretty` to `true`
      opts.pretty = opts.pretty !== false;
      return doc.end(opts);
    }

    /**
     * depth first, recursive traversal of a javascript object. when complete,
     * next_child contains a reference to the build XML object.
     *
     * @api private
     */

    function walk_obj(next, next_child) {
      var tag_type, i, prop;
      var name = type(next);

      if ("Undefined" == name) {
        return;
      } else if (Array.isArray(next)) {
        next_child = next_child.ele("array");
        for (i = 0; i < next.length; i++) {
          walk_obj(next[i], next_child);
        }
      } else if (Buffer.isBuffer(next)) {
        next_child.ele("data").raw(next.toString("base64"));
      } else if ("Object" == name) {
        next_child = next_child.ele("dict");
        for (prop in next) {
          if (next.hasOwnProperty(prop)) {
            next_child.ele("key").txt(prop);
            walk_obj(next[prop], next_child);
          }
        }
      } else if ("Number" == name) {
        // detect if this is an integer or real
        // TODO: add an ability to force one way or another via a "cast"
        tag_type = next % 1 === 0 ? "integer" : "real";
        next_child.ele(tag_type).txt(next.toString());
      } else if ("BigInt" == name) {
        next_child.ele("integer").txt(next);
      } else if ("Date" == name) {
        next_child.ele("date").txt(ISODateString(new Date(next)));
      } else if ("Boolean" == name) {
        next_child.ele(next ? "true" : "false");
      } else if ("String" == name) {
        next_child.ele("string").txt(next);
      } else if ("ArrayBuffer" == name) {
        next_child.ele("data").raw(base64.fromByteArray(next));
      } else if (next && next.buffer && "ArrayBuffer" == type(next.buffer)) {
        // a typed array
        next_child
          .ele("data")
          .raw(base64.fromByteArray(new Uint8Array(next.buffer), next_child));
      } else if ("Null" === name) {
        next_child.ele("null").txt("");
      }
    }

    /***/
  },

  /***/ 8068: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    /**
     * Module dependencies.
     */

    const { DOMParser } = __nccwpck_require__(9213);

    /**
     * Module exports.
     */

    exports.parse = parse;

    var TEXT_NODE = 3;
    var CDATA_NODE = 4;
    var COMMENT_NODE = 8;

    /**
     * We ignore raw text (usually whitespace), <!-- xml comments -->,
     * and raw CDATA nodes.
     *
     * @param {Element} node
     * @returns {Boolean}
     * @api private
     */

    function shouldIgnoreNode(node) {
      return (
        node.nodeType === TEXT_NODE ||
        node.nodeType === COMMENT_NODE ||
        node.nodeType === CDATA_NODE
      );
    }

    /**
     * Check if the node is empty. Some plist file has such node:
     * <key />
     * this node shoud be ignored.
     *
     * @see https://github.com/TooTallNate/plist.js/issues/66
     * @param {Element} node
     * @returns {Boolean}
     * @api private
     */
    function isEmptyNode(node) {
      if (!node.childNodes || node.childNodes.length === 0) {
        return true;
      } else {
        return false;
      }
    }

    function invariant(test, message) {
      if (!test) {
        throw new Error(message);
      }
    }

    /**
     * Parses a Plist XML string. Returns an Object.
     *
     * @param {String} xml - the XML String to decode
     * @returns {Mixed} the decoded value from the Plist XML
     * @api public
     */

    function parse(xml) {
      var doc = new DOMParser().parseFromString(xml);
      invariant(
        doc.documentElement.nodeName === "plist",
        "malformed document. First element should be <plist>"
      );
      var plist = parsePlistXML(doc.documentElement);

      // the root <plist> node gets interpreted as an Array,
      // so pull out the inner data first
      if (plist.length == 1) plist = plist[0];

      return plist;
    }

    /**
     * Convert an XML based plist document into a JSON representation.
     *
     * @param {Object} xml_node - current XML node in the plist
     * @returns {Mixed} built up JSON object
     * @api private
     */

    function parsePlistXML(node) {
      var i, new_obj, key, val, new_arr, res, counter, type;

      if (!node) return null;

      if (node.nodeName === "plist") {
        new_arr = [];
        if (isEmptyNode(node)) {
          return new_arr;
        }
        for (i = 0; i < node.childNodes.length; i++) {
          if (!shouldIgnoreNode(node.childNodes[i])) {
            new_arr.push(parsePlistXML(node.childNodes[i]));
          }
        }
        return new_arr;
      } else if (node.nodeName === "dict") {
        new_obj = {};
        key = null;
        counter = 0;
        if (isEmptyNode(node)) {
          return new_obj;
        }
        for (i = 0; i < node.childNodes.length; i++) {
          if (shouldIgnoreNode(node.childNodes[i])) continue;
          if (counter % 2 === 0) {
            invariant(
              node.childNodes[i].nodeName === "key",
              "Missing key while parsing <dict/>."
            );
            key = parsePlistXML(node.childNodes[i]);
          } else {
            invariant(
              node.childNodes[i].nodeName !== "key",
              'Unexpected key "' +
                parsePlistXML(node.childNodes[i]) +
                '" while parsing <dict/>.'
            );
            new_obj[key] = parsePlistXML(node.childNodes[i]);
          }
          counter += 1;
        }
        if (counter % 2 === 1) {
          new_obj[key] = "";
        }

        return new_obj;
      } else if (node.nodeName === "array") {
        new_arr = [];
        if (isEmptyNode(node)) {
          return new_arr;
        }
        for (i = 0; i < node.childNodes.length; i++) {
          if (!shouldIgnoreNode(node.childNodes[i])) {
            res = parsePlistXML(node.childNodes[i]);
            if (null != res) new_arr.push(res);
          }
        }
        return new_arr;
      } else if (node.nodeName === "#text") {
        // TODO: what should we do with text types? (CDATA sections)
      } else if (node.nodeName === "key") {
        if (isEmptyNode(node)) {
          return "";
        }

        invariant(
          node.childNodes[0].nodeValue !== "__proto__",
          "__proto__ keys can lead to prototype pollution. More details on CVE-2022-22912"
        );

        return node.childNodes[0].nodeValue;
      } else if (node.nodeName === "string") {
        res = "";
        if (isEmptyNode(node)) {
          return res;
        }
        for (i = 0; i < node.childNodes.length; i++) {
          var type = node.childNodes[i].nodeType;
          if (type === TEXT_NODE || type === CDATA_NODE) {
            res += node.childNodes[i].nodeValue;
          }
        }
        return res;
      } else if (node.nodeName === "integer") {
        invariant(!isEmptyNode(node), 'Cannot parse "" as integer.');
        return parseInt(node.childNodes[0].nodeValue, 10);
      } else if (node.nodeName === "real") {
        invariant(!isEmptyNode(node), 'Cannot parse "" as real.');
        res = "";
        for (i = 0; i < node.childNodes.length; i++) {
          if (node.childNodes[i].nodeType === TEXT_NODE) {
            res += node.childNodes[i].nodeValue;
          }
        }
        return parseFloat(res);
      } else if (node.nodeName === "data") {
        res = "";
        if (isEmptyNode(node)) {
          return Buffer.from(res, "base64");
        }
        for (i = 0; i < node.childNodes.length; i++) {
          if (node.childNodes[i].nodeType === TEXT_NODE) {
            res += node.childNodes[i].nodeValue.replace(/\s+/g, "");
          }
        }
        return Buffer.from(res, "base64");
      } else if (node.nodeName === "date") {
        invariant(!isEmptyNode(node), 'Cannot parse "" as Date.');
        return new Date(node.childNodes[0].nodeValue);
      } else if (node.nodeName === "null") {
        return null;
      } else if (node.nodeName === "true") {
        return true;
      } else if (node.nodeName === "false") {
        return false;
      } else {
        throw new Error("Invalid PLIST tag " + node.nodeName);
      }
    }

    /***/
  },

  /***/ 4526: /***/ (module) => {
    const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    const numRegex =
      /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    // const octRegex = /0x[a-z0-9]+/;
    // const binRegex = /0x[a-z0-9]+/;

    //polyfill
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }

    const consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true,
      //skipLike: /regex/
    };

    function toNumber(str, options = {}) {
      // const options = Object.assign({}, consider);
      // if(opt.leadingZeros === false){
      //     options.leadingZeros = false;
      // }else if(opt.hex === false){
      //     options.hex = false;
      // }

      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string") return str;

      let trimmedStr = str.trim();
      // if(trimmedStr === "0.0") return 0;
      // else if(trimmedStr === "+0.0") return 0;
      // else if(trimmedStr === "-0.0") return -0;

      if (options.skipLike !== undefined && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
        // } else if (options.parseOct && octRegex.test(str)) {
        //     return Number.parseInt(val, 8);
        // }else if (options.parseBin && binRegex.test(str)) {
        //     return Number.parseInt(val, 2);
      } else {
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
          //trim ending zeros for floating number

          const eNotation = match[4] || match[6];
          if (
            !options.leadingZeros &&
            leadingZeros.length > 0 &&
            sign &&
            trimmedStr[2] !== "."
          )
            return str; //-0123
          else if (
            !options.leadingZeros &&
            leadingZeros.length > 0 &&
            !sign &&
            trimmedStr[1] !== "."
          )
            return str; //0123
          else {
            //no leading zeros or leading zeros are allowed
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              //given number is long and parsed to eNotation
              if (options.eNotation) return num;
              else return str;
            } else if (eNotation) {
              //given number has enotation
              if (options.eNotation) return num;
              else return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              //floating number
              // const decimalPart = match[5].substr(1);
              // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

              // const p = numStr.indexOf(".");
              // const givenIntPart = numStr.substr(0,p);
              // const givenDecPart = numStr.substr(p+1);
              if (numStr === "0" && numTrimmedByZeros === "")
                return num; //0.0
              else if (numStr === numTrimmedByZeros)
                return num; //0.456. 0.79000
              else if (sign && numStr === "-" + numTrimmedByZeros) return num;
              else return str;
            }

            if (leadingZeros) {
              // if(numTrimmedByZeros === numStr){
              //     if(options.leadingZeros) return num;
              //     else return str;
              // }else return str;
              if (numTrimmedByZeros === numStr) return num;
              else if (sign + numTrimmedByZeros === numStr) return num;
              else return str;
            }

            if (trimmedStr === numStr) return num;
            else if (trimmedStr === sign + numStr) return num;
            // else{
            //     //number with +/- sign
            //     trimmedStr.test(/[-+][0-9]);

            // }
            return str;
          }
          // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
        } else {
          //non-numeric string
          return str;
        }
      }
    }

    /**
     *
     * @param {string} numStr without leading zeros
     * @returns
     */
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        //float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if (numStr === ".") numStr = "0";
        else if (numStr[0] === ".") numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber;

    /***/
  },

  /***/ 9318: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const os = __nccwpck_require__(2037);
    const tty = __nccwpck_require__(6224);
    const hasFlag = __nccwpck_require__(1621);

    const { env } = process;

    let forceColor;
    if (
      hasFlag("no-color") ||
      hasFlag("no-colors") ||
      hasFlag("color=false") ||
      hasFlag("color=never")
    ) {
      forceColor = 0;
    } else if (
      hasFlag("color") ||
      hasFlag("colors") ||
      hasFlag("color=true") ||
      hasFlag("color=always")
    ) {
      forceColor = 1;
    }

    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor =
          env.FORCE_COLOR.length === 0
            ? 1
            : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }

    function translateLevel(level) {
      if (level === 0) {
        return false;
      }

      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3,
      };
    }

    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }

      if (
        hasFlag("color=16m") ||
        hasFlag("color=full") ||
        hasFlag("color=truecolor")
      ) {
        return 3;
      }

      if (hasFlag("color=256")) {
        return 2;
      }

      if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
      }

      const min = forceColor || 0;

      if (env.TERM === "dumb") {
        return min;
      }

      if (process.platform === "win32") {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }

        return 1;
      }

      if ("CI" in env) {
        if (
          [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "GITHUB_ACTIONS",
            "BUILDKITE",
          ].some((sign) => sign in env) ||
          env.CI_NAME === "codeship"
        ) {
          return 1;
        }

        return min;
      }

      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)
          ? 1
          : 0;
      }

      if (env.COLORTERM === "truecolor") {
        return 3;
      }

      if ("TERM_PROGRAM" in env) {
        const version = parseInt(
          (env.TERM_PROGRAM_VERSION || "").split(".")[0],
          10
        );

        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
          // No default
        }
      }

      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }

      if (
        /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
          env.TERM
        )
      ) {
        return 1;
      }

      if ("COLORTERM" in env) {
        return 1;
      }

      return min;
    }

    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }

    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2))),
    };

    /***/
  },

  /***/ 4351: /***/ (module) => {
    /******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    /* global global, define, Symbol, Reflect, Promise, SuppressedError */
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    var __addDisposableResource;
    var __disposeResources;
    (function (factory) {
      var root =
        typeof global === "object"
          ? global
          : typeof self === "object"
            ? self
            : typeof this === "object"
              ? this
              : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) {
          factory(createExporter(root, createExporter(exports)));
        });
      } else if (true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports, previous) {
        if (exports !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports, "__esModule", { value: true });
          } else {
            exports.__esModule = true;
          }
        }
        return function (id, v) {
          return (exports[id] = previous ? previous(id, v) : v);
        };
      }
    })(function (exporter) {
      var extendStatics =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (d, b) {
            d.__proto__ = b;
          }) ||
        function (d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };

      __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError(
            "Class extends value " + String(b) + " is not a constructor or null"
          );
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype =
          b === null
            ? Object.create(b)
            : ((__.prototype = b.prototype), new __());
      };

      __assign =
        Object.assign ||
        function (t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };

      __rest = function (s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (
            var i = 0, p = Object.getOwnPropertySymbols(s);
            i < p.length;
            i++
          ) {
            if (
              e.indexOf(p[i]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(s, p[i])
            )
              t[p[i]] = s[p[i]];
          }
        return t;
      };

      __decorate = function (decorators, target, key, desc) {
        var c = arguments.length,
          r =
            c < 3
              ? target
              : desc === null
                ? (desc = Object.getOwnPropertyDescriptor(target, key))
                : desc,
          d;
        if (
          typeof Reflect === "object" &&
          typeof Reflect.decorate === "function"
        )
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if ((d = decorators[i]))
              r =
                (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) ||
                r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };

      __param = function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };

      __esDecorate = function (
        ctor,
        descriptorIn,
        decorators,
        contextIn,
        initializers,
        extraInitializers
      ) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function")
            throw new TypeError("Function expected");
          return f;
        }
        var kind = contextIn.kind,
          key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target =
          !descriptorIn && ctor
            ? contextIn["static"]
              ? ctor
              : ctor.prototype
            : null;
        var descriptor =
          descriptorIn ||
          (target
            ? Object.getOwnPropertyDescriptor(target, contextIn.name)
            : {});
        var _,
          done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
          var context = {};
          for (var p in contextIn)
            context[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access)
            context.access[p] = contextIn.access[p];
          context.addInitializer = function (f) {
            if (done)
              throw new TypeError(
                "Cannot add initializers after decoration has completed"
              );
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i])(
            kind === "accessor"
              ? { get: descriptor.get, set: descriptor.set }
              : descriptor[key],
            context
          );
          if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if ((_ = accept(result.get))) descriptor.get = _;
            if ((_ = accept(result.set))) descriptor.set = _;
            if ((_ = accept(result.init))) initializers.unshift(_);
          } else if ((_ = accept(result))) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
          }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };

      __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
          value = useValue
            ? initializers[i].call(thisArg, value)
            : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
      };

      __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
      };

      __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", {
          configurable: true,
          value: prefix ? "".concat(prefix, " ", name) : name,
        });
      };

      __metadata = function (metadataKey, metadataValue) {
        if (
          typeof Reflect === "object" &&
          typeof Reflect.metadata === "function"
        )
          return Reflect.metadata(metadataKey, metadataValue);
      };

      __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };

      __generator = function (thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: [],
          },
          f,
          y,
          t,
          g;
        return (
          (g = { next: verb(0), throw: verb(1), return: verb(2) }),
          typeof Symbol === "function" &&
            (g[Symbol.iterator] = function () {
              return this;
            }),
          g
        );
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while ((g && ((g = 0), op[0] && (_ = 0)), _))
            try {
              if (
                ((f = 1),
                y &&
                  (t =
                    op[0] & 2
                      ? y["return"]
                      : op[0]
                        ? y["throw"] || ((t = y["return"]) && t.call(y), 0)
                        : y.next) &&
                  !(t = t.call(y, op[1])).done)
              )
                return t;
              if (((y = 0), t)) op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (
                    !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
                    (op[0] === 6 || op[0] === 2)
                  ) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };

      __exportStar = function (m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };

      __createBinding = Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          };

      __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
            },
          };
        throw new TypeError(
          s ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      };

      __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error: error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      };

      /** @deprecated */
      __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };

      /** @deprecated */
      __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };

      __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };

      __await = function (v) {
        return this instanceof __await ? ((this.v = v), this) : new __await(v);
      };

      __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return (
          (i = {}),
          verb("next"),
          verb("throw"),
          verb("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function verb(n) {
          if (g[n])
            i[n] = function (v) {
              return new Promise(function (a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await
            ? Promise.resolve(r.value.v).then(fulfill, reject)
            : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
        }
      };

      __asyncDelegator = function (o) {
        var i, p;
        return (
          (i = {}),
          verb("next"),
          verb("throw", function (e) {
            throw e;
          }),
          verb("return"),
          (i[Symbol.iterator] = function () {
            return this;
          }),
          i
        );
        function verb(n, f) {
          i[n] = o[n]
            ? function (v) {
                return (p = !p)
                  ? { value: __await(o[n](v)), done: false }
                  : f
                    ? f(v)
                    : v;
              }
            : f;
        }
      };

      __asyncValues = function (o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m
          ? m.call(o)
          : ((o =
              typeof __values === "function"
                ? __values(o)
                : o[Symbol.iterator]()),
            (i = {}),
            verb("next"),
            verb("throw"),
            verb("return"),
            (i[Symbol.asyncIterator] = function () {
              return this;
            }),
            i);
        function verb(n) {
          i[n] =
            o[n] &&
            function (v) {
              return new Promise(function (resolve, reject) {
                (v = o[n](v)), settle(resolve, reject, v.done, v.value);
              });
            };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({ value: v, done: d });
          }, reject);
        }
      };

      __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };

      var __setModuleDefault = Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          };

      __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null)
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };

      __importDefault = function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };

      __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (
          typeof state === "function"
            ? receiver !== state || !f
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        return kind === "m"
          ? f
          : kind === "a"
            ? f.call(receiver)
            : f
              ? f.value
              : state.get(receiver);
      };

      __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (
          typeof state === "function"
            ? receiver !== state || !f
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        return (
          kind === "a"
            ? f.call(receiver, value)
            : f
              ? (f.value = value)
              : state.set(receiver, value),
          value
        );
      };

      __classPrivateFieldIn = function (state, receiver) {
        if (
          receiver === null ||
          (typeof receiver !== "object" && typeof receiver !== "function")
        )
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function"
          ? receiver === state
          : state.has(receiver);
      };

      __addDisposableResource = function (env, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env.stack.push({ value: value, dispose: dispose, async: async });
        } else if (async) {
          env.stack.push({ async: true });
        }
        return value;
      };

      var _SuppressedError =
        typeof SuppressedError === "function"
          ? SuppressedError
          : function (error, suppressed, message) {
              var e = new Error(message);
              return (
                (e.name = "SuppressedError"),
                (e.error = error),
                (e.suppressed = suppressed),
                e
              );
            };

      __disposeResources = function (env) {
        function fail(e) {
          env.error = env.hasError
            ? new _SuppressedError(
                e,
                env.error,
                "An error was suppressed during disposal."
              )
            : e;
          env.hasError = true;
        }
        function next() {
          while (env.stack.length) {
            var rec = env.stack.pop();
            try {
              var result = rec.dispose && rec.dispose.call(rec.value);
              if (rec.async)
                return Promise.resolve(result).then(next, function (e) {
                  fail(e);
                  return next();
                });
            } catch (e) {
              fail(e);
            }
          }
          if (env.hasError) throw env.error;
        }
        return next();
      };

      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
      exporter("__addDisposableResource", __addDisposableResource);
      exporter("__disposeResources", __disposeResources);
    });

    /***/
  },

  /***/ 4294: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = __nccwpck_require__(4219);

    /***/
  },

  /***/ 4219: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var net = __nccwpck_require__(1808);
    var tls = __nccwpck_require__(4404);
    var http = __nccwpck_require__(3685);
    var https = __nccwpck_require__(5687);
    var events = __nccwpck_require__(2361);
    var assert = __nccwpck_require__(9491);
    var util = __nccwpck_require__(3837);

    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;

    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }

    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }

    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }

    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }

    function TunnelingAgent(options) {
      var self = this;
      self.options = options || {};
      self.proxyOptions = self.options.proxy || {};
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
      self.requests = [];
      self.sockets = [];

      self.on("free", function onFree(socket, host, port, localAddress) {
        var options = toOptions(host, port, localAddress);
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i];
          if (pending.host === options.host && pending.port === options.port) {
            // Detect the request to connect same origin server,
            // reuse the connection.
            self.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);

    TunnelingAgent.prototype.addRequest = function addRequest(
      req,
      host,
      port,
      localAddress
    ) {
      var self = this;
      var options = mergeOptions(
        { request: req },
        self.options,
        toOptions(host, port, localAddress)
      );

      if (self.sockets.length >= this.maxSockets) {
        // We are over limit so we'll add it to the queue.
        self.requests.push(options);
        return;
      }

      // If we are under maxSockets create a new one.
      self.createSocket(options, function (socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);

        function onFree() {
          self.emit("free", socket, options);
        }

        function onCloseOrRemove(err) {
          self.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };

    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this;
      var placeholder = {};
      self.sockets.push(placeholder);

      var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port,
        },
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] =
          "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }

      debug("making CONNECT request");
      var connectReq = self.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false; // for v0.6
      connectReq.once("response", onResponse); // for v0.6
      connectReq.once("upgrade", onUpgrade); // for v0.6
      connectReq.once("connect", onConnect); // for v0.7 or later
      connectReq.once("error", onError);
      connectReq.end();

      function onResponse(res) {
        // Very hacky. This is necessary to avoid http-parser leaks.
        res.upgrade = true;
      }

      function onUpgrade(res, socket, head) {
        // Hacky.
        process.nextTick(function () {
          onConnect(res, socket, head);
        });
      }

      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();

        if (res.statusCode !== 200) {
          debug(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error(
            "tunneling socket could not be established, " +
              "statusCode=" +
              res.statusCode
          );
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
          return;
        }
        debug("tunneling connection has established");
        self.sockets[self.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }

      function onError(cause) {
        connectReq.removeAllListeners();

        debug(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error(
          "tunneling socket could not be established, " +
            "cause=" +
            cause.message
        );
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self.removeSocket(placeholder);
      }
    };

    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);

      var pending = this.requests.shift();
      if (pending) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createSocket(pending, function (socket) {
          pending.request.onSocket(socket);
        });
      }
    };

    function createSecureSocket(options, cb) {
      var self = this;
      TunnelingAgent.prototype.createSocket.call(
        self,
        options,
        function (socket) {
          var hostHeader = options.request.getHeader("host");
          var tlsOptions = mergeOptions({}, self.options, {
            socket: socket,
            servername: hostHeader
              ? hostHeader.replace(/:.*$/, "")
              : options.host,
          });

          // 0 is dummy port for v0.6
          var secureSocket = tls.connect(0, tlsOptions);
          self.sockets[self.sockets.indexOf(socket)] = secureSocket;
          cb(secureSocket);
        }
      );
    }

    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        // since v0.10
        return {
          host: host,
          port: port,
          localAddress: localAddress,
        };
      }
      return host; // for v0.11 or later
    }

    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== undefined) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }

    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function () {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function () {};
    }
    exports.debug = debug; // for test

    /***/
  },

  /***/ 1773: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const Client = __nccwpck_require__(3598);
    const Dispatcher = __nccwpck_require__(412);
    const errors = __nccwpck_require__(8045);
    const Pool = __nccwpck_require__(4634);
    const BalancedPool = __nccwpck_require__(7931);
    const Agent = __nccwpck_require__(7890);
    const util = __nccwpck_require__(3983);
    const { InvalidArgumentError } = errors;
    const api = __nccwpck_require__(4059);
    const buildConnector = __nccwpck_require__(2067);
    const MockClient = __nccwpck_require__(8687);
    const MockAgent = __nccwpck_require__(6771);
    const MockPool = __nccwpck_require__(6193);
    const mockErrors = __nccwpck_require__(888);
    const ProxyAgent = __nccwpck_require__(7858);
    const RetryHandler = __nccwpck_require__(2286);
    const { getGlobalDispatcher, setGlobalDispatcher } =
      __nccwpck_require__(1892);
    const DecoratorHandler = __nccwpck_require__(6930);
    const RedirectHandler = __nccwpck_require__(2860);
    const createRedirectInterceptor = __nccwpck_require__(8861);

    let hasCrypto;
    try {
      __nccwpck_require__(6113);
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }

    Object.assign(Dispatcher.prototype, api);

    module.exports.Dispatcher = Dispatcher;
    module.exports.Client = Client;
    module.exports.Pool = Pool;
    module.exports.BalancedPool = BalancedPool;
    module.exports.Agent = Agent;
    module.exports.ProxyAgent = ProxyAgent;
    module.exports.RetryHandler = RetryHandler;

    module.exports.DecoratorHandler = DecoratorHandler;
    module.exports.RedirectHandler = RedirectHandler;
    module.exports.createRedirectInterceptor = createRedirectInterceptor;

    module.exports.buildConnector = buildConnector;
    module.exports.errors = errors;

    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }

        if (
          !url ||
          (typeof url !== "string" &&
            typeof url !== "object" &&
            !(url instanceof URL))
        ) {
          throw new InvalidArgumentError("invalid url");
        }

        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }

        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }

          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }

          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }

          url = util.parseURL(url);
        }

        const { agent, dispatcher = getGlobalDispatcher() } = opts;

        if (agent) {
          throw new InvalidArgumentError(
            "unsupported opts.agent. Did you mean opts.client?"
          );
        }

        return fn.call(
          dispatcher,
          {
            ...opts,
            origin: url.origin,
            path: url.search ? `${url.pathname}${url.search}` : url.pathname,
            method: opts.method || (opts.body ? "PUT" : "GET"),
          },
          handler
        );
      };
    }

    module.exports.setGlobalDispatcher = setGlobalDispatcher;
    module.exports.getGlobalDispatcher = getGlobalDispatcher;

    if (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {
      let fetchImpl = null;
      module.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = __nccwpck_require__(4881).fetch;
        }

        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }

          throw err;
        }
      };
      module.exports.Headers = __nccwpck_require__(554).Headers;
      module.exports.Response = __nccwpck_require__(7823).Response;
      module.exports.Request = __nccwpck_require__(8359).Request;
      module.exports.FormData = __nccwpck_require__(2015).FormData;
      module.exports.File = __nccwpck_require__(8511).File;
      module.exports.FileReader = __nccwpck_require__(1446).FileReader;

      const { setGlobalOrigin, getGlobalOrigin } = __nccwpck_require__(1246);

      module.exports.setGlobalOrigin = setGlobalOrigin;
      module.exports.getGlobalOrigin = getGlobalOrigin;

      const { CacheStorage } = __nccwpck_require__(7907);
      const { kConstruct } = __nccwpck_require__(9174);

      // Cache & CacheStorage are tightly coupled with fetch. Even if it may run
      // in an older version of Node, it doesn't have any use without fetch.
      module.exports.caches = new CacheStorage(kConstruct);
    }

    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } =
        __nccwpck_require__(1724);

      module.exports.deleteCookie = deleteCookie;
      module.exports.getCookies = getCookies;
      module.exports.getSetCookies = getSetCookies;
      module.exports.setCookie = setCookie;

      const { parseMIMEType, serializeAMimeType } = __nccwpck_require__(685);

      module.exports.parseMIMEType = parseMIMEType;
      module.exports.serializeAMimeType = serializeAMimeType;
    }

    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = __nccwpck_require__(4284);

      module.exports.WebSocket = WebSocket;
    }

    module.exports.request = makeDispatcher(api.request);
    module.exports.stream = makeDispatcher(api.stream);
    module.exports.pipeline = makeDispatcher(api.pipeline);
    module.exports.connect = makeDispatcher(api.connect);
    module.exports.upgrade = makeDispatcher(api.upgrade);

    module.exports.MockClient = MockClient;
    module.exports.MockPool = MockPool;
    module.exports.MockAgent = MockAgent;
    module.exports.mockErrors = mockErrors;

    /***/
  },

  /***/ 7890: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { InvalidArgumentError } = __nccwpck_require__(8045);
    const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } =
      __nccwpck_require__(2785);
    const DispatcherBase = __nccwpck_require__(4839);
    const Pool = __nccwpck_require__(4634);
    const Client = __nccwpck_require__(3598);
    const util = __nccwpck_require__(3983);
    const createRedirectInterceptor = __nccwpck_require__(8861);
    const { WeakRef, FinalizationRegistry } = __nccwpck_require__(6436)();

    const kOnConnect = Symbol("onConnect");
    const kOnDisconnect = Symbol("onDisconnect");
    const kOnConnectionError = Symbol("onConnectionError");
    const kMaxRedirections = Symbol("maxRedirections");
    const kOnDrain = Symbol("onDrain");
    const kFactory = Symbol("factory");
    const kFinalizer = Symbol("finalizer");
    const kOptions = Symbol("options");

    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1
        ? new Client(origin, opts)
        : new Pool(origin, opts);
    }

    class Agent extends DispatcherBase {
      constructor({
        factory = defaultFactory,
        maxRedirections = 0,
        connect,
        ...options
      } = {}) {
        super();

        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }

        if (
          connect != null &&
          typeof connect !== "function" &&
          typeof connect !== "object"
        ) {
          throw new InvalidArgumentError(
            "connect must be a function or an object"
          );
        }

        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError(
            "maxRedirections must be a positive number"
          );
        }

        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }

        this[kInterceptors] =
          options.interceptors &&
          options.interceptors.Agent &&
          Array.isArray(options.interceptors.Agent)
            ? options.interceptors.Agent
            : [createRedirectInterceptor({ maxRedirections })];

        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors
          ? { ...options.interceptors }
          : undefined;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */ (key) => {
            const ref = this[kClients].get(key);
            if (ref !== undefined && ref.deref() === undefined) {
              this[kClients].delete(key);
            }
          }
        );

        const agent = this;

        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };

        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };

        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };

        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }

      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          /* istanbul ignore next: gc is undeterministic */
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }

      [kDispatch](opts, handler) {
        let key;
        if (
          opts.origin &&
          (typeof opts.origin === "string" || opts.origin instanceof URL)
        ) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError(
            "opts.origin must be a non-empty string or URL."
          );
        }

        const ref = this[kClients].get(key);

        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions])
            .on("drain", this[kOnDrain])
            .on("connect", this[kOnConnect])
            .on("disconnect", this[kOnDisconnect])
            .on("connectionError", this[kOnConnectionError]);

          this[kClients].set(key, new WeakRef(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }

        return dispatcher.dispatch(opts, handler);
      }

      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          /* istanbul ignore else: gc is undeterministic */
          if (client) {
            closePromises.push(client.close());
          }
        }

        await Promise.all(closePromises);
      }

      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          /* istanbul ignore else: gc is undeterministic */
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }

        await Promise.all(destroyPromises);
      }
    }

    module.exports = Agent;

    /***/
  },

  /***/ 7032: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { addAbortListener } = __nccwpck_require__(3983);
    const { RequestAbortedError } = __nccwpck_require__(8045);

    const kListener = Symbol("kListener");
    const kSignal = Symbol("kSignal");

    function abort(self) {
      if (self.abort) {
        self.abort();
      } else {
        self.onError(new RequestAbortedError());
      }
    }

    function addSignal(self, signal) {
      self[kSignal] = null;
      self[kListener] = null;

      if (!signal) {
        return;
      }

      if (signal.aborted) {
        abort(self);
        return;
      }

      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };

      addAbortListener(self[kSignal], self[kListener]);
    }

    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }

      if ("removeEventListener" in self[kSignal]) {
        self[kSignal].removeEventListener("abort", self[kListener]);
      } else {
        self[kSignal].removeListener("abort", self[kListener]);
      }

      self[kSignal] = null;
      self[kListener] = null;
    }

    module.exports = {
      addSignal,
      removeSignal,
    };

    /***/
  },

  /***/ 9744: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { AsyncResource } = __nccwpck_require__(852);
    const { InvalidArgumentError, RequestAbortedError, SocketError } =
      __nccwpck_require__(8045);
    const util = __nccwpck_require__(3983);
    const { addSignal, removeSignal } = __nccwpck_require__(7032);

    class ConnectHandler extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }

        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }

        const { signal, opaque, responseHeaders } = opts;

        if (
          signal &&
          typeof signal.on !== "function" &&
          typeof signal.addEventListener !== "function"
        ) {
          throw new InvalidArgumentError(
            "signal must be an EventEmitter or EventTarget"
          );
        }

        super("UNDICI_CONNECT");

        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;

        addSignal(this, signal);
      }

      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }

        this.abort = abort;
        this.context = context;
      }

      onHeaders() {
        throw new SocketError("bad connect", null);
      }

      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;

        removeSignal(this);

        this.callback = null;

        let headers = rawHeaders;
        // Indicates is an HTTP2Session
        if (headers != null) {
          headers =
            this.responseHeaders === "raw"
              ? util.parseRawHeaders(rawHeaders)
              : util.parseHeaders(rawHeaders);
        }

        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context,
        });
      }

      onError(err) {
        const { callback, opaque } = this;

        removeSignal(this);

        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    }

    function connect(opts, callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }

      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }

    module.exports = connect;

    /***/
  },

  /***/ 8752: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { Readable, Duplex, PassThrough } = __nccwpck_require__(2781);
    const {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
    } = __nccwpck_require__(8045);
    const util = __nccwpck_require__(3983);
    const { AsyncResource } = __nccwpck_require__(852);
    const { addSignal, removeSignal } = __nccwpck_require__(7032);
    const assert = __nccwpck_require__(9491);

    const kResume = Symbol("resume");

    class PipelineRequest extends Readable {
      constructor() {
        super({ autoDestroy: true });

        this[kResume] = null;
      }

      _read() {
        const { [kResume]: resume } = this;

        if (resume) {
          this[kResume] = null;
          resume();
        }
      }

      _destroy(err, callback) {
        this._read();

        callback(err);
      }
    }

    class PipelineResponse extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }

      _read() {
        this[kResume]();
      }

      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }

        callback(err);
      }
    }

    class PipelineHandler extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }

        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }

        const { signal, method, opaque, onInfo, responseHeaders } = opts;

        if (
          signal &&
          typeof signal.on !== "function" &&
          typeof signal.addEventListener !== "function"
        ) {
          throw new InvalidArgumentError(
            "signal must be an EventEmitter or EventTarget"
          );
        }

        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }

        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }

        super("UNDICI_PIPELINE");

        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;

        this.req = new PipelineRequest().on("error", util.nop);

        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;

            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;

            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;

            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }

            if (abort && err) {
              abort();
            }

            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);

            removeSignal(this);

            callback(err);
          },
        }).on("prefinish", () => {
          const { req } = this;

          // Node < 15 does not call _final in same tick.
          req.push(null);
        });

        this.res = null;

        addSignal(this, signal);
      }

      onConnect(abort, context) {
        const { ret, res } = this;

        assert(!res, "pipeline cannot be retried");

        if (ret.destroyed) {
          throw new RequestAbortedError();
        }

        this.abort = abort;
        this.context = context;
      }

      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;

        if (statusCode < 200) {
          if (this.onInfo) {
            const headers =
              this.responseHeaders === "raw"
                ? util.parseRawHeaders(rawHeaders)
                : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }

        this.res = new PipelineResponse(resume);

        let body;
        try {
          this.handler = null;
          const headers =
            this.responseHeaders === "raw"
              ? util.parseRawHeaders(rawHeaders)
              : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context,
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }

        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }

        body
          .on("data", (chunk) => {
            const { ret, body } = this;

            if (!ret.push(chunk) && body.pause) {
              body.pause();
            }
          })
          .on("error", (err) => {
            const { ret } = this;

            util.destroy(ret, err);
          })
          .on("end", () => {
            const { ret } = this;

            ret.push(null);
          })
          .on("close", () => {
            const { ret } = this;

            if (!ret._readableState.ended) {
              util.destroy(ret, new RequestAbortedError());
            }
          });

        this.body = body;
      }

      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }

      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }

      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    }

    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }

    module.exports = pipeline;

    /***/
  },

  /***/ 5448: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const Readable = __nccwpck_require__(3858);
    const { InvalidArgumentError, RequestAbortedError } =
      __nccwpck_require__(8045);
    const util = __nccwpck_require__(3983);
    const { getResolveErrorBodyCallback } = __nccwpck_require__(7474);
    const { AsyncResource } = __nccwpck_require__(852);
    const { addSignal, removeSignal } = __nccwpck_require__(7032);

    class RequestHandler extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }

        const {
          signal,
          method,
          opaque,
          body,
          onInfo,
          responseHeaders,
          throwOnError,
          highWaterMark,
        } = opts;

        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }

          if (
            highWaterMark &&
            (typeof highWaterMark !== "number" || highWaterMark < 0)
          ) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }

          if (
            signal &&
            typeof signal.on !== "function" &&
            typeof signal.addEventListener !== "function"
          ) {
            throw new InvalidArgumentError(
              "signal must be an EventEmitter or EventTarget"
            );
          }

          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }

          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }

          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }

        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;

        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }

        addSignal(this, signal);
      }

      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }

        this.abort = abort;
        this.context = context;
      }

      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const {
          callback,
          opaque,
          abort,
          context,
          responseHeaders,
          highWaterMark,
        } = this;

        const headers =
          responseHeaders === "raw"
            ? util.parseRawHeaders(rawHeaders)
            : util.parseHeaders(rawHeaders);

        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }

        const parsedHeaders =
          responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({
          resume,
          abort,
          contentType,
          highWaterMark,
        });

        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(getResolveErrorBodyCallback, null, {
              callback,
              body,
              contentType,
              statusCode,
              statusMessage,
              headers,
            });
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context,
            });
          }
        }
      }

      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }

      onComplete(trailers) {
        const { res } = this;

        removeSignal(this);

        util.parseHeaders(trailers, this.trailers);

        res.push(null);
      }

      onError(err) {
        const { res, callback, body, opaque } = this;

        removeSignal(this);

        if (callback) {
          // TODO: Does this need queueMicrotask?
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }

        if (res) {
          this.res = null;
          // Ensure all queued handlers are invoked before destroying res.
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }

        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    }

    function request(opts, callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }

      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }

    module.exports = request;
    module.exports.RequestHandler = RequestHandler;

    /***/
  },

  /***/ 5395: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { finished, PassThrough } = __nccwpck_require__(2781);
    const {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
    } = __nccwpck_require__(8045);
    const util = __nccwpck_require__(3983);
    const { getResolveErrorBodyCallback } = __nccwpck_require__(7474);
    const { AsyncResource } = __nccwpck_require__(852);
    const { addSignal, removeSignal } = __nccwpck_require__(7032);

    class StreamHandler extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }

        const {
          signal,
          method,
          opaque,
          body,
          onInfo,
          responseHeaders,
          throwOnError,
        } = opts;

        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }

          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }

          if (
            signal &&
            typeof signal.on !== "function" &&
            typeof signal.addEventListener !== "function"
          ) {
            throw new InvalidArgumentError(
              "signal must be an EventEmitter or EventTarget"
            );
          }

          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }

          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }

          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }

        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;

        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }

        addSignal(this, signal);
      }

      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }

        this.abort = abort;
        this.context = context;
      }

      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;

        const headers =
          responseHeaders === "raw"
            ? util.parseRawHeaders(rawHeaders)
            : util.parseHeaders(rawHeaders);

        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }

        this.factory = null;

        let res;

        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders =
            responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();

          this.callback = null;
          this.runInAsyncScope(getResolveErrorBodyCallback, null, {
            callback,
            body: res,
            contentType,
            statusCode,
            statusMessage,
            headers,
          });
        } else {
          if (factory === null) {
            return;
          }

          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context,
          });

          if (
            !res ||
            typeof res.write !== "function" ||
            typeof res.end !== "function" ||
            typeof res.on !== "function"
          ) {
            throw new InvalidReturnValueError("expected Writable");
          }

          // TODO: Avoid finished. It registers an unnecessary amount of listeners.
          finished(res, { readable: false }, (err) => {
            const { callback, res, opaque, trailers, abort } = this;

            this.res = null;
            if (err || !res.readable) {
              util.destroy(res, err);
            }

            this.callback = null;
            this.runInAsyncScope(callback, null, err || null, {
              opaque,
              trailers,
            });

            if (err) {
              abort();
            }
          });
        }

        res.on("drain", resume);

        this.res = res;

        const needDrain =
          res.writableNeedDrain !== undefined
            ? res.writableNeedDrain
            : res._writableState && res._writableState.needDrain;

        return needDrain !== true;
      }

      onData(chunk) {
        const { res } = this;

        return res ? res.write(chunk) : true;
      }

      onComplete(trailers) {
        const { res } = this;

        removeSignal(this);

        if (!res) {
          return;
        }

        this.trailers = util.parseHeaders(trailers);

        res.end();
      }

      onError(err) {
        const { res, callback, opaque, body } = this;

        removeSignal(this);

        this.factory = null;

        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }

        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    }

    function stream(opts, factory, callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }

      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }

    module.exports = stream;

    /***/
  },

  /***/ 6923: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { InvalidArgumentError, RequestAbortedError, SocketError } =
      __nccwpck_require__(8045);
    const { AsyncResource } = __nccwpck_require__(852);
    const util = __nccwpck_require__(3983);
    const { addSignal, removeSignal } = __nccwpck_require__(7032);
    const assert = __nccwpck_require__(9491);

    class UpgradeHandler extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }

        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }

        const { signal, opaque, responseHeaders } = opts;

        if (
          signal &&
          typeof signal.on !== "function" &&
          typeof signal.addEventListener !== "function"
        ) {
          throw new InvalidArgumentError(
            "signal must be an EventEmitter or EventTarget"
          );
        }

        super("UNDICI_UPGRADE");

        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;

        addSignal(this, signal);
      }

      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }

        this.abort = abort;
        this.context = null;
      }

      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }

      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;

        assert.strictEqual(statusCode, 101);

        removeSignal(this);

        this.callback = null;
        const headers =
          this.responseHeaders === "raw"
            ? util.parseRawHeaders(rawHeaders)
            : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context,
        });
      }

      onError(err) {
        const { callback, opaque } = this;

        removeSignal(this);

        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    }

    function upgrade(opts, callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }

      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch(
          {
            ...opts,
            method: opts.method || "GET",
            upgrade: opts.protocol || "Websocket",
          },
          upgradeHandler
        );
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }

    module.exports = upgrade;

    /***/
  },

  /***/ 4059: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports.request = __nccwpck_require__(5448);
    module.exports.stream = __nccwpck_require__(5395);
    module.exports.pipeline = __nccwpck_require__(8752);
    module.exports.upgrade = __nccwpck_require__(6923);
    module.exports.connect = __nccwpck_require__(9744);

    /***/
  },

  /***/ 3858: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // Ported from https://github.com/nodejs/undici/pull/907

    const assert = __nccwpck_require__(9491);
    const { Readable } = __nccwpck_require__(2781);
    const { RequestAbortedError, NotSupportedError, InvalidArgumentError } =
      __nccwpck_require__(8045);
    const util = __nccwpck_require__(3983);
    const { ReadableStreamFrom, toUSVString } = __nccwpck_require__(3983);

    let Blob;

    const kConsume = Symbol("kConsume");
    const kReading = Symbol("kReading");
    const kBody = Symbol("kBody");
    const kAbort = Symbol("abort");
    const kContentType = Symbol("kContentType");

    const noop = () => {};

    module.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024, // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark,
        });

        this._readableState.dataEmitted = false;

        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;

        // Is stream being consumed through Readable API?
        // This is an optimization so that we avoid checking
        // for 'data' and 'readable' listeners in the hot path
        // inside push().
        this[kReading] = false;
      }

      destroy(err) {
        if (this.destroyed) {
          // Node < 16
          return this;
        }

        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }

        if (err) {
          this[kAbort]();
        }

        return super.destroy(err);
      }

      emit(ev, ...args) {
        if (ev === "data") {
          // Node < 16.7
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          // Node < 16
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }

      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }

      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }

      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] =
            this.listenerCount("data") > 0 ||
            this.listenerCount("readable") > 0;
        }
        return ret;
      }

      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }

      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }

      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }

      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }

      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }

      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }

      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        // TODO: Implement.
        throw new NotSupportedError();
      }

      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }

      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            // TODO: Is this the best way to force a lock?
            this[kBody].getReader(); // Ensure stream is locked.
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }

      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;

        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }

        if (this.closed) {
          return Promise.resolve(null);
        }

        return new Promise((resolve, reject) => {
          const signalListenerCleanup = signal
            ? util.addAbortListener(signal, () => {
                this.destroy();
              })
            : noop;

          this.on("close", function () {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(
                signal.reason ||
                  Object.assign(new Error("The operation was aborted"), {
                    name: "AbortError",
                  })
              );
            } else {
              resolve(null);
            }
          })
            .on("error", noop)
            .on("data", function (chunk) {
              limit -= chunk.length;
              if (limit <= 0) {
                this.destroy();
              }
            })
            .resume();
        });
      }
    };

    // https://streams.spec.whatwg.org/#readablestream-locked
    function isLocked(self) {
      // Consume is an implicit lock.
      return (self[kBody] && self[kBody].locked === true) || self[kConsume];
    }

    // https://fetch.spec.whatwg.org/#body-unusable
    function isUnusable(self) {
      return util.isDisturbed(self) || isLocked(self);
    }

    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }

      assert(!stream[kConsume]);

      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: [],
        };

        stream
          .on("error", function (err) {
            consumeFinish(this[kConsume], err);
          })
          .on("close", function () {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError());
            }
          });

        process.nextTick(consumeStart, stream[kConsume]);
      });
    }

    function consumeStart(consume) {
      if (consume.body === null) {
        return;
      }

      const { _readableState: state } = consume.stream;

      for (const chunk of state.buffer) {
        consumePush(consume, chunk);
      }

      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume.stream.on("end", function () {
          consumeEnd(this[kConsume]);
        });
      }

      consume.stream.resume();

      while (consume.stream.read() != null) {
        // Loop
      }
    }

    function consumeEnd(consume) {
      const { type, body, resolve, stream, length } = consume;

      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);

          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }

          resolve(dst.buffer);
        } else if (type === "blob") {
          if (!Blob) {
            Blob = __nccwpck_require__(4300).Blob;
          }
          resolve(new Blob(body, { type: stream[kContentType] }));
        }

        consumeFinish(consume);
      } catch (err) {
        stream.destroy(err);
      }
    }

    function consumePush(consume, chunk) {
      consume.length += chunk.length;
      consume.body.push(chunk);
    }

    function consumeFinish(consume, err) {
      if (consume.body === null) {
        return;
      }

      if (err) {
        consume.reject(err);
      } else {
        consume.resolve();
      }

      consume.type = null;
      consume.stream = null;
      consume.resolve = null;
      consume.reject = null;
      consume.length = 0;
      consume.body = null;
    }

    /***/
  },

  /***/ 7474: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const assert = __nccwpck_require__(9491);
    const { ResponseStatusCodeError } = __nccwpck_require__(8045);
    const { toUSVString } = __nccwpck_require__(3983);

    async function getResolveErrorBodyCallback({
      callback,
      body,
      contentType,
      statusCode,
      statusMessage,
      headers,
    }) {
      assert(body);

      let chunks = [];
      let limit = 0;

      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }

      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(
          callback,
          new ResponseStatusCodeError(
            `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
            statusCode,
            headers
          )
        );
        return;
      }

      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(
            callback,
            new ResponseStatusCodeError(
              `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
              statusCode,
              headers,
              payload
            )
          );
          return;
        }

        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(
            callback,
            new ResponseStatusCodeError(
              `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
              statusCode,
              headers,
              payload
            )
          );
          return;
        }
      } catch (err) {
        // Process in a fallback if error
      }

      process.nextTick(
        callback,
        new ResponseStatusCodeError(
          `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
          statusCode,
          headers
        )
      );
    }

    module.exports = { getResolveErrorBodyCallback };

    /***/
  },

  /***/ 7931: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { BalancedPoolMissingUpstreamError, InvalidArgumentError } =
      __nccwpck_require__(8045);
    const {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher,
    } = __nccwpck_require__(3198);
    const Pool = __nccwpck_require__(4634);
    const { kUrl, kInterceptors } = __nccwpck_require__(2785);
    const { parseOrigin } = __nccwpck_require__(3983);
    const kFactory = Symbol("factory");

    const kOptions = Symbol("options");
    const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    const kCurrentWeight = Symbol("kCurrentWeight");
    const kIndex = Symbol("kIndex");
    const kWeight = Symbol("kWeight");
    const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    const kErrorPenalty = Symbol("kErrorPenalty");

    function getGreatestCommonDivisor(a, b) {
      if (b === 0) return a;
      return getGreatestCommonDivisor(b, a % b);
    }

    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }

    class BalancedPool extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();

        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;

        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;

        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }

        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }

        this[kInterceptors] =
          opts.interceptors &&
          opts.interceptors.BalancedPool &&
          Array.isArray(opts.interceptors.BalancedPool)
            ? opts.interceptors.BalancedPool
            : [];
        this[kFactory] = factory;

        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }

      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;

        if (
          this[kClients].find(
            (pool) =>
              pool[kUrl].origin === upstreamOrigin &&
              pool.closed !== true &&
              pool.destroyed !== true
          )
        ) {
          return this;
        }
        const pool = this[kFactory](
          upstreamOrigin,
          Object.assign({}, this[kOptions])
        );

        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(
            this[kMaxWeightPerServer],
            pool[kWeight] + this[kErrorPenalty]
          );
        });

        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });

        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            // decrease the weight of the pool.
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });

        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }

        this._updateBalancedPoolStats();

        return this;
      }

      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients]
          .map((p) => p[kWeight])
          .reduce(getGreatestCommonDivisor, 0);
      }

      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;

        const pool = this[kClients].find(
          (pool) =>
            pool[kUrl].origin === upstreamOrigin &&
            pool.closed !== true &&
            pool.destroyed !== true
        );

        if (pool) {
          this[kRemoveClient](pool);
        }

        return this;
      }

      get upstreams() {
        return this[kClients]
          .filter(
            (dispatcher) =>
              dispatcher.closed !== true && dispatcher.destroyed !== true
          )
          .map((p) => p[kUrl].origin);
      }

      [kGetDispatcher]() {
        // We validate that pools is greater than 0,
        // otherwise we would have to wait until an upstream
        // is added, which might never happen.
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }

        const dispatcher = this[kClients].find(
          (dispatcher) =>
            !dispatcher[kNeedDrain] &&
            dispatcher.closed !== true &&
            dispatcher.destroyed !== true
        );

        if (!dispatcher) {
          return;
        }

        const allClientsBusy = this[kClients]
          .map((pool) => pool[kNeedDrain])
          .reduce((a, b) => a && b, true);

        if (allClientsBusy) {
          return;
        }

        let counter = 0;

        let maxWeightIndex = this[kClients].findIndex(
          (pool) => !pool[kNeedDrain]
        );

        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];

          // find pool index with the largest weight
          if (
            pool[kWeight] > this[kClients][maxWeightIndex][kWeight] &&
            !pool[kNeedDrain]
          ) {
            maxWeightIndex = this[kIndex];
          }

          // decrease the current weight every `this[kClients].length`.
          if (this[kIndex] === 0) {
            // Set the current weight to the next lower weight.
            this[kCurrentWeight] =
              this[kCurrentWeight] - this[kGreatestCommonDivisor];

            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }

        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    }

    module.exports = BalancedPool;

    /***/
  },

  /***/ 6101: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kConstruct } = __nccwpck_require__(9174);
    const { urlEquals, fieldValues: getFieldValues } =
      __nccwpck_require__(2396);
    const { kEnumerableProperty, isDisturbed } = __nccwpck_require__(3983);
    const { kHeadersList } = __nccwpck_require__(2785);
    const { webidl } = __nccwpck_require__(1744);
    const { Response, cloneResponse } = __nccwpck_require__(7823);
    const { Request } = __nccwpck_require__(8359);
    const { kState, kHeaders, kGuard, kRealm } = __nccwpck_require__(5861);
    const { fetching } = __nccwpck_require__(4881);
    const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } =
      __nccwpck_require__(2538);
    const assert = __nccwpck_require__(9491);
    const { getGlobalDispatcher } = __nccwpck_require__(1892);

    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
     * @typedef {Object} CacheBatchOperation
     * @property {'delete' | 'put'} type
     * @property {any} request
     * @property {any} response
     * @property {import('../../types/cache').CacheQueryOptions} options
     */

    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
     * @typedef {[any, any][]} requestResponseList
     */

    class Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;

      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }

        this.#relevantRequestResponseList = arguments[1];
      }

      async match(request, options = {}) {
        webidl.brandCheck(this, Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });

        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);

        const p = await this.matchAll(request, options);

        if (p.length === 0) {
          return;
        }

        return p[0];
      }

      async matchAll(request = undefined, options = {}) {
        webidl.brandCheck(this, Cache);

        if (request !== undefined)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);

        // 1.
        let r = null;

        // 2.
        if (request !== undefined) {
          if (request instanceof Request) {
            // 2.1.1
            r = request[kState];

            // 2.1.2
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            // 2.2.1
            r = new Request(request)[kState];
          }
        }

        // 5.
        // 5.1
        const responses = [];

        // 5.2
        if (request === undefined) {
          // 5.2.1
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          // 5.3
          // 5.3.1
          const requestResponses = this.#queryCache(r, options);

          // 5.3.2
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }

        // 5.4
        // We don't implement CORs so we don't need to loop over the responses, yay!

        // 5.5.1
        const responseList = [];

        // 5.5.2
        for (const response of responses) {
          // 5.5.2.1
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";

          responseList.push(responseObject);
        }

        // 6.
        return Object.freeze(responseList);
      }

      async add(request) {
        webidl.brandCheck(this, Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });

        request = webidl.converters.RequestInfo(request);

        // 1.
        const requests = [request];

        // 2.
        const responseArrayPromise = this.addAll(requests);

        // 3.
        return await responseArrayPromise;
      }

      async addAll(requests) {
        webidl.brandCheck(this, Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });

        requests = webidl.converters["sequence<RequestInfo>"](requests);

        // 1.
        const responsePromises = [];

        // 2.
        const requestList = [];

        // 3.
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }

          // 3.1
          const r = request[kState];

          // 3.2
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET.",
            });
          }
        }

        // 4.
        /** @type {ReturnType<typeof fetching>[]} */
        const fetchControllers = [];

        // 5.
        for (const request of requests) {
          // 5.1
          const r = new Request(request)[kState];

          // 5.2
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme.",
            });
          }

          // 5.4
          r.initiator = "fetch";
          r.destination = "subresource";

          // 5.5
          requestList.push(r);

          // 5.6
          const responsePromise = createDeferredPromise();

          // 5.7
          fetchControllers.push(
            fetching({
              request: r,
              dispatcher: getGlobalDispatcher(),
              processResponse(response) {
                // 1.
                if (
                  response.type === "error" ||
                  response.status === 206 ||
                  response.status < 200 ||
                  response.status > 299
                ) {
                  responsePromise.reject(
                    webidl.errors.exception({
                      header: "Cache.addAll",
                      message:
                        "Received an invalid status code or the request failed.",
                    })
                  );
                } else if (response.headersList.contains("vary")) {
                  // 2.
                  // 2.1
                  const fieldValues = getFieldValues(
                    response.headersList.get("vary")
                  );

                  // 2.2
                  for (const fieldValue of fieldValues) {
                    // 2.2.1
                    if (fieldValue === "*") {
                      responsePromise.reject(
                        webidl.errors.exception({
                          header: "Cache.addAll",
                          message: "invalid vary field value",
                        })
                      );

                      for (const controller of fetchControllers) {
                        controller.abort();
                      }

                      return;
                    }
                  }
                }
              },
              processResponseEndOfBody(response) {
                // 1.
                if (response.aborted) {
                  responsePromise.reject(
                    new DOMException("aborted", "AbortError")
                  );
                  return;
                }

                // 2.
                responsePromise.resolve(response);
              },
            })
          );

          // 5.8
          responsePromises.push(responsePromise.promise);
        }

        // 6.
        const p = Promise.all(responsePromises);

        // 7.
        const responses = await p;

        // 7.1
        const operations = [];

        // 7.2
        let index = 0;

        // 7.3
        for (const response of responses) {
          // 7.3.1
          /** @type {CacheBatchOperation} */
          const operation = {
            type: "put", // 7.3.2
            request: requestList[index], // 7.3.3
            response, // 7.3.4
          };

          operations.push(operation); // 7.3.5

          index++; // 7.3.6
        }

        // 7.5
        const cacheJobPromise = createDeferredPromise();

        // 7.6.1
        let errorData = null;

        // 7.6.2
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }

        // 7.6.3
        queueMicrotask(() => {
          // 7.6.3.1
          if (errorData === null) {
            cacheJobPromise.resolve(undefined);
          } else {
            // 7.6.3.2
            cacheJobPromise.reject(errorData);
          }
        });

        // 7.7
        return cacheJobPromise.promise;
      }

      async put(request, response) {
        webidl.brandCheck(this, Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });

        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);

        // 1.
        let innerRequest = null;

        // 2.
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          // 3.
          innerRequest = new Request(request)[kState];
        }

        // 4.
        if (
          !urlIsHttpHttpsScheme(innerRequest.url) ||
          innerRequest.method !== "GET"
        ) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET",
          });
        }

        // 5.
        const innerResponse = response[kState];

        // 6.
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status",
          });
        }

        // 7.
        if (innerResponse.headersList.contains("vary")) {
          // 7.1.
          const fieldValues = getFieldValues(
            innerResponse.headersList.get("vary")
          );

          // 7.2.
          for (const fieldValue of fieldValues) {
            // 7.2.1
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value",
              });
            }
          }
        }

        // 8.
        if (
          innerResponse.body &&
          (isDisturbed(innerResponse.body.stream) ||
            innerResponse.body.stream.locked)
        ) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed",
          });
        }

        // 9.
        const clonedResponse = cloneResponse(innerResponse);

        // 10.
        const bodyReadPromise = createDeferredPromise();

        // 11.
        if (innerResponse.body != null) {
          // 11.1
          const stream = innerResponse.body.stream;

          // 11.2
          const reader = stream.getReader();

          // 11.3
          readAllBytes(reader).then(
            bodyReadPromise.resolve,
            bodyReadPromise.reject
          );
        } else {
          bodyReadPromise.resolve(undefined);
        }

        // 12.
        /** @type {CacheBatchOperation[]} */
        const operations = [];

        // 13.
        /** @type {CacheBatchOperation} */
        const operation = {
          type: "put", // 14.
          request: innerRequest, // 15.
          response: clonedResponse, // 16.
        };

        // 17.
        operations.push(operation);

        // 19.
        const bytes = await bodyReadPromise.promise;

        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }

        // 19.1
        const cacheJobPromise = createDeferredPromise();

        // 19.2.1
        let errorData = null;

        // 19.2.2
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }

        // 19.2.3
        queueMicrotask(() => {
          // 19.2.3.1
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            // 19.2.3.2
            cacheJobPromise.reject(errorData);
          }
        });

        return cacheJobPromise.promise;
      }

      async delete(request, options = {}) {
        webidl.brandCheck(this, Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });

        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);

        /**
         * @type {Request}
         */
        let r = null;

        if (request instanceof Request) {
          r = request[kState];

          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");

          r = new Request(request)[kState];
        }

        /** @type {CacheBatchOperation[]} */
        const operations = [];

        /** @type {CacheBatchOperation} */
        const operation = {
          type: "delete",
          request: r,
          options,
        };

        operations.push(operation);

        const cacheJobPromise = createDeferredPromise();

        let errorData = null;
        let requestResponses;

        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }

        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });

        return cacheJobPromise.promise;
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = undefined, options = {}) {
        webidl.brandCheck(this, Cache);

        if (request !== undefined)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);

        // 1.
        let r = null;

        // 2.
        if (request !== undefined) {
          // 2.1
          if (request instanceof Request) {
            // 2.1.1
            r = request[kState];

            // 2.1.2
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            // 2.2
            r = new Request(request)[kState];
          }
        }

        // 4.
        const promise = createDeferredPromise();

        // 5.
        // 5.1
        const requests = [];

        // 5.2
        if (request === undefined) {
          // 5.2.1
          for (const requestResponse of this.#relevantRequestResponseList) {
            // 5.2.1.1
            requests.push(requestResponse[0]);
          }
        } else {
          // 5.3
          // 5.3.1
          const requestResponses = this.#queryCache(r, options);

          // 5.3.2
          for (const requestResponse of requestResponses) {
            // 5.3.2.1
            requests.push(requestResponse[0]);
          }
        }

        // 5.4
        queueMicrotask(() => {
          // 5.4.1
          const requestList = [];

          // 5.4.2
          for (const request of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request;
            requestObject[kHeaders][kHeadersList] = request.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request.client;

            // 5.4.2.1
            requestList.push(requestObject);
          }

          // 5.4.3
          promise.resolve(Object.freeze(requestList));
        });

        return promise.promise;
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        // 1.
        const cache = this.#relevantRequestResponseList;

        // 2.
        const backupCache = [...cache];

        // 3.
        const addedItems = [];

        // 4.1
        const resultList = [];

        try {
          // 4.2
          for (const operation of operations) {
            // 4.2.1
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"',
              });
            }

            // 4.2.2
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message:
                  "delete operation should not have an associated response",
              });
            }

            // 4.2.3
            if (
              this.#queryCache(operation.request, operation.options, addedItems)
                .length
            ) {
              throw new DOMException("???", "InvalidStateError");
            }

            // 4.2.4
            let requestResponses;

            // 4.2.5
            if (operation.type === "delete") {
              // 4.2.5.1
              requestResponses = this.#queryCache(
                operation.request,
                operation.options
              );

              // TODO: the spec is wrong, this is needed to pass WPTs
              if (requestResponses.length === 0) {
                return [];
              }

              // 4.2.5.2
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);

                // 4.2.5.2.1
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              // 4.2.6
              // 4.2.6.1
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response",
                });
              }

              // 4.2.6.2
              const r = operation.request;

              // 4.2.6.3
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme",
                });
              }

              // 4.2.6.4
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method",
                });
              }

              // 4.2.6.5
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined",
                });
              }

              // 4.2.6.6
              requestResponses = this.#queryCache(operation.request);

              // 4.2.6.7
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);

                // 4.2.6.7.1
                cache.splice(idx, 1);
              }

              // 4.2.6.8
              cache.push([operation.request, operation.response]);

              // 4.2.6.10
              addedItems.push([operation.request, operation.response]);
            }

            // 4.2.7
            resultList.push([operation.request, operation.response]);
          }

          // 4.3
          return resultList;
        } catch (e) {
          // 5.
          // 5.1
          this.#relevantRequestResponseList.length = 0;

          // 5.2
          this.#relevantRequestResponseList = backupCache;

          // 5.3
          throw e;
        }
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        /** @type {requestResponseList} */
        const resultList = [];

        const storage = targetStorage ?? this.#relevantRequestResponseList;

        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (
            this.#requestMatchesCachedItem(
              requestQuery,
              cachedRequest,
              cachedResponse,
              options
            )
          ) {
            resultList.push(requestResponse);
          }
        }

        return resultList;
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(
        requestQuery,
        request,
        response = null,
        options
      ) {
        // if (options?.ignoreMethod === false && request.method === 'GET') {
        //   return false
        // }

        const queryURL = new URL(requestQuery.url);

        const cachedURL = new URL(request.url);

        if (options?.ignoreSearch) {
          cachedURL.search = "";

          queryURL.search = "";
        }

        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }

        if (
          response == null ||
          options?.ignoreVary ||
          !response.headersList.contains("vary")
        ) {
          return true;
        }

        const fieldValues = getFieldValues(response.headersList.get("vary"));

        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }

          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);

          // If one has the header and the other doesn't, or one has
          // a different value than the other, return false
          if (requestValue !== queryValue) {
            return false;
          }
        }

        return true;
      }
    }

    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true,
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty,
    });

    const cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
    ];

    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(
      cacheQueryOptionConverters
    );

    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString,
      },
    ]);

    webidl.converters.Response = webidl.interfaceConverter(Response);

    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );

    module.exports = {
      Cache,
    };

    /***/
  },

  /***/ 7907: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kConstruct } = __nccwpck_require__(9174);
    const { Cache } = __nccwpck_require__(6101);
    const { webidl } = __nccwpck_require__(1744);
    const { kEnumerableProperty } = __nccwpck_require__(3983);

    class CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = new Map();

      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }

      async match(request, options = {}) {
        webidl.brandCheck(this, CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, {
          header: "CacheStorage.match",
        });

        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);

        // 1.
        if (options.cacheName != null) {
          // 1.1.1.1
          if (this.#caches.has(options.cacheName)) {
            // 1.1.1.1.1
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);

            return await cache.match(request, options);
          }
        } else {
          // 2.
          // 2.2
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);

            // 2.2.1.2
            const response = await cache.match(request, options);

            if (response !== undefined) {
              return response;
            }
          }
        }
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, {
          header: "CacheStorage.has",
        });

        cacheName = webidl.converters.DOMString(cacheName);

        // 2.1.1
        // 2.2
        return this.#caches.has(cacheName);
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, {
          header: "CacheStorage.open",
        });

        cacheName = webidl.converters.DOMString(cacheName);

        // 2.1
        if (this.#caches.has(cacheName)) {
          // await caches.open('v1') !== await caches.open('v1')

          // 2.1.1
          const cache = this.#caches.get(cacheName);

          // 2.1.1.1
          return new Cache(kConstruct, cache);
        }

        // 2.2
        const cache = [];

        // 2.3
        this.#caches.set(cacheName, cache);

        // 2.4
        return new Cache(kConstruct, cache);
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, {
          header: "CacheStorage.delete",
        });

        cacheName = webidl.converters.DOMString(cacheName);

        return this.#caches.delete(cacheName);
      }

      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, CacheStorage);

        // 2.1
        const keys = this.#caches.keys();

        // 2.2
        return [...keys];
      }
    }

    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true,
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty,
    });

    module.exports = {
      CacheStorage,
    };

    /***/
  },

  /***/ 9174: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    module.exports = {
      kConstruct: __nccwpck_require__(2785).kConstruct,
    };

    /***/
  },

  /***/ 2396: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const assert = __nccwpck_require__(9491);
    const { URLSerializer } = __nccwpck_require__(685);
    const { isValidHeaderName } = __nccwpck_require__(2538);

    /**
     * @see https://url.spec.whatwg.org/#concept-url-equals
     * @param {URL} A
     * @param {URL} B
     * @param {boolean | undefined} excludeFragment
     * @returns {boolean}
     */
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);

      const serializedB = URLSerializer(B, excludeFragment);

      return serializedA === serializedB;
    }

    /**
     * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
     * @param {string} header
     */
    function fieldValues(header) {
      assert(header !== null);

      const values = [];

      for (let value of header.split(",")) {
        value = value.trim();

        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }

        values.push(value);
      }

      return values;
    }

    module.exports = {
      urlEquals,
      fieldValues,
    };

    /***/
  },

  /***/ 3598: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // @ts-check

    /* global WebAssembly */

    const assert = __nccwpck_require__(9491);
    const net = __nccwpck_require__(1808);
    const http = __nccwpck_require__(3685);
    const { pipeline } = __nccwpck_require__(2781);
    const util = __nccwpck_require__(3983);
    const timers = __nccwpck_require__(9459);
    const Request = __nccwpck_require__(2905);
    const DispatcherBase = __nccwpck_require__(4839);
    const {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError,
    } = __nccwpck_require__(8045);
    const buildConnector = __nccwpck_require__(2067);
    const {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest,
    } = __nccwpck_require__(2785);

    /** @type {import('http2')} */
    let http2;
    try {
      http2 = __nccwpck_require__(5158);
    } catch {
      // @ts-ignore
      http2 = { constants: {} };
    }

    const {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS,
      },
    } = http2;

    // Experimental
    let h2ExperimentalWarned = false;

    const FastBuffer = Buffer[Symbol.species];

    const kClosedResolve = Symbol("kClosedResolve");

    const channels = {};

    try {
      const diagnosticsChannel = __nccwpck_require__(7643);
      channels.sendHeaders = diagnosticsChannel.channel(
        "undici:client:sendHeaders"
      );
      channels.beforeConnect = diagnosticsChannel.channel(
        "undici:client:beforeConnect"
      );
      channels.connectError = diagnosticsChannel.channel(
        "undici:client:connectError"
      );
      channels.connected = diagnosticsChannel.channel(
        "undici:client:connected"
      );
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }

    /**
     * @type {import('../types/client').default}
     */
    class Client extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(
        url,
        {
          interceptors,
          maxHeaderSize,
          headersTimeout,
          socketTimeout,
          requestTimeout,
          connectTimeout,
          bodyTimeout,
          idleTimeout,
          keepAlive,
          keepAliveTimeout,
          maxKeepAliveTimeout,
          keepAliveMaxTimeout,
          keepAliveTimeoutThreshold,
          socketPath,
          pipelining,
          tls,
          strictContentLength,
          maxCachedSessions,
          maxRedirections,
          connect,
          maxRequestsPerClient,
          localAddress,
          maxResponseSize,
          autoSelectFamily,
          autoSelectFamilyAttemptTimeout,
          // h2
          allowH2,
          maxConcurrentStreams,
        } = {}
      ) {
        super();

        if (keepAlive !== undefined) {
          throw new InvalidArgumentError(
            "unsupported keepAlive, use pipelining=0 instead"
          );
        }

        if (socketTimeout !== undefined) {
          throw new InvalidArgumentError(
            "unsupported socketTimeout, use headersTimeout & bodyTimeout instead"
          );
        }

        if (requestTimeout !== undefined) {
          throw new InvalidArgumentError(
            "unsupported requestTimeout, use headersTimeout & bodyTimeout instead"
          );
        }

        if (idleTimeout !== undefined) {
          throw new InvalidArgumentError(
            "unsupported idleTimeout, use keepAliveTimeout instead"
          );
        }

        if (maxKeepAliveTimeout !== undefined) {
          throw new InvalidArgumentError(
            "unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead"
          );
        }

        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }

        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }

        if (
          connectTimeout != null &&
          (!Number.isFinite(connectTimeout) || connectTimeout < 0)
        ) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }

        if (
          keepAliveTimeout != null &&
          (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)
        ) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }

        if (
          keepAliveMaxTimeout != null &&
          (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)
        ) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }

        if (
          keepAliveTimeoutThreshold != null &&
          !Number.isFinite(keepAliveTimeoutThreshold)
        ) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }

        if (
          headersTimeout != null &&
          (!Number.isInteger(headersTimeout) || headersTimeout < 0)
        ) {
          throw new InvalidArgumentError(
            "headersTimeout must be a positive integer or zero"
          );
        }

        if (
          bodyTimeout != null &&
          (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)
        ) {
          throw new InvalidArgumentError(
            "bodyTimeout must be a positive integer or zero"
          );
        }

        if (
          connect != null &&
          typeof connect !== "function" &&
          typeof connect !== "object"
        ) {
          throw new InvalidArgumentError(
            "connect must be a function or an object"
          );
        }

        if (
          maxRedirections != null &&
          (!Number.isInteger(maxRedirections) || maxRedirections < 0)
        ) {
          throw new InvalidArgumentError(
            "maxRedirections must be a positive number"
          );
        }

        if (
          maxRequestsPerClient != null &&
          (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)
        ) {
          throw new InvalidArgumentError(
            "maxRequestsPerClient must be a positive number"
          );
        }

        if (
          localAddress != null &&
          (typeof localAddress !== "string" || net.isIP(localAddress) === 0)
        ) {
          throw new InvalidArgumentError(
            "localAddress must be valid string IP address"
          );
        }

        if (
          maxResponseSize != null &&
          (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)
        ) {
          throw new InvalidArgumentError(
            "maxResponseSize must be a positive number"
          );
        }

        if (
          autoSelectFamilyAttemptTimeout != null &&
          (!Number.isInteger(autoSelectFamilyAttemptTimeout) ||
            autoSelectFamilyAttemptTimeout < -1)
        ) {
          throw new InvalidArgumentError(
            "autoSelectFamilyAttemptTimeout must be a positive number"
          );
        }

        // h2
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError(
            "allowH2 must be a valid boolean value"
          );
        }

        if (
          maxConcurrentStreams != null &&
          (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)
        ) {
          throw new InvalidArgumentError(
            "maxConcurrentStreams must be a possitive integer, greater than 0"
          );
        }

        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...(util.nodeHasAutoSelectFamily && autoSelectFamily
              ? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
              : undefined),
            ...connect,
          });
        }

        this[kInterceptors] =
          interceptors &&
          interceptors.Client &&
          Array.isArray(interceptors.Client)
            ? interceptors.Client
            : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] =
          keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] =
          keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] =
          keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming
        this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming
        this[kHostHeader] =
          `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r\n`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;
        this[kStrictContentLength] =
          strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";

        // HTTP/2
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2
          ? null
          : {
              // streams: null, // Fixed queue of streams - For future support of `push`
              openStreams: 0, // Keep track of them to decide wether or not unref the session
              maxConcurrentStreams:
                maxConcurrentStreams != null ? maxConcurrentStreams : 100, // Max peerConcurrentStreams for a Node h2 server
            };
        this[kHost] =
          `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;

        // kQueue is built up of 3 sections separated by
        // the kRunningIdx and kPendingIdx indices.
        // |   complete   |   running   |   pending   |
        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
        // kRunningIdx points to the first running element.
        // kPendingIdx points to the first pending element.
        // This implements a fast queue with an amortized
        // time of O(1).

        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }

      get pipelining() {
        return this[kPipelining];
      }

      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }

      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }

      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }

      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }

      get [kConnected]() {
        return (
          !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed
        );
      }

      get [kBusy]() {
        const socket = this[kSocket];
        return (
          (socket &&
            (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
          this[kSize] >= (this[kPipelining] || 1) ||
          this[kPending] > 0
        );
      }

      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }

      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;

        const request =
          this[kHTTPConnVersion] === "h2"
            ? Request[kHTTP2BuildRequest](origin, opts, handler)
            : Request[kHTTP1BuildRequest](origin, opts, handler);

        this[kQueue].push(request);
        if (this[kResuming]) {
          // Do nothing.
        } else if (
          util.bodyLength(request.body) == null &&
          util.isIterable(request.body)
        ) {
          // Wait a tick in case stream/iterator is ended in the same tick.
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }

        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }

        return this[kNeedDrain] < 2;
      }

      async [kClose]() {
        // TODO: for H2 we need to gracefully flush the remaining enqueued
        // request and close each stream.
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }

      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }

          const callback = () => {
            if (this[kClosedResolve]) {
              // TODO (fix): Should we error here with ClientDestroyedError?
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };

          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }

          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }

          resume(this);
        });
      }
    }

    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");

      this[kSocket][kError] = err;

      onError(this[kClient], err);
    }

    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(
        `HTTP/2: "frameError" received - type ${type}, code ${code}`
      );

      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }

    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }

    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(
        `HTTP/2: "GOAWAY" frame received with code ${code}`
      );
      client[kSocket] = null;
      client[kHTTP2Session] = null;

      if (client.destroyed) {
        assert(this[kPending] === 0);

        // Fail entire queue.
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        // Fail head of pipeline.
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;

        errorRequest(client, request, err);
      }

      client[kPendingIdx] = client[kRunningIdx];

      assert(client[kRunning] === 0);

      client.emit("disconnect", client[kUrl], [client], err);

      resume(client);
    }

    const constants = __nccwpck_require__(953);
    const createRedirectInterceptor = __nccwpck_require__(8861);
    const EMPTY_BUF = Buffer.alloc(0);

    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID
        ? __nccwpck_require__(1145)
        : undefined;

      let mod;
      try {
        mod = await WebAssembly.compile(
          Buffer.from(__nccwpck_require__(5627), "base64")
        );
      } catch (e) {
        /* istanbul ignore next */

        // We could check if the error was caused by the simd option not
        // being enabled, but the occurring of this other error
        // * https://github.com/emscripten-core/emscripten/issues/11495
        // got me to remove that check to avoid breaking Node 12.
        mod = await WebAssembly.compile(
          Buffer.from(llhttpWasmData || __nccwpck_require__(1145), "base64")
        );
      }

      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */

          wasm_on_url: (p, at, len) => {
            /* istanbul ignore next */
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return (
              currentParser.onStatus(
                new FastBuffer(currentBufferRef.buffer, start, len)
              ) || 0
            );
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return (
              currentParser.onHeaderField(
                new FastBuffer(currentBufferRef.buffer, start, len)
              ) || 0
            );
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return (
              currentParser.onHeaderValue(
                new FastBuffer(currentBufferRef.buffer, start, len)
              ) || 0
            );
          },
          wasm_on_headers_complete: (
            p,
            statusCode,
            upgrade,
            shouldKeepAlive
          ) => {
            assert.strictEqual(currentParser.ptr, p);
            return (
              currentParser.onHeadersComplete(
                statusCode,
                Boolean(upgrade),
                Boolean(shouldKeepAlive)
              ) || 0
            );
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return (
              currentParser.onBody(
                new FastBuffer(currentBufferRef.buffer, start, len)
              ) || 0
            );
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          },

          /* eslint-enable camelcase */
        },
      });
    }

    let llhttpInstance = null;
    let llhttpPromise = lazyllhttp();
    llhttpPromise.catch();

    let currentParser = null;
    let currentBufferRef = null;
    let currentBufferSize = 0;
    let currentBufferPtr = null;

    const TIMEOUT_HEADERS = 1;
    const TIMEOUT_BODY = 2;
    const TIMEOUT_IDLE = 3;

    class Parser {
      constructor(client, socket, { exports }) {
        assert(
          Number.isFinite(client[kMaxHeadersSize]) &&
            client[kMaxHeadersSize] > 0
        );

        this.llhttp = exports;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);

        this.bytesRead = 0;

        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }

      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            // istanbul ignore else: only for jest
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          // istanbul ignore else: only for jest
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }

      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }

        assert(this.ptr != null);
        assert(currentParser == null);

        this.llhttp.llhttp_resume(this.ptr);

        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          // istanbul ignore else: only for jest
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }

        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.
        this.readMore();
      }

      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }

      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);

        const { socket, llhttp } = this;

        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }

        new Uint8Array(
          llhttp.memory.buffer,
          currentBufferPtr,
          currentBufferSize
        ).set(data);

        // Call `execute` on the wasm parser.
        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
        // and finally the length of bytes to parse.
        // The return value is an error code or `constants.ERROR.OK`.
        try {
          let ret;

          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(
              this.ptr,
              currentBufferPtr,
              data.length
            );
            /* eslint-disable-next-line no-useless-catch */
          } catch (err) {
            /* istanbul ignore next: difficult to make a test case for */
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }

          const offset =
            llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;

          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            /* istanbul ignore else: difficult to make a test case for */
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message =
                "Response does not match the HTTP/1.1 protocol (" +
                Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
                ")";
            }
            throw new HTTPParserError(
              message,
              constants.ERROR[ret],
              data.slice(offset)
            );
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }

      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);

        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;

        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;

        this.paused = false;
      }

      onStatus(buf) {
        this.statusText = buf.toString();
      }

      onMessageBegin() {
        const { socket, client } = this;

        /* istanbul ignore next: difficult to make a test case for */
        if (socket.destroyed) {
          return -1;
        }

        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }

      onHeaderField(buf) {
        const len = this.headers.length;

        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }

        this.trackHeader(buf.length);
      }

      onHeaderValue(buf) {
        let len = this.headers.length;

        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }

        const key = this.headers[len - 2];
        if (
          key.length === 10 &&
          key.toString().toLowerCase() === "keep-alive"
        ) {
          this.keepAlive += buf.toString();
        } else if (
          key.length === 10 &&
          key.toString().toLowerCase() === "connection"
        ) {
          this.connection += buf.toString();
        } else if (
          key.length === 14 &&
          key.toString().toLowerCase() === "content-length"
        ) {
          this.contentLength += buf.toString();
        }

        this.trackHeader(buf.length);
      }

      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }

      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;

        assert(upgrade);

        const request = client[kQueue][client[kRunningIdx]];
        assert(request);

        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");

        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;

        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;

        socket.unshift(head);

        socket[kParser].destroy();
        socket[kParser] = null;

        socket[kClient] = null;
        socket[kError] = null;
        socket
          .removeListener("error", onSocketError)
          .removeListener("readable", onSocketReadable)
          .removeListener("end", onSocketEnd)
          .removeListener("close", onSocketClose);

        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit(
          "disconnect",
          client[kUrl],
          [client],
          new InformationalError("upgrade")
        );

        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }

        resume(client);
      }

      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;

        /* istanbul ignore next: difficult to make a test case for */
        if (socket.destroyed) {
          return -1;
        }

        const request = client[kQueue][client[kRunningIdx]];

        /* istanbul ignore next: difficult to make a test case for */
        if (!request) {
          return -1;
        }

        assert(!this.upgrade);
        assert(this.statusCode < 200);

        if (statusCode === 100) {
          util.destroy(
            socket,
            new SocketError("bad response", util.getSocketInfo(socket))
          );
          return -1;
        }

        /* this can only happen if server is misbehaving */
        if (upgrade && !request.upgrade) {
          util.destroy(
            socket,
            new SocketError("bad upgrade", util.getSocketInfo(socket))
          );
          return -1;
        }

        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);

        this.statusCode = statusCode;
        this.shouldKeepAlive =
          shouldKeepAlive ||
          // Override llhttp value which does not allow keepAlive for HEAD.
          (request.method === "HEAD" &&
            !socket[kReset] &&
            this.connection.toLowerCase() === "keep-alive");

        if (this.statusCode >= 200) {
          const bodyTimeout =
            request.bodyTimeout != null
              ? request.bodyTimeout
              : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          // istanbul ignore else: only for jest
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }

        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }

        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }

        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;

        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive
            ? util.parseKeepAliveTimeout(this.keepAlive)
            : null;

          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          // Stop more requests from being dispatched.
          socket[kReset] = true;
        }

        const pause =
          request.onHeaders(statusCode, headers, this.resume, statusText) ===
          false;

        if (request.aborted) {
          return -1;
        }

        if (request.method === "HEAD") {
          return 1;
        }

        if (statusCode < 200) {
          return 1;
        }

        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }

        return pause ? constants.ERROR.PAUSED : 0;
      }

      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;

        if (socket.destroyed) {
          return -1;
        }

        const request = client[kQueue][client[kRunningIdx]];
        assert(request);

        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          // istanbul ignore else: only for jest
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }

        assert(statusCode >= 200);

        if (
          maxResponseSize > -1 &&
          this.bytesRead + buf.length > maxResponseSize
        ) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }

        this.bytesRead += buf.length;

        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }

      onMessageComplete() {
        const {
          client,
          socket,
          statusCode,
          upgrade,
          headers,
          contentLength,
          bytesRead,
          shouldKeepAlive,
        } = this;

        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }

        if (upgrade) {
          return;
        }

        const request = client[kQueue][client[kRunningIdx]];
        assert(request);

        assert(statusCode >= 100);

        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";

        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;

        if (statusCode < 200) {
          return;
        }

        /* istanbul ignore next: should be handled by llhttp? */
        if (
          request.method !== "HEAD" &&
          contentLength &&
          bytesRead !== parseInt(contentLength, 10)
        ) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }

        request.onComplete(headers);

        client[kQueue][client[kRunningIdx]++] = null;

        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          // Response completed before request.
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          // Destroy socket once all requests have completed.
          // The request at the tail of the pipeline is the one
          // that requested reset and no further requests should
          // have been queued since then.
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          // We must wait a full event loop cycle to reuse this socket to make sure
          // that non-spec compliant servers are not closing the connection even if they
          // said they won't.
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    }

    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;

      /* istanbul ignore else */
      if (timeoutType === TIMEOUT_HEADERS) {
        if (
          !socket[kWriting] ||
          socket.writableNeedDrain ||
          client[kRunning] > 1
        ) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }

    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }

    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;

      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");

      if (client[kHTTPConnVersion] !== "h2") {
        // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
        // to the user.
        if (
          err.code === "ECONNRESET" &&
          parser.statusCode &&
          !parser.shouldKeepAlive
        ) {
          // We treat all incoming data so for as a valid response.
          parser.onMessageComplete();
          return;
        }
      }

      this[kError] = err;

      onError(this[kClient], err);
    }

    function onError(client, err) {
      if (
        client[kRunning] === 0 &&
        err.code !== "UND_ERR_INFO" &&
        err.code !== "UND_ERR_SOCKET"
      ) {
        // Error is not caused by running request and not a recoverable
        // socket error.

        assert(client[kPendingIdx] === client[kRunningIdx]);

        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }

    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;

      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          // We treat all incoming data so far as a valid response.
          parser.onMessageComplete();
          return;
        }
      }

      util.destroy(
        this,
        new SocketError("other side closed", util.getSocketInfo(this))
      );
    }

    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;

      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          // We treat all incoming data so far as a valid response.
          parser.onMessageComplete();
        }

        this[kParser].destroy();
        this[kParser] = null;
      }

      const err =
        this[kError] || new SocketError("closed", util.getSocketInfo(this));

      client[kSocket] = null;

      if (client.destroyed) {
        assert(client[kPending] === 0);

        // Fail entire queue.
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        // Fail head of pipeline.
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;

        errorRequest(client, request, err);
      }

      client[kPendingIdx] = client[kRunningIdx];

      assert(client[kRunning] === 0);

      client.emit("disconnect", client[kUrl], [client], err);

      resume(client);
    }

    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);

      let { host, hostname, protocol, port } = client[kUrl];

      // Resolve ipv6
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");

        assert(idx !== -1);
        const ip = hostname.substring(1, idx);

        assert(net.isIP(ip));
        hostname = ip;
      }

      client[kConnecting] = true;

      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress],
          },
          connector: client[kConnector],
        });
      }

      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector](
            {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress],
            },
            (err, socket) => {
              if (err) {
                reject(err);
              } else {
                resolve(socket);
              }
            }
          );
        });

        if (client.destroyed) {
          util.destroy(
            socket.on("error", () => {}),
            new ClientDestroyedError()
          );
          return;
        }

        client[kConnecting] = false;

        assert(socket);

        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning(
              "H2 support is experimental, expect them to change at any time.",
              {
                code: "UNDICI-H2",
              }
            );
          }

          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams:
              client[kHTTP2SessionState].maxConcurrentStreams,
          });

          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();

          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }

          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }

        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;

        socket
          .on("error", onSocketError)
          .on("readable", onSocketReadable)
          .on("end", onSocketEnd)
          .on("close", onSocketClose);

        client[kSocket] = socket;

        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress],
            },
            connector: client[kConnector],
            socket,
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }

        client[kConnecting] = false;

        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress],
            },
            connector: client[kConnector],
            error: err,
          });
        }

        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (
            client[kPending] > 0 &&
            client[kQueue][client[kPendingIdx]].servername ===
              client[kServerName]
          ) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }

        client.emit("connectionError", client[kUrl], [client], err);
      }

      resume(client);
    }

    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }

    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }

      client[kResuming] = 2;

      _resume(client, sync);
      client[kResuming] = 0;

      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }

    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }

        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }

        const socket = client[kSocket];

        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }

          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(
                client[kKeepAliveTimeoutValue],
                TIMEOUT_IDLE
              );
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request = client[kQueue][client[kRunningIdx]];
              const headersTimeout =
                request.headersTimeout != null
                  ? request.headersTimeout
                  : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }

        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }

        if (client[kPending] === 0) {
          return;
        }

        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }

        const request = client[kQueue][client[kPendingIdx]];

        if (
          client[kUrl].protocol === "https:" &&
          client[kServerName] !== request.servername
        ) {
          if (client[kRunning] > 0) {
            return;
          }

          client[kServerName] = request.servername;

          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }

        if (client[kConnecting]) {
          return;
        }

        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }

        if (
          socket.destroyed ||
          socket[kWriting] ||
          socket[kReset] ||
          socket[kBlocking]
        ) {
          return;
        }

        if (client[kRunning] > 0 && !request.idempotent) {
          // Non-idempotent request cannot be retried.
          // Ensure that no other requests are inflight and
          // could cause failure.
          return;
        }

        if (
          client[kRunning] > 0 &&
          (request.upgrade || request.method === "CONNECT")
        ) {
          // Don't dispatch an upgrade until all preceding requests have completed.
          // A misbehaving server might upgrade the connection before all pipelined
          // request has completed.
          return;
        }

        if (
          client[kRunning] > 0 &&
          util.bodyLength(request.body) !== 0 &&
          (util.isStream(request.body) || util.isAsyncIterable(request.body))
        ) {
          // Request with stream or iterator body can error while other requests
          // are inflight and indirectly error those as well.
          // Ensure this doesn't happen by waiting for inflight
          // to complete before dispatching.

          // Request with stream or iterator body cannot be retried.
          // Ensure that no other requests are inflight and
          // could cause failure.
          return;
        }

        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }

    // https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
    function shouldSendContentLength(method) {
      return (
        method !== "GET" &&
        method !== "HEAD" &&
        method !== "OPTIONS" &&
        method !== "TRACE" &&
        method !== "CONNECT"
      );
    }

    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }

      const { body, method, path, host, upgrade, headers, blocking, reset } =
        request;

      // https://tools.ietf.org/html/rfc7231#section-4.3.1
      // https://tools.ietf.org/html/rfc7231#section-4.3.2
      // https://tools.ietf.org/html/rfc7231#section-4.3.5

      // Sending a payload body on a request that does not
      // expect it can cause undefined behavior on some
      // servers and corrupt connection state. Do not
      // re-use the connection for further requests.

      const expectsPayload =
        method === "PUT" || method === "POST" || method === "PATCH";

      if (body && typeof body.read === "function") {
        // Try to read EOF in order to get length.
        body.read(0);
      }

      const bodyLength = util.bodyLength(body);

      let contentLength = bodyLength;

      if (contentLength === null) {
        contentLength = request.contentLength;
      }

      if (contentLength === 0 && !expectsPayload) {
        // https://tools.ietf.org/html/rfc7230#section-3.3.2
        // A user agent SHOULD NOT send a Content-Length header field when
        // the request message does not contain a payload body and the method
        // semantics do not anticipate such a body.

        contentLength = null;
      }

      // https://github.com/nodejs/undici/issues/2046
      // A user agent may send a Content-Length header with 0 value, this should be allowed.
      if (
        shouldSendContentLength(method) &&
        contentLength > 0 &&
        request.contentLength !== null &&
        request.contentLength !== contentLength
      ) {
        if (client[kStrictContentLength]) {
          errorRequest(
            client,
            request,
            new RequestContentLengthMismatchError()
          );
          return false;
        }

        process.emitWarning(new RequestContentLengthMismatchError());
      }

      const socket = client[kSocket];

      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }

          errorRequest(client, request, err || new RequestAbortedError());

          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }

      if (request.aborted) {
        return false;
      }

      if (method === "HEAD") {
        // https://github.com/mcollina/undici/issues/258
        // Close after a HEAD request to interop with misbehaving servers
        // that may send a body in the response.

        socket[kReset] = true;
      }

      if (upgrade || method === "CONNECT") {
        // On CONNECT or upgrade, block pipeline from dispatching further
        // requests on this connection.

        socket[kReset] = true;
      }

      if (reset != null) {
        socket[kReset] = reset;
      }

      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }

      if (blocking) {
        socket[kBlocking] = true;
      }

      let header = `${method} ${path} HTTP/1.1\r\n`;

      if (typeof host === "string") {
        header += `host: ${host}\r\n`;
      } else {
        header += client[kHostHeader];
      }

      if (upgrade) {
        header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }

      if (headers) {
        header += headers;
      }

      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }

      /* istanbul ignore else: assertion */
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
        } else {
          assert(
            contentLength === null,
            "no body must not have content length"
          );
          socket.write(`${header}\r\n`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(
          contentLength === body.byteLength,
          "buffer body must have content length"
        );

        socket.cork();
        socket.write(
          `${header}content-length: ${contentLength}\r\n\r\n`,
          "latin1"
        );
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({
            body: body.stream(),
            client,
            request,
            socket,
            contentLength,
            header,
            expectsPayload,
          });
        } else {
          writeBlob({
            body,
            client,
            request,
            socket,
            contentLength,
            header,
            expectsPayload,
          });
        }
      } else if (util.isStream(body)) {
        writeStream({
          body,
          client,
          request,
          socket,
          contentLength,
          header,
          expectsPayload,
        });
      } else if (util.isIterable(body)) {
        writeIterable({
          body,
          client,
          request,
          socket,
          contentLength,
          header,
          expectsPayload,
        });
      } else {
        assert(false);
      }

      return true;
    }

    function writeH2(client, session, request) {
      const {
        body,
        method,
        path,
        host,
        upgrade,
        expectContinue,
        signal,
        headers: reqHeaders,
      } = request;

      let headers;
      if (typeof reqHeaders === "string")
        headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;

      if (upgrade) {
        errorRequest(
          client,
          request,
          new Error("Upgrade not supported for H2")
        );
        return false;
      }

      try {
        // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }

          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }

      if (request.aborted) {
        return false;
      }

      /** @type {import('node:http2').ClientHttp2Stream} */
      let stream;
      const h2State = client[kHTTP2SessionState];

      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;

      if (method === "CONNECT") {
        session.ref();
        // we are already connected, streams are pending, first request
        // will create a new stream. We trigger a request to create the stream and wait until
        // `ready` event is triggered
        // We disabled endStream to allow the user to write to the stream
        stream = session.request(headers, { endStream: false, signal });

        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }

        stream.once("close", () => {
          h2State.openStreams -= 1;
          // TODO(HTTP/2): unref only if current streams count is 0
          if (h2State.openStreams === 0) session.unref();
        });

        return true;
      }

      // https://tools.ietf.org/html/rfc7540#section-8.3
      // :path and :scheme headers must be omited when sending CONNECT

      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";

      // https://tools.ietf.org/html/rfc7231#section-4.3.1
      // https://tools.ietf.org/html/rfc7231#section-4.3.2
      // https://tools.ietf.org/html/rfc7231#section-4.3.5

      // Sending a payload body on a request that does not
      // expect it can cause undefined behavior on some
      // servers and corrupt connection state. Do not
      // re-use the connection for further requests.

      const expectsPayload =
        method === "PUT" || method === "POST" || method === "PATCH";

      if (body && typeof body.read === "function") {
        // Try to read EOF in order to get length.
        body.read(0);
      }

      let contentLength = util.bodyLength(body);

      if (contentLength == null) {
        contentLength = request.contentLength;
      }

      if (contentLength === 0 || !expectsPayload) {
        // https://tools.ietf.org/html/rfc7230#section-3.3.2
        // A user agent SHOULD NOT send a Content-Length header field when
        // the request message does not contain a payload body and the method
        // semantics do not anticipate such a body.

        contentLength = null;
      }

      // https://github.com/nodejs/undici/issues/2046
      // A user agent may send a Content-Length header with 0 value, this should be allowed.
      if (
        shouldSendContentLength(method) &&
        contentLength > 0 &&
        request.contentLength != null &&
        request.contentLength !== contentLength
      ) {
        if (client[kStrictContentLength]) {
          errorRequest(
            client,
            request,
            new RequestContentLengthMismatchError()
          );
          return false;
        }

        process.emitWarning(new RequestContentLengthMismatchError());
      }

      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }

      session.ref();

      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal,
        });

        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal,
        });
        writeBodyH2();
      }

      // Increment counter as we have new several streams open
      ++h2State.openStreams;

      stream.once("response", (headers) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;

        if (
          request.onHeaders(
            Number(statusCode),
            realHeaders,
            stream.resume.bind(stream),
            ""
          ) === false
        ) {
          stream.pause();
        }
      });

      stream.once("end", () => {
        request.onComplete([]);
      });

      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });

      stream.once("close", () => {
        h2State.openStreams -= 1;
        // TODO(HTTP/2): unref only if current streams count is 0
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });

      stream.once("error", function (err) {
        if (
          client[kHTTP2Session] &&
          !client[kHTTP2Session].destroyed &&
          !this.closed &&
          !this.destroyed
        ) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });

      stream.once("frameError", (type, code) => {
        const err = new InformationalError(
          `HTTP/2: "frameError" received - type ${type}, code ${code}`
        );
        errorRequest(client, request, err);

        if (
          client[kHTTP2Session] &&
          !client[kHTTP2Session].destroyed &&
          !this.closed &&
          !this.destroyed
        ) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });

      // stream.on('aborted', () => {
      //   // TODO(HTTP/2): Support aborted
      // })

      // stream.on('timeout', () => {
      //   // TODO(HTTP/2): Support timeout
      // })

      // stream.on('push', headers => {
      //   // TODO(HTTP/2): Suppor push
      // })

      // stream.on('trailers', headers => {
      //   // TODO(HTTP/2): Support trailers
      // })

      return true;

      function writeBodyH2() {
        /* istanbul ignore else: assertion */
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(
            contentLength === body.byteLength,
            "buffer body must have content length"
          );
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: "",
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket],
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: "",
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket],
          });
        } else {
          assert(false);
        }
      }
    }

    function writeStream({
      h2stream,
      body,
      client,
      request,
      socket,
      contentLength,
      header,
      expectsPayload,
    }) {
      assert(
        contentLength !== 0 || client[kRunning] === 0,
        "stream body cannot be pipelined"
      );

      if (client[kHTTPConnVersion] === "h2") {
        // For HTTP/2, is enough to pipe the stream
        const pipe = pipeline(body, h2stream, (err) => {
          if (err) {
            util.destroy(body, err);
            util.destroy(h2stream, err);
          } else {
            request.onRequestSent();
          }
        });

        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });

        function onPipeData(chunk) {
          request.onBodySent(chunk);
        }

        return;
      }

      let finished = false;

      const writer = new AsyncWriter({
        socket,
        request,
        contentLength,
        client,
        expectsPayload,
        header,
      });

      const onData = function (chunk) {
        if (finished) {
          return;
        }

        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function () {
        if (finished) {
          return;
        }

        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function () {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function (err) {
        if (finished) {
          return;
        }

        finished = true;

        assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1));

        socket.off("drain", onDrain).off("error", onFinished);

        body
          .removeListener("data", onData)
          .removeListener("end", onFinished)
          .removeListener("error", onFinished)
          .removeListener("close", onAbort);

        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }

        writer.destroy(err);

        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };

      body
        .on("data", onData)
        .on("end", onFinished)
        .on("error", onFinished)
        .on("close", onAbort);

      if (body.resume) {
        body.resume();
      }

      socket.on("drain", onDrain).on("error", onFinished);
    }

    async function writeBlob({
      h2stream,
      body,
      client,
      request,
      socket,
      contentLength,
      header,
      expectsPayload,
    }) {
      assert(contentLength === body.size, "blob body must have content length");

      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }

        const buffer = Buffer.from(await body.arrayBuffer());

        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(
            `${header}content-length: ${contentLength}\r\n\r\n`,
            "latin1"
          );
          socket.write(buffer);
          socket.uncork();
        }

        request.onBodySent(buffer);
        request.onRequestSent();

        if (!expectsPayload) {
          socket[kReset] = true;
        }

        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }

    async function writeIterable({
      h2stream,
      body,
      client,
      request,
      socket,
      contentLength,
      header,
      expectsPayload,
    }) {
      assert(
        contentLength !== 0 || client[kRunning] === 0,
        "iterator body cannot be pipelined"
      );

      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }

      const waitForDrain = () =>
        new Promise((resolve, reject) => {
          assert(callback === null);

          if (socket[kError]) {
            reject(socket[kError]);
          } else {
            callback = resolve;
          }
        });

      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);

        try {
          // It's up to the user to somehow abort the async iterable.
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }

            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }

        return;
      }

      socket.on("close", onDrain).on("drain", onDrain);

      const writer = new AsyncWriter({
        socket,
        request,
        contentLength,
        client,
        expectsPayload,
        header,
      });
      try {
        // It's up to the user to somehow abort the async iterable.
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }

          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }

        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }

    class AsyncWriter {
      constructor({
        socket,
        request,
        contentLength,
        client,
        expectsPayload,
        header,
      }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;

        socket[kWriting] = true;
      }

      write(chunk) {
        const {
          socket,
          request,
          contentLength,
          client,
          bytesWritten,
          expectsPayload,
          header,
        } = this;

        if (socket[kError]) {
          throw socket[kError];
        }

        if (socket.destroyed) {
          return false;
        }

        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }

        // We should defer writing chunks.
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }

          process.emitWarning(new RequestContentLengthMismatchError());
        }

        socket.cork();

        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }

          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
          } else {
            socket.write(
              `${header}content-length: ${contentLength}\r\n\r\n`,
              "latin1"
            );
          }
        }

        if (contentLength === null) {
          socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
        }

        this.bytesWritten += len;

        const ret = socket.write(chunk);

        socket.uncork();

        request.onBodySent(chunk);

        if (!ret) {
          if (
            socket[kParser].timeout &&
            socket[kParser].timeoutType === TIMEOUT_HEADERS
          ) {
            // istanbul ignore else: only for jest
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }

        return ret;
      }

      end() {
        const {
          socket,
          contentLength,
          client,
          bytesWritten,
          expectsPayload,
          header,
          request,
        } = this;
        request.onRequestSent();

        socket[kWriting] = false;

        if (socket[kError]) {
          throw socket[kError];
        }

        if (socket.destroyed) {
          return;
        }

        if (bytesWritten === 0) {
          if (expectsPayload) {
            // https://tools.ietf.org/html/rfc7230#section-3.3.2
            // A user agent SHOULD send a Content-Length in a request message when
            // no Transfer-Encoding is sent and the request method defines a meaning
            // for an enclosed payload body.

            socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
          } else {
            socket.write(`${header}\r\n`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }

        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }

        if (
          socket[kParser].timeout &&
          socket[kParser].timeoutType === TIMEOUT_HEADERS
        ) {
          // istanbul ignore else: only for jest
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }

        resume(client);
      }

      destroy(err) {
        const { socket, client } = this;

        socket[kWriting] = false;

        if (err) {
          assert(
            client[kRunning] <= 1,
            "pipeline should only contain this request"
          );
          util.destroy(socket, err);
        }
      }
    }

    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err) {
        client.emit("error", err);
      }
    }

    module.exports = Client;

    /***/
  },

  /***/ 6436: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /* istanbul ignore file: only for Node 12 */

    const { kConnected, kSize } = __nccwpck_require__(2785);

    class CompatWeakRef {
      constructor(value) {
        this.value = value;
      }

      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0
          ? undefined
          : this.value;
      }
    }

    class CompatFinalizer {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }

      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    }

    module.exports = function () {
      // FIXME: remove workaround when the Node bug is fixed
      // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer,
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer,
      };
    };

    /***/
  },

  /***/ 663: /***/ (module) => {
    // https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size
    const maxAttributeValueSize = 1024;

    // https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size
    const maxNameValuePairSize = 4096;

    module.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize,
    };

    /***/
  },

  /***/ 1724: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { parseSetCookie } = __nccwpck_require__(4408);
    const { stringify, getHeadersList } = __nccwpck_require__(3121);
    const { webidl } = __nccwpck_require__(1744);
    const { Headers } = __nccwpck_require__(554);

    /**
     * @typedef {Object} Cookie
     * @property {string} name
     * @property {string} value
     * @property {Date|number|undefined} expires
     * @property {number|undefined} maxAge
     * @property {string|undefined} domain
     * @property {string|undefined} path
     * @property {boolean|undefined} secure
     * @property {boolean|undefined} httpOnly
     * @property {'Strict'|'Lax'|'None'} sameSite
     * @property {string[]} unparsed
     */

    /**
     * @param {Headers} headers
     * @returns {Record<string, string>}
     */
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });

      webidl.brandCheck(headers, Headers, { strict: false });

      const cookie = headers.get("cookie");
      const out = {};

      if (!cookie) {
        return out;
      }

      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");

        out[name.trim()] = value.join("=");
      }

      return out;
    }

    /**
     * @param {Headers} headers
     * @param {string} name
     * @param {{ path?: string, domain?: string }|undefined} attributes
     * @returns {void}
     */
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });

      webidl.brandCheck(headers, Headers, { strict: false });

      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);

      // Matches behavior of
      // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278
      setCookie(headers, {
        name,
        value: "",
        expires: new Date(0),
        ...attributes,
      });
    }

    /**
     * @param {Headers} headers
     * @returns {Cookie[]}
     */
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });

      webidl.brandCheck(headers, Headers, { strict: false });

      const cookies = getHeadersList(headers).cookies;

      if (!cookies) {
        return [];
      }

      // In older versions of undici, cookies is a list of name:value.
      return cookies.map((pair) =>
        parseSetCookie(Array.isArray(pair) ? pair[1] : pair)
      );
    }

    /**
     * @param {Headers} headers
     * @param {Cookie} cookie
     * @returns {void}
     */
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });

      webidl.brandCheck(headers, Headers, { strict: false });

      cookie = webidl.converters.Cookie(cookie);

      const str = stringify(cookie);

      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }

    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null,
      },
    ]);

    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name",
      },
      {
        converter: webidl.converters.DOMString,
        key: "value",
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }

          return new Date(value);
        }),
        key: "expires",
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null,
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"],
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: [],
      },
    ]);

    module.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie,
    };

    /***/
  },

  /***/ 4408: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { maxNameValuePairSize, maxAttributeValueSize } =
      __nccwpck_require__(663);
    const { isCTLExcludingHtab } = __nccwpck_require__(3121);
    const { collectASequenceOfCodePointsFast } = __nccwpck_require__(685);
    const assert = __nccwpck_require__(9491);

    /**
     * @description Parses the field-value attributes of a set-cookie header string.
     * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
     * @param {string} header
     * @returns if the header is invalid, null will be returned
     */
    function parseSetCookie(header) {
      // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F
      //    character (CTL characters excluding HTAB): Abort these steps and
      //    ignore the set-cookie-string entirely.
      if (isCTLExcludingHtab(header)) {
        return null;
      }

      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";

      // 2. If the set-cookie-string contains a %x3B (";") character:
      if (header.includes(";")) {
        // 1. The name-value-pair string consists of the characters up to,
        //    but not including, the first %x3B (";"), and the unparsed-
        //    attributes consist of the remainder of the set-cookie-string
        //    (including the %x3B (";") in question).
        const position = { position: 0 };

        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        // Otherwise:

        // 1. The name-value-pair string consists of all the characters
        //    contained in the set-cookie-string, and the unparsed-
        //    attributes is the empty string.
        nameValuePair = header;
      }

      // 3. If the name-value-pair string lacks a %x3D ("=") character, then
      //    the name string is empty, and the value string is the value of
      //    name-value-pair.
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        //    Otherwise, the name string consists of the characters up to, but
        //    not including, the first %x3D ("=") character, and the (possibly
        //    empty) value string consists of the characters after the first
        //    %x3D ("=") character.
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
        value = nameValuePair.slice(position.position + 1);
      }

      // 4. Remove any leading or trailing WSP characters from the name
      //    string and the value string.
      name = name.trim();
      value = value.trim();

      // 5. If the sum of the lengths of the name string and the value string
      //    is more than 4096 octets, abort these steps and ignore the set-
      //    cookie-string entirely.
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }

      // 6. The cookie-name is the name string, and the cookie-value is the
      //    value string.
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes),
      };
    }

    /**
     * Parses the remaining attributes of a set-cookie header
     * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
     * @param {string} unparsedAttributes
     * @param {[Object.<string, unknown>]={}} cookieAttributeList
     */
    function parseUnparsedAttributes(
      unparsedAttributes,
      cookieAttributeList = {}
    ) {
      // 1. If the unparsed-attributes string is empty, skip the rest of
      //    these steps.
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }

      // 2. Discard the first character of the unparsed-attributes (which
      //    will be a %x3B (";") character).
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);

      let cookieAv = "";

      // 3. If the remaining unparsed-attributes contains a %x3B (";")
      //    character:
      if (unparsedAttributes.includes(";")) {
        // 1. Consume the characters of the unparsed-attributes up to, but
        //    not including, the first %x3B (";") character.
        cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, {
          position: 0,
        });
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        // Otherwise:

        // 1. Consume the remainder of the unparsed-attributes.
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }

      // Let the cookie-av string be the characters consumed in this step.

      let attributeName = "";
      let attributeValue = "";

      // 4. If the cookie-av string contains a %x3D ("=") character:
      if (cookieAv.includes("=")) {
        // 1. The (possibly empty) attribute-name string consists of the
        //    characters up to, but not including, the first %x3D ("=")
        //    character, and the (possibly empty) attribute-value string
        //    consists of the characters after the first %x3D ("=")
        //    character.
        const position = { position: 0 };

        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        // Otherwise:

        // 1. The attribute-name string consists of the entire cookie-av
        //    string, and the attribute-value string is empty.
        attributeName = cookieAv;
      }

      // 5. Remove any leading or trailing WSP characters from the attribute-
      //    name string and the attribute-value string.
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();

      // 6. If the attribute-value is longer than 1024 octets, ignore the
      //    cookie-av string and return to Step 1 of this algorithm.
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }

      // 7. Process the attribute-name and attribute-value according to the
      //    requirements in the following subsections.  (Notice that
      //    attributes with unrecognized attribute-names are ignored.)
      const attributeNameLowercase = attributeName.toLowerCase();

      // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1
      // If the attribute-name case-insensitively matches the string
      // "Expires", the user agent MUST process the cookie-av as follows.
      if (attributeNameLowercase === "expires") {
        // 1. Let the expiry-time be the result of parsing the attribute-value
        //    as cookie-date (see Section 5.1.1).
        const expiryTime = new Date(attributeValue);

        // 2. If the attribute-value failed to parse as a cookie date, ignore
        //    the cookie-av.

        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2
        // If the attribute-name case-insensitively matches the string "Max-
        // Age", the user agent MUST process the cookie-av as follows.

        // 1. If the first character of the attribute-value is not a DIGIT or a
        //    "-" character, ignore the cookie-av.
        const charCode = attributeValue.charCodeAt(0);

        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(
            unparsedAttributes,
            cookieAttributeList
          );
        }

        // 2. If the remainder of attribute-value contains a non-DIGIT
        //    character, ignore the cookie-av.
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(
            unparsedAttributes,
            cookieAttributeList
          );
        }

        // 3. Let delta-seconds be the attribute-value converted to an integer.
        const deltaSeconds = Number(attributeValue);

        // 4. Let cookie-age-limit be the maximum age of the cookie (which
        //    SHOULD be 400 days or less, see Section 4.1.2.2).

        // 5. Set delta-seconds to the smaller of its present value and cookie-
        //    age-limit.
        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)

        // 6. If delta-seconds is less than or equal to zero (0), let expiry-
        //    time be the earliest representable date and time.  Otherwise, let
        //    the expiry-time be the current date and time plus delta-seconds
        //    seconds.
        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds

        // 7. Append an attribute to the cookie-attribute-list with an
        //    attribute-name of Max-Age and an attribute-value of expiry-time.
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3
        // If the attribute-name case-insensitively matches the string "Domain",
        // the user agent MUST process the cookie-av as follows.

        // 1. Let cookie-domain be the attribute-value.
        let cookieDomain = attributeValue;

        // 2. If cookie-domain starts with %x2E ("."), let cookie-domain be
        //    cookie-domain without its leading %x2E (".").
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }

        // 3. Convert the cookie-domain to lower case.
        cookieDomain = cookieDomain.toLowerCase();

        // 4. Append an attribute to the cookie-attribute-list with an
        //    attribute-name of Domain and an attribute-value of cookie-domain.
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4
        // If the attribute-name case-insensitively matches the string "Path",
        // the user agent MUST process the cookie-av as follows.

        // 1. If the attribute-value is empty or if the first character of the
        //    attribute-value is not %x2F ("/"):
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          // 1. Let cookie-path be the default-path.
          cookiePath = "/";
        } else {
          // Otherwise:

          // 1. Let cookie-path be the attribute-value.
          cookiePath = attributeValue;
        }

        // 2. Append an attribute to the cookie-attribute-list with an
        //    attribute-name of Path and an attribute-value of cookie-path.
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5
        // If the attribute-name case-insensitively matches the string "Secure",
        // the user agent MUST append an attribute to the cookie-attribute-list
        // with an attribute-name of Secure and an empty attribute-value.

        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6
        // If the attribute-name case-insensitively matches the string
        // "HttpOnly", the user agent MUST append an attribute to the cookie-
        // attribute-list with an attribute-name of HttpOnly and an empty
        // attribute-value.

        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7
        // If the attribute-name case-insensitively matches the string
        // "SameSite", the user agent MUST process the cookie-av as follows:

        // 1. Let enforcement be "Default".
        let enforcement = "Default";

        const attributeValueLowercase = attributeValue.toLowerCase();
        // 2. If cookie-av's attribute-value is a case-insensitive match for
        //    "None", set enforcement to "None".
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }

        // 3. If cookie-av's attribute-value is a case-insensitive match for
        //    "Strict", set enforcement to "Strict".
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }

        // 4. If cookie-av's attribute-value is a case-insensitive match for
        //    "Lax", set enforcement to "Lax".
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }

        // 5. Append an attribute to the cookie-attribute-list with an
        //    attribute-name of "SameSite" and an attribute-value of
        //    enforcement.
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];

        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }

      // 8. Return to Step 1 of this algorithm.
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }

    module.exports = {
      parseSetCookie,
      parseUnparsedAttributes,
    };

    /***/
  },

  /***/ 3121: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const assert = __nccwpck_require__(9491);
    const { kHeadersList } = __nccwpck_require__(2785);

    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }

      for (const char of value) {
        const code = char.charCodeAt(0);

        if (
          code >= 0x00 ||
          code <= 0x08 ||
          code >= 0x0a ||
          code <= 0x1f ||
          code === 0x7f
        ) {
          return false;
        }
      }
    }

    /**
 CHAR           = <any US-ASCII character (octets 0 - 127)>
 token          = 1*<any CHAR except CTLs or separators>
 separators     = "(" | ")" | "<" | ">" | "@"
                | "," | ";" | ":" | "\" | <">
                | "/" | "[" | "]" | "?" | "="
                | "{" | "}" | SP | HT
 * @param {string} name
 */
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);

        if (
          code <= 0x20 ||
          code > 0x7f ||
          char === "(" ||
          char === ")" ||
          char === ">" ||
          char === "<" ||
          char === "@" ||
          char === "," ||
          char === ";" ||
          char === ":" ||
          char === "\\" ||
          char === '"' ||
          char === "/" ||
          char === "[" ||
          char === "]" ||
          char === "?" ||
          char === "=" ||
          char === "{" ||
          char === "}"
        ) {
          throw new Error("Invalid cookie name");
        }
      }
    }

    /**
 cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
                       ; US-ASCII characters excluding CTLs,
                       ; whitespace DQUOTE, comma, semicolon,
                       ; and backslash
 * @param {string} value
 */
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);

        if (
          code < 0x21 || // exclude CTLs (0-31)
          code === 0x22 ||
          code === 0x2c ||
          code === 0x3b ||
          code === 0x5c ||
          code > 0x7e // non-ascii
        ) {
          throw new Error("Invalid header value");
        }
      }
    }

    /**
     * path-value        = <any CHAR except CTLs or ";">
     * @param {string} path
     */
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);

        if (code < 0x21 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }

    /**
     * I have no idea why these values aren't allowed to be honest,
     * but Deno tests these. - Khafra
     * @param {string} domain
     */
    function validateCookieDomain(domain) {
      if (
        domain.startsWith("-") ||
        domain.endsWith(".") ||
        domain.endsWith("-")
      ) {
        throw new Error("Invalid cookie domain");
      }
    }

    /**
 * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
 * @param {number|Date} date
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
              / %x54.75.65 ; "Tue", case-sensitive
              / %x57.65.64 ; "Wed", case-sensitive
              / %x54.68.75 ; "Thu", case-sensitive
              / %x46.72.69 ; "Fri", case-sensitive
              / %x53.61.74 ; "Sat", case-sensitive
              / %x53.75.6E ; "Sun", case-sensitive
  date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %x4A.61.6E ; "Jan", case-sensitive
              / %x46.65.62 ; "Feb", case-sensitive
              / %x4D.61.72 ; "Mar", case-sensitive
              / %x41.70.72 ; "Apr", case-sensitive
              / %x4D.61.79 ; "May", case-sensitive
              / %x4A.75.6E ; "Jun", case-sensitive
              / %x4A.75.6C ; "Jul", case-sensitive
              / %x41.75.67 ; "Aug", case-sensitive
              / %x53.65.70 ; "Sep", case-sensitive
              / %x4F.63.74 ; "Oct", case-sensitive
              / %x4E.6F.76 ; "Nov", case-sensitive
              / %x44.65.63 ; "Dec", case-sensitive
  year         = 4DIGIT

  GMT          = %x47.4D.54 ; "GMT", case-sensitive

  time-of-day  = hour ":" minute ":" second
              ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT
 */
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }

      const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ];

      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");

      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }

    /**
 max-age-av        = "Max-Age=" non-zero-digit *DIGIT
                       ; In practice, both expires-av and max-age-av
                       ; are limited to dates representable by the
                       ; user agent.
 * @param {number} maxAge
 */
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }

    /**
     * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
     * @param {import('./index').Cookie} cookie
     */
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }

      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);

      const out = [`${cookie.name}=${cookie.value}`];

      // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1
      // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }

      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }

      if (cookie.secure) {
        out.push("Secure");
      }

      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }

      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }

      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }

      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }

      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }

      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }

      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }

        const [key, ...value] = part.split("=");

        out.push(`${key.trim()}=${value.join("=")}`);
      }

      return out.join("; ");
    }

    let kHeadersListNode;

    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }

      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === "headers list"
        );

        assert(kHeadersListNode, "Headers cannot be parsed");
      }

      const headersList = headers[kHeadersListNode];
      assert(headersList);

      return headersList;
    }

    module.exports = {
      isCTLExcludingHtab,
      stringify,
      getHeadersList,
    };

    /***/
  },

  /***/ 2067: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const net = __nccwpck_require__(1808);
    const assert = __nccwpck_require__(9491);
    const util = __nccwpck_require__(3983);
    const { InvalidArgumentError, ConnectTimeoutError } =
      __nccwpck_require__(8045);

    let tls; // include tls conditionally since it is not always available

    // TODO: session re-use does not wait for the first
    // connection to resolve the session and might therefore
    // resolve the same servername multiple times even when
    // re-use is enabled.

    let SessionCache;
    // FIXME: remove workaround when the Node bug is fixed
    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }

            const ref = this._sessionCache.get(key);
            if (ref !== undefined && ref.deref() === undefined) {
              this._sessionCache.delete(key);
            }
          });
        }

        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }

        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }

          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = new Map();
        }

        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }

        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }

          if (this._sessionCache.size >= this._maxCachedSessions) {
            // remove the oldest session
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }

          this._sessionCache.set(sessionKey, session);
        }
      };
    }

    function buildConnector({
      allowH2,
      maxCachedSessions,
      socketPath,
      timeout,
      ...opts
    }) {
      if (
        maxCachedSessions != null &&
        (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)
      ) {
        throw new InvalidArgumentError(
          "maxCachedSessions must be a positive integer or zero"
        );
      }

      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(
        maxCachedSessions == null ? 100 : maxCachedSessions
      );
      timeout = timeout == null ? 10e3 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect(
        {
          hostname,
          host,
          protocol,
          port,
          servername,
          localAddress,
          httpSocket,
        },
        callback
      ) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = __nccwpck_require__(4404);
          }
          servername =
            servername ||
            options.servername ||
            util.getServerName(host) ||
            null;

          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;

          assert(sessionKey);

          socket = tls.connect({
            highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket, // upgrade socket connection
            port: port || 443,
            host: hostname,
          });

          socket.on("session", function (session) {
            // TODO (fix): Can a session become invalid once established? Don't think so?
            sessionCache.set(sessionKey, session);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024, // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname,
          });
        }

        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay =
            options.keepAliveInitialDelay === undefined
              ? 60e3
              : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }

        const cancelTimeout = setupTimeout(
          () => onConnectTimeout(socket),
          timeout
        );

        socket
          .setNoDelay(true)
          .once(
            protocol === "https:" ? "secureConnect" : "connect",
            function () {
              cancelTimeout();

              if (callback) {
                const cb = callback;
                callback = null;
                cb(null, this);
              }
            }
          )
          .on("error", function (err) {
            cancelTimeout();

            if (callback) {
              const cb = callback;
              callback = null;
              cb(err);
            }
          });

        return socket;
      };
    }

    function setupTimeout(onConnectTimeout, timeout) {
      if (!timeout) {
        return () => {};
      }

      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        // setImmediate is added to make sure that we priotorise socket error events over timeouts
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            // Windows needs an extra setImmediate probably due to implementation differences in the socket logic
            s2 = setImmediate(() => onConnectTimeout());
          } else {
            onConnectTimeout();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }

    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }

    module.exports = buildConnector;

    /***/
  },

  /***/ 4462: /***/ (module) => {
    /** @type {Record<string, string | undefined>} */
    const headerNameLowerCasedRecord = {};

    // https://developer.mozilla.org/docs/Web/HTTP/Headers
    const wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection",
    ];

    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[
        lowerCasedKey
      ] = lowerCasedKey;
    }

    // Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);

    module.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord,
    };

    /***/
  },

  /***/ 8045: /***/ (module) => {
    class UndiciError extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    }

    class ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    }

    class HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    }

    class HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    }

    class BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    }

    class ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    }

    class InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    }

    class InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    }

    class RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    }

    class InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    }

    class RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message =
          message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    }

    class ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message =
          message ||
          "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    }

    class ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    }

    class ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    }

    class SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    }

    class NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    }

    class BalancedPoolMissingUpstreamError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message =
          message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    }

    class HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : undefined;
        this.data = data ? data.toString() : undefined;
      }
    }

    class ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    }

    class RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    }

    module.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError,
    };

    /***/
  },

  /***/ 2905: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { InvalidArgumentError, NotSupportedError } =
      __nccwpck_require__(8045);
    const assert = __nccwpck_require__(9491);
    const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } =
      __nccwpck_require__(2785);
    const util = __nccwpck_require__(3983);

    // tokenRegExp and headerCharRegex have been lifted from
    // https://github.com/nodejs/node/blob/main/lib/_http_common.js

    /**
     * Verifies that the given val is a valid HTTP token
     * per the rules defined in RFC 7230
     * See https://tools.ietf.org/html/rfc7230#section-3.2.6
     */
    const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;

    /**
     * Matches if val contains an invalid field-vchar
     *  field-value    = *( field-content / obs-fold )
     *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     *  field-vchar    = VCHAR / obs-text
     */
    const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

    // Verifies that a given path is valid does not contain control chars \x00 to \x20
    const invalidPathRegex = /[^\u0021-\u00ff]/;

    const kHandler = Symbol("handler");

    const channels = {};

    let extractBody;

    try {
      const diagnosticsChannel = __nccwpck_require__(7643);
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }

    class Request {
      constructor(
        origin,
        {
          path,
          method,
          body,
          headers,
          query,
          idempotent,
          blocking,
          upgrade,
          headersTimeout,
          bodyTimeout,
          reset,
          throwOnError,
          expectContinue,
        },
        handler
      ) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (
          path[0] !== "/" &&
          !(path.startsWith("http://") || path.startsWith("https://")) &&
          method !== "CONNECT"
        ) {
          throw new InvalidArgumentError(
            "path must be an absolute URL or start with a slash"
          );
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }

        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }

        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }

        if (
          headersTimeout != null &&
          (!Number.isFinite(headersTimeout) || headersTimeout < 0)
        ) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }

        if (
          bodyTimeout != null &&
          (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)
        ) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }

        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }

        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }

        this.headersTimeout = headersTimeout;

        this.bodyTimeout = bodyTimeout;

        this.throwOnError = throwOnError === true;

        this.method = method;

        this.abort = null;

        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;

          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }

          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength
            ? Buffer.from(body.buffer, body.byteOffset, body.byteLength)
            : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (
          util.isFormDataLike(body) ||
          util.isIterable(body) ||
          util.isBlobLike(body)
        ) {
          this.body = body;
        } else {
          throw new InvalidArgumentError(
            "body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable"
          );
        }

        this.completed = false;

        this.aborted = false;

        this.upgrade = upgrade || null;

        this.path = query ? util.buildURL(path, query) : path;

        this.origin = origin;

        this.idempotent =
          idempotent == null
            ? method === "HEAD" || method === "GET"
            : idempotent;

        this.blocking = blocking == null ? false : blocking;

        this.reset = reset == null ? null : reset;

        this.host = null;

        this.contentLength = null;

        this.contentType = null;

        this.headers = "";

        // Only for H2
        this.expectContinue = expectContinue != null ? expectContinue : false;

        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError(
            "headers must be an object or an array"
          );
        }

        if (util.isFormDataLike(this.body)) {
          if (
            util.nodeMajor < 16 ||
            (util.nodeMajor === 16 && util.nodeMinor < 8)
          ) {
            throw new InvalidArgumentError(
              "Form-Data bodies are only supported in node v16.8 and newer."
            );
          }

          if (!extractBody) {
            extractBody = __nccwpck_require__(1472).extractBody;
          }

          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r\n`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (
          util.isBlobLike(body) &&
          this.contentType == null &&
          body.type
        ) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r\n`;
        }

        util.validateHandler(handler, method, upgrade);

        this.servername = util.getServerName(this.host);

        this[kHandler] = handler;

        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }

      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }

      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }

        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }

      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);

        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }

      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);

        if (channels.headers.hasSubscribers) {
          channels.headers.publish({
            request: this,
            response: { statusCode, headers, statusText },
          });
        }

        try {
          return this[kHandler].onHeaders(
            statusCode,
            headers,
            resume,
            statusText
          );
        } catch (err) {
          this.abort(err);
        }
      }

      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);

        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }

      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);

        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }

      onComplete(trailers) {
        this.onFinally();

        assert(!this.aborted);

        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }

        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          // TODO (fix): This might be a bad idea?
          this.onError(err);
        }
      }

      onError(error) {
        this.onFinally();

        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }

        if (this.aborted) {
          return;
        }
        this.aborted = true;

        return this[kHandler].onError(error);
      }

      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }

        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }

      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }

      static [kHTTP1BuildRequest](origin, opts, handler) {
        // TODO: Migrate header parsing here, to make Requests
        // HTTP agnostic
        return new Request(origin, opts, handler);
      }

      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };

        const request = new Request(origin, opts, handler);

        request.headers = {};

        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError(
            "headers must be an object or an array"
          );
        }

        return request;
      }

      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};

        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");

          if (value == null || value.length === 0) continue;

          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }

        return headers;
      }
    }

    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }

      val = val != null ? `${val}` : "";

      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }

      return skipAppend ? val : `${key}: ${val}\r\n`;
    }

    function processHeader(request, key, val, skipAppend = false) {
      if (val && typeof val === "object" && !Array.isArray(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === undefined) {
        return;
      }

      if (
        request.host === null &&
        key.length === 4 &&
        key.toLowerCase() === "host"
      ) {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        // Consumed by Client
        request.host = val;
      } else if (
        request.contentLength === null &&
        key.length === 14 &&
        key.toLowerCase() === "content-length"
      ) {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (
        request.contentType === null &&
        key.length === 12 &&
        key.toLowerCase() === "content-type"
      ) {
        request.contentType = val;
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (
        key.length === 17 &&
        key.toLowerCase() === "transfer-encoding"
      ) {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key])
                request.headers[key] +=
                  `,${processHeaderValue(key, val[i], skipAppend)}`;
              else
                request.headers[key] = processHeaderValue(
                  key,
                  val[i],
                  skipAppend
                );
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend)
            request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }

    module.exports = Request;

    /***/
  },

  /***/ 2785: /***/ (module) => {
    module.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable"),
    };

    /***/
  },

  /***/ 3983: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const assert = __nccwpck_require__(9491);
    const { kDestroyed, kBodyUsed } = __nccwpck_require__(2785);
    const { IncomingMessage } = __nccwpck_require__(3685);
    const stream = __nccwpck_require__(2781);
    const net = __nccwpck_require__(1808);
    const { InvalidArgumentError } = __nccwpck_require__(8045);
    const { Blob } = __nccwpck_require__(4300);
    const nodeUtil = __nccwpck_require__(3837);
    const { stringify } = __nccwpck_require__(3477);
    const { headerNameLowerCasedRecord } = __nccwpck_require__(4462);

    const [nodeMajor, nodeMinor] = process.versions.node
      .split(".")
      .map((v) => Number(v));

    function nop() {}

    function isStream(obj) {
      return (
        obj &&
        typeof obj === "object" &&
        typeof obj.pipe === "function" &&
        typeof obj.on === "function"
      );
    }

    // based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
    function isBlobLike(object) {
      return (
        (Blob && object instanceof Blob) ||
        (object &&
          typeof object === "object" &&
          (typeof object.stream === "function" ||
            typeof object.arrayBuffer === "function") &&
          /^(Blob|File)$/.test(object[Symbol.toStringTag]))
      );
    }

    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error(
          'Query params cannot be passed when url already contains "?" or "#".'
        );
      }

      const stringified = stringify(queryParams);

      if (stringified) {
        url += "?" + stringified;
      }

      return url;
    }

    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);

        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError(
            "Invalid URL protocol: the URL must start with `http:` or `https:`."
          );
        }

        return url;
      }

      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError(
          "Invalid URL: The URL argument must be a non-null object."
        );
      }

      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError(
          "Invalid URL protocol: the URL must start with `http:` or `https:`."
        );
      }

      if (!(url instanceof URL)) {
        if (
          url.port != null &&
          url.port !== "" &&
          !Number.isFinite(parseInt(url.port))
        ) {
          throw new InvalidArgumentError(
            "Invalid URL: port must be a valid integer or a string representation of an integer."
          );
        }

        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError(
            "Invalid URL path: the path must be a string or null/undefined."
          );
        }

        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError(
            "Invalid URL pathname: the pathname must be a string or null/undefined."
          );
        }

        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError(
            "Invalid URL hostname: the hostname must be a string or null/undefined."
          );
        }

        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError(
            "Invalid URL origin: the origin must be a string or null/undefined."
          );
        }

        const port =
          url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin =
          url.origin != null
            ? url.origin
            : `${url.protocol}//${url.hostname}:${port}`;
        let path =
          url.path != null
            ? url.path
            : `${url.pathname || ""}${url.search || ""}`;

        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }

        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        // new URL(path, origin) is unsafe when `path` contains an absolute URL
        // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:
        // If first parameter is a relative URL, second param is required, and will be used as the base URL.
        // If first parameter is an absolute URL, a given second param will be ignored.
        url = new URL(origin + path);
      }

      return url;
    }

    function parseOrigin(url) {
      url = parseURL(url);

      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }

      return url;
    }

    function getHostname(host) {
      if (host[0] === "[") {
        const idx = host.indexOf("]");

        assert(idx !== -1);
        return host.substring(1, idx);
      }

      const idx = host.indexOf(":");
      if (idx === -1) return host;

      return host.substring(0, idx);
    }

    // IP addresses are not valid server names per RFC6066
    // > Currently, the only server names supported are DNS hostnames
    function getServerName(host) {
      if (!host) {
        return null;
      }

      assert.strictEqual(typeof host, "string");

      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }

      return servername;
    }

    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }

    function isIterable(obj) {
      return !!(
        obj != null &&
        (typeof obj[Symbol.iterator] === "function" ||
          typeof obj[Symbol.asyncIterator] === "function")
      );
    }

    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state &&
          state.objectMode === false &&
          state.ended === true &&
          Number.isFinite(state.length)
          ? state.length
          : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }

      return null;
    }

    function isDestroyed(stream) {
      return !stream || !!(stream.destroyed || stream[kDestroyed]);
    }

    function isReadableAborted(stream) {
      const state = stream && stream._readableState;
      return isDestroyed(stream) && state && !state.endEmitted;
    }

    function destroy(stream, err) {
      if (stream == null || !isStream(stream) || isDestroyed(stream)) {
        return;
      }

      if (typeof stream.destroy === "function") {
        if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
          // See: https://github.com/nodejs/node/pull/38505/files
          stream.socket = null;
        }

        stream.destroy(err);
      } else if (err) {
        process.nextTick(
          (stream, err) => {
            stream.emit("error", err);
          },
          stream,
          err
        );
      }

      if (stream.destroyed !== true) {
        stream[kDestroyed] = true;
      }
    }

    const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1000 : null;
    }

    /**
     * Retrieves a header name and returns its lowercase value.
     * @param {string | Buffer} value Header name
     * @returns {string}
     */
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }

    function parseHeaders(headers, obj = {}) {
      // For H2 support
      if (!Array.isArray(headers)) return headers;

      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];

        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }

      // See https://github.com/nodejs/node/pull/46528
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(
          obj["content-disposition"]
        ).toString("latin1");
      }

      return obj;
    }

    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;

      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");

        if (
          key.length === 14 &&
          (key === "content-length" || key.toLowerCase() === "content-length")
        ) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (
          key.length === 19 &&
          (key === "content-disposition" ||
            key.toLowerCase() === "content-disposition")
        ) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }

      // See https://github.com/nodejs/node/pull/46528
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(
          ret[contentDispositionIdx]
        ).toString("latin1");
      }

      return ret;
    }

    function isBuffer(buffer) {
      // See, https://github.com/mcollina/undici/pull/319
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }

    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }

      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }

      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }

      if (
        typeof handler.onBodySent !== "function" &&
        handler.onBodySent !== undefined
      ) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }

      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }

        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }

        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }

    // A body is disturbed if it has been read from and it cannot
    // be re-used without losing state or data.
    function isDisturbed(body) {
      return !!(
        body &&
        (stream.isDisturbed
          ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?
          : body[kBodyUsed] ||
            body.readableDidRead ||
            (body._readableState && body._readableState.dataEmitted) ||
            isReadableAborted(body))
      );
    }

    function isErrored(body) {
      return !!(
        body &&
        (stream.isErrored
          ? stream.isErrored(body)
          : /state: 'errored'/.test(nodeUtil.inspect(body)))
      );
    }

    function isReadable(body) {
      return !!(
        body &&
        (stream.isReadable
          ? stream.isReadable(body)
          : /state: 'readable'/.test(nodeUtil.inspect(body)))
      );
    }

    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead,
      };
    }

    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }

    let ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = __nccwpck_require__(5356).ReadableStream;
      }

      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }

      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
        },
        0
      );
    }

    // The chunk should be a FormData instance and contains
    // all the required methods.
    function isFormDataLike(object) {
      return (
        object &&
        typeof object === "object" &&
        typeof object.append === "function" &&
        typeof object.delete === "function" &&
        typeof object.get === "function" &&
        typeof object.getAll === "function" &&
        typeof object.has === "function" &&
        typeof object.set === "function" &&
        object[Symbol.toStringTag] === "FormData"
      );
    }

    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          // DOMException not available < v17.0.0
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }

    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }

    const hasToWellFormed = !!String.prototype.toWellFormed;

    /**
     * @param {string} val
     */
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }

      return `${val}`;
    }

    // Parsed accordingly to RFC 9110
    // https://www.rfc-editor.org/rfc/rfc9110#field.content-range
    function parseRangeHeader(range) {
      if (range == null || range === "")
        return { start: 0, end: null, size: null };

      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m
        ? {
            start: parseInt(m[1]),
            end: m[2] ? parseInt(m[2]) : null,
            size: m[3] ? parseInt(m[3]) : null,
          }
        : null;
    }

    const kEnumerableProperty = Object.create(null);
    kEnumerableProperty.enumerable = true;

    module.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily:
        nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    };

    /***/
  },

  /***/ 4839: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const Dispatcher = __nccwpck_require__(412);
    const { ClientDestroyedError, ClientClosedError, InvalidArgumentError } =
      __nccwpck_require__(8045);
    const { kDestroy, kClose, kDispatch, kInterceptors } =
      __nccwpck_require__(2785);

    const kDestroyed = Symbol("destroyed");
    const kClosed = Symbol("closed");
    const kOnDestroyed = Symbol("onDestroyed");
    const kOnClosed = Symbol("onClosed");
    const kInterceptedDispatch = Symbol("Intercepted Dispatch");

    class DispatcherBase extends Dispatcher {
      constructor() {
        super();

        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }

      get destroyed() {
        return this[kDestroyed];
      }

      get closed() {
        return this[kClosed];
      }

      get interceptors() {
        return this[kInterceptors];
      }

      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }

        this[kInterceptors] = newInterceptors;
      }

      close(callback) {
        if (callback === undefined) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }

        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }

        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }

        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }

        this[kClosed] = true;
        this[kOnClosed].push(callback);

        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };

        // Should not error.
        this[kClose]()
          .then(() => this.destroy())
          .then(() => {
            queueMicrotask(onClosed);
          });
      }

      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }

        if (callback === undefined) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err, data) => {
              return err
                ? /* istanbul ignore next: should never error */ reject(err)
                : resolve(data);
            });
          });
        }

        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }

        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }

        if (!err) {
          err = new ClientDestroyedError();
        }

        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);

        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };

        // Should not error.
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }

      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }

        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }

      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }

        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }

          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }

          if (this[kClosed]) {
            throw new ClientClosedError();
          }

          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }

          handler.onError(err);

          return false;
        }
      }
    }

    module.exports = DispatcherBase;

    /***/
  },

  /***/ 412: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const EventEmitter = __nccwpck_require__(2361);

    class Dispatcher extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }

      close() {
        throw new Error("not implemented");
      }

      destroy() {
        throw new Error("not implemented");
      }
    }

    module.exports = Dispatcher;

    /***/
  },

  /***/ 1472: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const Busboy = __nccwpck_require__(727);
    const util = __nccwpck_require__(3983);
    const {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody,
    } = __nccwpck_require__(2538);
    const { FormData } = __nccwpck_require__(2015);
    const { kState } = __nccwpck_require__(5861);
    const { webidl } = __nccwpck_require__(1744);
    const { DOMException, structuredClone } = __nccwpck_require__(1037);
    const { Blob, File: NativeFile } = __nccwpck_require__(4300);
    const { kBodyUsed } = __nccwpck_require__(2785);
    const assert = __nccwpck_require__(9491);
    const { isErrored } = __nccwpck_require__(3983);
    const { isUint8Array, isArrayBuffer } = __nccwpck_require__(9830);
    const { File: UndiciFile } = __nccwpck_require__(8511);
    const { parseMIMEType, serializeAMimeType } = __nccwpck_require__(685);

    let ReadableStream = globalThis.ReadableStream;

    /** @type {globalThis['File']} */
    const File = NativeFile ?? UndiciFile;
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    // https://fetch.spec.whatwg.org/#concept-bodyinit-extract
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = __nccwpck_require__(5356).ReadableStream;
      }

      // 1. Let stream be null.
      let stream = null;

      // 2. If object is a ReadableStream object, then set stream to object.
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        // 3. Otherwise, if object is a Blob object, set stream to the
        //    result of running object’s get stream.
        stream = object.stream();
      } else {
        // 4. Otherwise, set stream to a new ReadableStream object, and set
        //    up stream.
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {},
          type: undefined,
        });
      }

      // 5. Assert: stream is a ReadableStream object.
      assert(isReadableStreamLike(stream));

      // 6. Let action be null.
      let action = null;

      // 7. Let source be null.
      let source = null;

      // 8. Let length be null.
      let length = null;

      // 9. Let type be null.
      let type = null;

      // 10. Switch on object:
      if (typeof object === "string") {
        // Set source to the UTF-8 encoding of object.
        // Note: setting source to a Uint8Array here breaks some mocking assumptions.
        source = object;

        // Set type to `text/plain;charset=UTF-8`.
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        // URLSearchParams

        // spec says to run application/x-www-form-urlencoded on body.list
        // this is implemented in Node.js as apart of an URLSearchParams instance toString method
        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

        // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.
        source = object.toString();

        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        // BufferSource/ArrayBuffer

        // Set source to a copy of the bytes held by object.
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        // BufferSource/ArrayBufferView

        // Set source to a copy of the bytes held by object.
        source = new Uint8Array(
          object.buffer.slice(
            object.byteOffset,
            object.byteOffset + object.byteLength
          )
        );
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r\nContent-Disposition: form-data`;

        /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
        const escape = (str) =>
          str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) =>
          value.replace(/\r?\n|\r/g, "\r\n");

        // Set action to this step: run the multipart/form-data
        // encoding algorithm, with object’s entry list and UTF-8.
        // - This ensures that the body is immutable and can't be changed afterwords
        // - That the content-length is calculated in advance.
        // - And that all parts are pre-encoded and ready to be sent.

        const blobParts = [];
        const rn = new Uint8Array([13, 10]); // '\r\n'
        length = 0;
        let hasUnknownSizeValue = false;

        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk = textEncoder.encode(
              prefix +
                `; name="${escape(normalizeLinefeeds(name))}"` +
                `\r\n\r\n${normalizeLinefeeds(value)}\r\n`
            );
            blobParts.push(chunk);
            length += chunk.byteLength;
          } else {
            const chunk = textEncoder.encode(
              `${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
                (value.name ? `; filename="${escape(value.name)}"` : "") +
                "\r\n" +
                `Content-Type: ${
                  value.type || "application/octet-stream"
                }\r\n\r\n`
            );
            blobParts.push(chunk, value, rn);
            if (typeof value.size === "number") {
              length += chunk.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }

        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }

        // Set source to object.
        source = object;

        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };

        // Set type to `multipart/form-data; boundary=`,
        // followed by the multipart/form-data boundary string generated
        // by the multipart/form-data encoding algorithm.
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        // Blob

        // Set source to object.
        source = object;

        // Set length to object’s size.
        length = object.size;

        // If object’s type attribute is not the empty byte sequence, set
        // type to its value.
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        // If keepalive is true, then throw a TypeError.
        if (keepalive) {
          throw new TypeError("keepalive");
        }

        // If object is disturbed or locked, then throw a TypeError.
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }

        stream =
          object instanceof ReadableStream
            ? object
            : ReadableStreamFrom(object);
      }

      // 11. If source is a byte sequence, then set action to a
      // step that returns source and length to source’s length.
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }

      // 12. If action is non-null, then run these steps in in parallel:
      if (action != null) {
        // Run action.
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              // When running action is done, close stream.
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              // Whenever one or more bytes are available and stream is not errored,
              // enqueue a Uint8Array wrapping an ArrayBuffer containing the available
              // bytes into stream.
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: undefined,
        });
      }

      // 13. Let body be a body whose stream is stream, source is source,
      // and length is length.
      const body = { stream, source, length };

      // 14. Return (body, type).
      return [body, type];
    }

    // https://fetch.spec.whatwg.org/#bodyinit-safely-extract
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        // istanbul ignore next
        ReadableStream = __nccwpck_require__(5356).ReadableStream;
      }

      // To safely extract a body and a `Content-Type` value from
      // a byte sequence or BodyInit object object, run these steps:

      // 1. If object is a ReadableStream object, then:
      if (object instanceof ReadableStream) {
        // Assert: object is neither disturbed nor locked.
        // istanbul ignore next
        assert(
          !util.isDisturbed(object),
          "The body has already been consumed."
        );
        // istanbul ignore next
        assert(!object.locked, "The stream is locked.");
      }

      // 2. Return the results of extracting object.
      return extractBody(object, keepalive);
    }

    function cloneBody(body) {
      // To clone a body body, run these steps:

      // https://fetch.spec.whatwg.org/#concept-body-clone

      // 1. Let « out1, out2 » be the result of teeing body’s stream.
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      // This, for whatever reasons, unrefs out2Clone which allows
      // the process to exit by itself.
      const [, finalClone] = out2Clone.tee();

      // 2. Set body’s stream to out1.
      body.stream = out1;

      // 3. Return a body whose stream is out2 and other members are copied from body.
      return {
        stream: finalClone,
        length: body.length,
        source: body.source,
      };
    }

    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;

          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }

          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }

          // Compat.
          stream[kBodyUsed] = true;

          yield* stream;
        }
      }
    }

    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }

    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          // The blob() method steps are to return the result of
          // running consume body with this and the following step
          // given a byte sequence bytes: return a Blob whose
          // contents are bytes and whose type attribute is this’s
          // MIME type.
          return specConsumeBody(
            this,
            (bytes) => {
              let mimeType = bodyMimeType(this);

              if (mimeType === "failure") {
                mimeType = "";
              } else if (mimeType) {
                mimeType = serializeAMimeType(mimeType);
              }

              // Return a Blob whose contents are bytes and type attribute
              // is mimeType.
              return new Blob([bytes], { type: mimeType });
            },
            instance
          );
        },

        arrayBuffer() {
          // The arrayBuffer() method steps are to return the result
          // of running consume body with this and the following step
          // given a byte sequence bytes: return a new ArrayBuffer
          // whose contents are bytes.
          return specConsumeBody(
            this,
            (bytes) => {
              return new Uint8Array(bytes).buffer;
            },
            instance
          );
        },

        text() {
          // The text() method steps are to return the result of running
          // consume body with this and UTF-8 decode.
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },

        json() {
          // The json() method steps are to return the result of running
          // consume body with this and parse JSON from bytes.
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },

        async formData() {
          webidl.brandCheck(this, instance);

          throwIfAborted(this[kState]);

          const contentType = this.headers.get("Content-Type");

          // If mimeType’s essence is "multipart/form-data", then:
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers)
              headers[key.toLowerCase()] = value;

            const responseFormData = new FormData();

            let busboy;

            try {
              busboy = new Busboy({
                headers,
                preservePath: true,
              });
            } catch (err) {
              throw new DOMException(`${err}`, "AbortError");
            }

            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];

              if (
                encoding === "base64" ||
                encoding.toLowerCase() === "base64"
              ) {
                let base64chunk = "";

                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");

                  const end = base64chunk.length - (base64chunk.length % 4);
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));

                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(
                    name,
                    new File(chunks, filename, { type: mimeType })
                  );
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(
                    name,
                    new File(chunks, filename, { type: mimeType })
                  );
                });
              }
            });

            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });

            if (this.body !== null)
              for await (const chunk of consumeBody(this[kState].body))
                busboy.write(chunk);
            busboy.end();
            await busboyResolve;

            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            // Otherwise, if mimeType’s essence is "application/x-www-form-urlencoded", then:

            // 1. Let entries be the result of parsing bytes.
            let entries;
            try {
              let text = "";
              // application/x-www-form-urlencoded parser will keep the BOM.
              // https://url.spec.whatwg.org/#concept-urlencoded-parser
              // Note that streaming decoder is stateful and cannot be reused
              const streamingDecoder = new TextDecoder("utf-8", {
                ignoreBOM: true,
              });

              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
              // 2. If entries is failure, then throw a TypeError.
              throw Object.assign(new TypeError(), { cause: err });
            }

            // 3. Return a new FormData object whose entries are entries.
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            // Wait a tick before checking if the request has been aborted.
            // Otherwise, a TypeError can be thrown when an AbortError should.
            await Promise.resolve();

            throwIfAborted(this[kState]);

            // Otherwise, throw a TypeError.
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData.",
            });
          }
        },
      };

      return methods;
    }

    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }

    /**
     * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
     * @param {Response|Request} object
     * @param {(value: unknown) => unknown} convertBytesToJSValue
     * @param {Response|Request} instance
     */
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);

      throwIfAborted(object[kState]);

      // 1. If object is unusable, then return a promise rejected
      //    with a TypeError.
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }

      // 2. Let promise be a new promise.
      const promise = createDeferredPromise();

      // 3. Let errorSteps given error be to reject promise with error.
      const errorSteps = (error) => promise.reject(error);

      // 4. Let successSteps given a byte sequence data be to resolve
      //    promise with the result of running convertBytesToJSValue
      //    with data. If that threw an exception, then run errorSteps
      //    with that exception.
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };

      // 5. If object’s body is null, then run successSteps with an
      //    empty byte sequence.
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }

      // 6. Otherwise, fully read object’s body given successSteps,
      //    errorSteps, and object’s relevant global object.
      await fullyReadBody(object[kState].body, successSteps, errorSteps);

      // 7. Return promise.
      return promise.promise;
    }

    // https://fetch.spec.whatwg.org/#body-unusable
    function bodyUnusable(body) {
      // An object including the Body interface mixin is
      // said to be unusable if its body is non-null and
      // its body’s stream is disturbed or locked.
      return (
        body != null && (body.stream.locked || util.isDisturbed(body.stream))
      );
    }

    /**
     * @see https://encoding.spec.whatwg.org/#utf-8-decode
     * @param {Buffer} buffer
     */
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }

      // 1. Let buffer be the result of peeking three bytes from
      //    ioQueue, converted to a byte sequence.

      // 2. If buffer is 0xEF 0xBB 0xBF, then read three
      //    bytes from ioQueue. (Do nothing with those bytes.)
      if (buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf) {
        buffer = buffer.subarray(3);
      }

      // 3. Process a queue with an instance of UTF-8’s
      //    decoder, ioQueue, output, and "replacement".
      const output = textDecoder.decode(buffer);

      // 4. Return output.
      return output;
    }

    /**
     * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
     * @param {Uint8Array} bytes
     */
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }

    /**
     * @see https://fetch.spec.whatwg.org/#concept-body-mime-type
     * @param {import('./response').Response|import('./request').Request} object
     */
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");

      if (contentType === null) {
        return "failure";
      }

      return parseMIMEType(contentType);
    }

    module.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody,
    };

    /***/
  },

  /***/ 1037: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { MessageChannel, receiveMessageOnPort } = __nccwpck_require__(1267);

    const corsSafeListedMethods = ["GET", "HEAD", "POST"];
    const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);

    const nullBodyStatus = [101, 204, 205, 304];

    const redirectStatus = [301, 302, 303, 307, 308];
    const redirectStatusSet = new Set(redirectStatus);

    // https://fetch.spec.whatwg.org/#block-bad-port
    const badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080",
    ];

    const badPortsSet = new Set(badPorts);

    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policies
    const referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url",
    ];
    const referrerPolicySet = new Set(referrerPolicy);

    const requestRedirect = ["follow", "manual", "error"];

    const safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    const safeMethodsSet = new Set(safeMethods);

    const requestMode = ["navigate", "same-origin", "no-cors", "cors"];

    const requestCredentials = ["omit", "same-origin", "include"];

    const requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached",
    ];

    // https://fetch.spec.whatwg.org/#request-body-header-name
    const requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length",
    ];

    // https://fetch.spec.whatwg.org/#enumdef-requestduplex
    const requestDuplex = ["half"];

    // http://fetch.spec.whatwg.org/#forbidden-method
    const forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    const forbiddenMethodsSet = new Set(forbiddenMethods);

    const subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      "",
    ];
    const subresourceSet = new Set(subresource);

    /** @type {globalThis['DOMException']} */
    const DOMException =
      globalThis.DOMException ??
      (() => {
        // DOMException was only made a global in Node v17.0.0,
        // but fetch supports >= v16.8.
        try {
          atob("~");
        } catch (err) {
          return Object.getPrototypeOf(err).constructor;
        }
      })();

    let channel;

    /** @type {globalThis['structuredClone']} */
    const structuredClone =
      globalThis.structuredClone ??
      // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
      // structuredClone was added in v17.0.0, but fetch supports v16.8
      function structuredClone(value, options = undefined) {
        if (arguments.length === 0) {
          throw new TypeError("missing argument");
        }

        if (!channel) {
          channel = new MessageChannel();
        }
        channel.port1.unref();
        channel.port2.unref();
        channel.port1.postMessage(value, options?.transfer);
        return receiveMessageOnPort(channel.port2).message;
      };

    module.exports = {
      DOMException,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet,
    };

    /***/
  },

  /***/ 685: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const assert = __nccwpck_require__(9491);
    const { atob } = __nccwpck_require__(4300);
    const { isomorphicDecode } = __nccwpck_require__(2538);

    const encoder = new TextEncoder();

    /**
     * @see https://mimesniff.spec.whatwg.org/#http-token-code-point
     */
    const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/; // eslint-disable-line
    /**
     * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
     */
    const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/; // eslint-disable-line

    // https://fetch.spec.whatwg.org/#data-url-processor
    /** @param {URL} dataURL */
    function dataURLProcessor(dataURL) {
      // 1. Assert: dataURL’s scheme is "data".
      assert(dataURL.protocol === "data:");

      // 2. Let input be the result of running the URL
      // serializer on dataURL with exclude fragment
      // set to true.
      let input = URLSerializer(dataURL, true);

      // 3. Remove the leading "data:" string from input.
      input = input.slice(5);

      // 4. Let position point at the start of input.
      const position = { position: 0 };

      // 5. Let mimeType be the result of collecting a
      // sequence of code points that are not equal
      // to U+002C (,), given position.
      let mimeType = collectASequenceOfCodePointsFast(",", input, position);

      // 6. Strip leading and trailing ASCII whitespace
      // from mimeType.
      // Undici implementation note: we need to store the
      // length because if the mimetype has spaces removed,
      // the wrong amount will be sliced from the input in
      // step #9
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);

      // 7. If position is past the end of input, then
      // return failure
      if (position.position >= input.length) {
        return "failure";
      }

      // 8. Advance position by 1.
      position.position++;

      // 9. Let encodedBody be the remainder of input.
      const encodedBody = input.slice(mimeTypeLength + 1);

      // 10. Let body be the percent-decoding of encodedBody.
      let body = stringPercentDecode(encodedBody);

      // 11. If mimeType ends with U+003B (;), followed by
      // zero or more U+0020 SPACE, followed by an ASCII
      // case-insensitive match for "base64", then:
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        // 1. Let stringBody be the isomorphic decode of body.
        const stringBody = isomorphicDecode(body);

        // 2. Set body to the forgiving-base64 decode of
        // stringBody.
        body = forgivingBase64(stringBody);

        // 3. If body is failure, then return failure.
        if (body === "failure") {
          return "failure";
        }

        // 4. Remove the last 6 code points from mimeType.
        mimeType = mimeType.slice(0, -6);

        // 5. Remove trailing U+0020 SPACE code points from mimeType,
        // if any.
        mimeType = mimeType.replace(/(\u0020)+$/, "");

        // 6. Remove the last U+003B (;) code point from mimeType.
        mimeType = mimeType.slice(0, -1);
      }

      // 12. If mimeType starts with U+003B (;), then prepend
      // "text/plain" to mimeType.
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }

      // 13. Let mimeTypeRecord be the result of parsing
      // mimeType.
      let mimeTypeRecord = parseMIMEType(mimeType);

      // 14. If mimeTypeRecord is failure, then set
      // mimeTypeRecord to text/plain;charset=US-ASCII.
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }

      // 15. Return a new data: URL struct whose MIME
      // type is mimeTypeRecord and body is body.
      // https://fetch.spec.whatwg.org/#data-url-struct
      return { mimeType: mimeTypeRecord, body };
    }

    // https://url.spec.whatwg.org/#concept-url-serializer
    /**
     * @param {URL} url
     * @param {boolean} excludeFragment
     */
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }

      const href = url.href;
      const hashLength = url.hash.length;

      return hashLength === 0
        ? href
        : href.substring(0, href.length - hashLength);
    }

    // https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
    /**
     * @param {(char: string) => boolean} condition
     * @param {string} input
     * @param {{ position: number }} position
     */
    function collectASequenceOfCodePoints(condition, input, position) {
      // 1. Let result be the empty string.
      let result = "";

      // 2. While position doesn’t point past the end of input and the
      // code point at position within input meets the condition condition:
      while (
        position.position < input.length &&
        condition(input[position.position])
      ) {
        // 1. Append that code point to the end of result.
        result += input[position.position];

        // 2. Advance position by 1.
        position.position++;
      }

      // 3. Return result.
      return result;
    }

    /**
     * A faster collectASequenceOfCodePoints that only works when comparing a single character.
     * @param {string} char
     * @param {string} input
     * @param {{ position: number }} position
     */
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;

      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }

      position.position = idx;
      return input.slice(start, position.position);
    }

    // https://url.spec.whatwg.org/#string-percent-decode
    /** @param {string} input */
    function stringPercentDecode(input) {
      // 1. Let bytes be the UTF-8 encoding of input.
      const bytes = encoder.encode(input);

      // 2. Return the percent-decoding of bytes.
      return percentDecode(bytes);
    }

    // https://url.spec.whatwg.org/#percent-decode
    /** @param {Uint8Array} input */
    function percentDecode(input) {
      // 1. Let output be an empty byte sequence.
      /** @type {number[]} */
      const output = [];

      // 2. For each byte byte in input:
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];

        // 1. If byte is not 0x25 (%), then append byte to output.
        if (byte !== 0x25) {
          output.push(byte);

          // 2. Otherwise, if byte is 0x25 (%) and the next two bytes
          // after byte in input are not in the ranges
          // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
          // and 0x61 (a) to 0x66 (f), all inclusive, append byte
          // to output.
        } else if (
          byte === 0x25 &&
          !/^[0-9A-Fa-f]{2}$/i.test(
            String.fromCharCode(input[i + 1], input[i + 2])
          )
        ) {
          output.push(0x25);

          // 3. Otherwise:
        } else {
          // 1. Let bytePoint be the two bytes after byte in input,
          // decoded, and then interpreted as hexadecimal number.
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);

          // 2. Append a byte whose value is bytePoint to output.
          output.push(bytePoint);

          // 3. Skip the next two bytes in input.
          i += 2;
        }
      }

      // 3. Return output.
      return Uint8Array.from(output);
    }

    // https://mimesniff.spec.whatwg.org/#parse-a-mime-type
    /** @param {string} input */
    function parseMIMEType(input) {
      // 1. Remove any leading and trailing HTTP whitespace
      // from input.
      input = removeHTTPWhitespace(input, true, true);

      // 2. Let position be a position variable for input,
      // initially pointing at the start of input.
      const position = { position: 0 };

      // 3. Let type be the result of collecting a sequence
      // of code points that are not U+002F (/) from
      // input, given position.
      const type = collectASequenceOfCodePointsFast("/", input, position);

      // 4. If type is the empty string or does not solely
      // contain HTTP token code points, then return failure.
      // https://mimesniff.spec.whatwg.org/#http-token-code-point
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }

      // 5. If position is past the end of input, then return
      // failure
      if (position.position > input.length) {
        return "failure";
      }

      // 6. Advance position by 1. (This skips past U+002F (/).)
      position.position++;

      // 7. Let subtype be the result of collecting a sequence of
      // code points that are not U+003B (;) from input, given
      // position.
      let subtype = collectASequenceOfCodePointsFast(";", input, position);

      // 8. Remove any trailing HTTP whitespace from subtype.
      subtype = removeHTTPWhitespace(subtype, false, true);

      // 9. If subtype is the empty string or does not solely
      // contain HTTP token code points, then return failure.
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }

      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();

      // 10. Let mimeType be a new MIME type record whose type
      // is type, in ASCII lowercase, and subtype is subtype,
      // in ASCII lowercase.
      // https://mimesniff.spec.whatwg.org/#mime-type
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`,
      };

      // 11. While position is not past the end of input:
      while (position.position < input.length) {
        // 1. Advance position by 1. (This skips past U+003B (;).)
        position.position++;

        // 2. Collect a sequence of code points that are HTTP
        // whitespace from input given position.
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );

        // 3. Let parameterName be the result of collecting a
        // sequence of code points that are not U+003B (;)
        // or U+003D (=) from input, given position.
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );

        // 4. Set parameterName to parameterName, in ASCII
        // lowercase.
        parameterName = parameterName.toLowerCase();

        // 5. If position is not past the end of input, then:
        if (position.position < input.length) {
          // 1. If the code point at position within input is
          // U+003B (;), then continue.
          if (input[position.position] === ";") {
            continue;
          }

          // 2. Advance position by 1. (This skips past U+003D (=).)
          position.position++;
        }

        // 6. If position is past the end of input, then break.
        if (position.position > input.length) {
          break;
        }

        // 7. Let parameterValue be null.
        let parameterValue = null;

        // 8. If the code point at position within input is
        // U+0022 ("), then:
        if (input[position.position] === '"') {
          // 1. Set parameterValue to the result of collecting
          // an HTTP quoted string from input, given position
          // and the extract-value flag.
          parameterValue = collectAnHTTPQuotedString(input, position, true);

          // 2. Collect a sequence of code points that are not
          // U+003B (;) from input, given position.
          collectASequenceOfCodePointsFast(";", input, position);

          // 9. Otherwise:
        } else {
          // 1. Set parameterValue to the result of collecting
          // a sequence of code points that are not U+003B (;)
          // from input, given position.
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );

          // 2. Remove any trailing HTTP whitespace from parameterValue.
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);

          // 3. If parameterValue is the empty string, then continue.
          if (parameterValue.length === 0) {
            continue;
          }
        }

        // 10. If all of the following are true
        // - parameterName is not the empty string
        // - parameterName solely contains HTTP token code points
        // - parameterValue solely contains HTTP quoted-string token code points
        // - mimeType’s parameters[parameterName] does not exist
        // then set mimeType’s parameters[parameterName] to parameterValue.
        if (
          parameterName.length !== 0 &&
          HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
          (parameterValue.length === 0 ||
            HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
          !mimeType.parameters.has(parameterName)
        ) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }

      // 12. Return mimeType.
      return mimeType;
    }

    // https://infra.spec.whatwg.org/#forgiving-base64-decode
    /** @param {string} data */
    function forgivingBase64(data) {
      // 1. Remove all ASCII whitespace from data.
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, ""); // eslint-disable-line

      // 2. If data’s code point length divides by 4 leaving
      // no remainder, then:
      if (data.length % 4 === 0) {
        // 1. If data ends with one or two U+003D (=) code points,
        // then remove them from data.
        data = data.replace(/=?=$/, "");
      }

      // 3. If data’s code point length divides by 4 leaving
      // a remainder of 1, then return failure.
      if (data.length % 4 === 1) {
        return "failure";
      }

      // 4. If data contains a code point that is not one of
      //  U+002B (+)
      //  U+002F (/)
      //  ASCII alphanumeric
      // then return failure.
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }

      const binary = atob(data);
      const bytes = new Uint8Array(binary.length);

      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }

      return bytes;
    }

    // https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
    // tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
    /**
     * @param {string} input
     * @param {{ position: number }} position
     * @param {boolean?} extractValue
     */
    function collectAnHTTPQuotedString(input, position, extractValue) {
      // 1. Let positionStart be position.
      const positionStart = position.position;

      // 2. Let value be the empty string.
      let value = "";

      // 3. Assert: the code point at position within input
      // is U+0022 (").
      assert(input[position.position] === '"');

      // 4. Advance position by 1.
      position.position++;

      // 5. While true:
      while (true) {
        // 1. Append the result of collecting a sequence of code points
        // that are not U+0022 (") or U+005C (\) from input, given
        // position, to value.
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );

        // 2. If position is past the end of input, then break.
        if (position.position >= input.length) {
          break;
        }

        // 3. Let quoteOrBackslash be the code point at position within
        // input.
        const quoteOrBackslash = input[position.position];

        // 4. Advance position by 1.
        position.position++;

        // 5. If quoteOrBackslash is U+005C (\), then:
        if (quoteOrBackslash === "\\") {
          // 1. If position is past the end of input, then append
          // U+005C (\) to value and break.
          if (position.position >= input.length) {
            value += "\\";
            break;
          }

          // 2. Append the code point at position within input to value.
          value += input[position.position];

          // 3. Advance position by 1.
          position.position++;

          // 6. Otherwise:
        } else {
          // 1. Assert: quoteOrBackslash is U+0022 (").
          assert(quoteOrBackslash === '"');

          // 2. Break.
          break;
        }
      }

      // 6. If the extract-value flag is set, then return value.
      if (extractValue) {
        return value;
      }

      // 7. Return the code points from positionStart to position,
      // inclusive, within input.
      return input.slice(positionStart, position.position);
    }

    /**
     * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
     */
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;

      // 1. Let serialization be the concatenation of mimeType’s
      //    type, U+002F (/), and mimeType’s subtype.
      let serialization = essence;

      // 2. For each name → value of mimeType’s parameters:
      for (let [name, value] of parameters.entries()) {
        // 1. Append U+003B (;) to serialization.
        serialization += ";";

        // 2. Append name to serialization.
        serialization += name;

        // 3. Append U+003D (=) to serialization.
        serialization += "=";

        // 4. If value does not solely contain HTTP token code
        //    points or value is the empty string, then:
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          // 1. Precede each occurence of U+0022 (") or
          //    U+005C (\) in value with U+005C (\).
          value = value.replace(/(\\|")/g, "\\$1");

          // 2. Prepend U+0022 (") to value.
          value = '"' + value;

          // 3. Append U+0022 (") to value.
          value += '"';
        }

        // 5. Append value to serialization.
        serialization += value;
      }

      // 3. Return serialization.
      return serialization;
    }

    /**
     * @see https://fetch.spec.whatwg.org/#http-whitespace
     * @param {string} char
     */
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "\t" || char === " ";
    }

    /**
     * @see https://fetch.spec.whatwg.org/#http-whitespace
     * @param {string} str
     */
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;

      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
      }

      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
      }

      return str.slice(lead, trail + 1);
    }

    /**
     * @see https://infra.spec.whatwg.org/#ascii-whitespace
     * @param {string} char
     */
    function isASCIIWhitespace(char) {
      return (
        char === "\r" ||
        char === "\n" ||
        char === "\t" ||
        char === "\f" ||
        char === " "
      );
    }

    /**
     * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
     */
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;

      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
      }

      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
      }

      return str.slice(lead, trail + 1);
    }

    module.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType,
    };

    /***/
  },

  /***/ 8511: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { Blob, File: NativeFile } = __nccwpck_require__(4300);
    const { types } = __nccwpck_require__(3837);
    const { kState } = __nccwpck_require__(5861);
    const { isBlobLike } = __nccwpck_require__(2538);
    const { webidl } = __nccwpck_require__(1744);
    const { parseMIMEType, serializeAMimeType } = __nccwpck_require__(685);
    const { kEnumerableProperty } = __nccwpck_require__(3983);
    const encoder = new TextEncoder();

    class File extends Blob {
      constructor(fileBits, fileName, options = {}) {
        // The File constructor is invoked with two or three parameters, depending
        // on whether the optional dictionary parameter is used. When the File()
        // constructor is invoked, user agents must run the following steps:
        webidl.argumentLengthCheck(arguments, 2, {
          header: "File constructor",
        });

        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);

        // 1. Let bytes be the result of processing blob parts given fileBits and
        // options.
        // Note: Blob handles this for us

        // 2. Let n be the fileName argument to the constructor.
        const n = fileName;

        // 3. Process FilePropertyBag dictionary argument by running the following
        // substeps:

        //    1. If the type member is provided and is not the empty string, let t
        //    be set to the type dictionary member. If t contains any characters
        //    outside the range U+0020 to U+007E, then set t to the empty string
        //    and return from these substeps.
        //    2. Convert every character in t to ASCII lowercase.
        let t = options.type;
        let d;

        // eslint-disable-next-line no-labels
        substep: {
          if (t) {
            t = parseMIMEType(t);

            if (t === "failure") {
              t = "";
              // eslint-disable-next-line no-labels
              break substep;
            }

            t = serializeAMimeType(t).toLowerCase();
          }

          //    3. If the lastModified member is provided, let d be set to the
          //    lastModified dictionary member. If it is not provided, set d to the
          //    current date and time represented as the number of milliseconds since
          //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
          d = options.lastModified;
        }

        // 4. Return a new File object F such that:
        // F refers to the bytes byte sequence.
        // F.size is set to the number of total bytes in bytes.
        // F.name is set to n.
        // F.type is set to t.
        // F.lastModified is set to d.

        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t,
        };
      }

      get name() {
        webidl.brandCheck(this, File);

        return this[kState].name;
      }

      get lastModified() {
        webidl.brandCheck(this, File);

        return this[kState].lastModified;
      }

      get type() {
        webidl.brandCheck(this, File);

        return this[kState].type;
      }
    }

    class FileLike {
      constructor(blobLike, fileName, options = {}) {
        // TODO: argument idl type check

        // The File constructor is invoked with two or three parameters, depending
        // on whether the optional dictionary parameter is used. When the File()
        // constructor is invoked, user agents must run the following steps:

        // 1. Let bytes be the result of processing blob parts given fileBits and
        // options.

        // 2. Let n be the fileName argument to the constructor.
        const n = fileName;

        // 3. Process FilePropertyBag dictionary argument by running the following
        // substeps:

        //    1. If the type member is provided and is not the empty string, let t
        //    be set to the type dictionary member. If t contains any characters
        //    outside the range U+0020 to U+007E, then set t to the empty string
        //    and return from these substeps.
        //    TODO
        const t = options.type;

        //    2. Convert every character in t to ASCII lowercase.
        //    TODO

        //    3. If the lastModified member is provided, let d be set to the
        //    lastModified dictionary member. If it is not provided, set d to the
        //    current date and time represented as the number of milliseconds since
        //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
        const d = options.lastModified ?? Date.now();

        // 4. Return a new File object F such that:
        // F refers to the bytes byte sequence.
        // F.size is set to the number of total bytes in bytes.
        // F.name is set to n.
        // F.type is set to t.
        // F.lastModified is set to d.

        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d,
        };
      }

      stream(...args) {
        webidl.brandCheck(this, FileLike);

        return this[kState].blobLike.stream(...args);
      }

      arrayBuffer(...args) {
        webidl.brandCheck(this, FileLike);

        return this[kState].blobLike.arrayBuffer(...args);
      }

      slice(...args) {
        webidl.brandCheck(this, FileLike);

        return this[kState].blobLike.slice(...args);
      }

      text(...args) {
        webidl.brandCheck(this, FileLike);

        return this[kState].blobLike.text(...args);
      }

      get size() {
        webidl.brandCheck(this, FileLike);

        return this[kState].blobLike.size;
      }

      get type() {
        webidl.brandCheck(this, FileLike);

        return this[kState].blobLike.type;
      }

      get name() {
        webidl.brandCheck(this, FileLike);

        return this[kState].name;
      }

      get lastModified() {
        webidl.brandCheck(this, FileLike);

        return this[kState].lastModified;
      }

      get [Symbol.toStringTag]() {
        return "File";
      }
    }

    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true,
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty,
    });

    webidl.converters.Blob = webidl.interfaceConverter(Blob);

    webidl.converters.BlobPart = function (V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }

        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }

      return webidl.converters.USVString(V, opts);
    };

    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );

    // https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        },
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: "",
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();

          if (value !== "native") {
            value = "transparent";
          }

          return value;
        },
        defaultValue: "transparent",
      },
    ]);

    /**
     * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
     * @param {(NodeJS.TypedArray|Blob|string)[]} parts
     * @param {{ type: string, endings: string }} options
     */
    function processBlobParts(parts, options) {
      // 1. Let bytes be an empty sequence of bytes.
      /** @type {NodeJS.TypedArray[]} */
      const bytes = [];

      // 2. For each element in parts:
      for (const element of parts) {
        // 1. If element is a USVString, run the following substeps:
        if (typeof element === "string") {
          // 1. Let s be element.
          let s = element;

          // 2. If the endings member of options is "native", set s
          //    to the result of converting line endings to native
          //    of element.
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }

          // 3. Append the result of UTF-8 encoding s to bytes.
          bytes.push(encoder.encode(s));
        } else if (
          types.isAnyArrayBuffer(element) ||
          types.isTypedArray(element)
        ) {
          // 2. If element is a BufferSource, get a copy of the
          //    bytes held by the buffer source, and append those
          //    bytes to bytes.
          if (!element.buffer) {
            // ArrayBuffer
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(
                element.buffer,
                element.byteOffset,
                element.byteLength
              )
            );
          }
        } else if (isBlobLike(element)) {
          // 3. If element is a Blob, append the bytes it represents
          //    to bytes.
          bytes.push(element);
        }
      }

      // 3. Return bytes.
      return bytes;
    }

    /**
     * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
     * @param {string} s
     */
    function convertLineEndingsNative(s) {
      // 1. Let native line ending be be the code point U+000A LF.
      let nativeLineEnding = "\n";

      // 2. If the underlying platform’s conventions are to
      //    represent newlines as a carriage return and line feed
      //    sequence, set native line ending to the code point
      //    U+000D CR followed by the code point U+000A LF.
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }

      return s.replace(/\r?\n/g, nativeLineEnding);
    }

    // If this function is moved to ./util.js, some tools (such as
    // rollup) will warn about circular dependencies. See:
    // https://github.com/nodejs/undici/issues/1629
    function isFileLike(object) {
      return (
        (NativeFile && object instanceof NativeFile) ||
        object instanceof File ||
        (object &&
          (typeof object.stream === "function" ||
            typeof object.arrayBuffer === "function") &&
          object[Symbol.toStringTag] === "File")
      );
    }

    module.exports = { File, FileLike, isFileLike };

    /***/
  },

  /***/ 2015: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { isBlobLike, toUSVString, makeIterator } = __nccwpck_require__(2538);
    const { kState } = __nccwpck_require__(5861);
    const {
      File: UndiciFile,
      FileLike,
      isFileLike,
    } = __nccwpck_require__(8511);
    const { webidl } = __nccwpck_require__(1744);
    const { Blob, File: NativeFile } = __nccwpck_require__(4300);

    /** @type {globalThis['File']} */
    const File = NativeFile ?? UndiciFile;

    // https://xhr.spec.whatwg.org/#formdata
    class FormData {
      constructor(form) {
        if (form !== undefined) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"],
          });
        }

        this[kState] = [];
      }

      append(name, value, filename = undefined) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });

        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }

        // 1. Let value be value if given; otherwise blobValue.

        name = webidl.converters.USVString(name);
        value = isBlobLike(value)
          ? webidl.converters.Blob(value, { strict: false })
          : webidl.converters.USVString(value);
        filename =
          arguments.length === 3
            ? webidl.converters.USVString(filename)
            : undefined;

        // 2. Let entry be the result of creating an entry with
        // name, value, and filename if given.
        const entry = makeEntry(name, value, filename);

        // 3. Append entry to this’s entry list.
        this[kState].push(entry);
      }

      delete(name) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });

        name = webidl.converters.USVString(name);

        // The delete(name) method steps are to remove all entries whose name
        // is name from this’s entry list.
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }

      get(name) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });

        name = webidl.converters.USVString(name);

        // 1. If there is no entry whose name is name in this’s entry list,
        // then return null.
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }

        // 2. Return the value of the first entry whose name is name from
        // this’s entry list.
        return this[kState][idx].value;
      }

      getAll(name) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });

        name = webidl.converters.USVString(name);

        // 1. If there is no entry whose name is name in this’s entry list,
        // then return the empty list.
        // 2. Return the values of all entries whose name is name, in order,
        // from this’s entry list.
        return this[kState]
          .filter((entry) => entry.name === name)
          .map((entry) => entry.value);
      }

      has(name) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });

        name = webidl.converters.USVString(name);

        // The has(name) method steps are to return true if there is an entry
        // whose name is name in this’s entry list; otherwise false.
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }

      set(name, value, filename = undefined) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });

        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }

        // The set(name, value) and set(name, blobValue, filename) method steps
        // are:

        // 1. Let value be value if given; otherwise blobValue.

        name = webidl.converters.USVString(name);
        value = isBlobLike(value)
          ? webidl.converters.Blob(value, { strict: false })
          : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : undefined;

        // 2. Let entry be the result of creating an entry with name, value, and
        // filename if given.
        const entry = makeEntry(name, value, filename);

        // 3. If there are entries in this’s entry list whose name is name, then
        // replace the first such entry with entry and remove the others.
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState]
              .slice(idx + 1)
              .filter((entry) => entry.name !== name),
          ];
        } else {
          // 4. Otherwise, append entry to this’s entry list.
          this[kState].push(entry);
        }
      }

      entries() {
        webidl.brandCheck(this, FormData);

        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }

      keys() {
        webidl.brandCheck(this, FormData);

        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }

      values() {
        webidl.brandCheck(this, FormData);

        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }

      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, FormData);

        webidl.argumentLengthCheck(arguments, 1, {
          header: "FormData.forEach",
        });

        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }

        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    }

    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;

    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true,
      },
    });

    /**
     * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
     * @param {string} name
     * @param {string|Blob} value
     * @param {?string} filename
     * @returns
     */
    function makeEntry(name, value, filename) {
      // 1. Set name to the result of converting name into a scalar value string.
      // "To convert a string into a scalar value string, replace any surrogates
      //  with U+FFFD."
      // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end
      name = Buffer.from(name).toString("utf8");

      // 2. If value is a string, then set value to the result of converting
      //    value into a scalar value string.
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        // 3. Otherwise:

        // 1. If value is not a File object, then set value to a new File object,
        //    representing the same bytes, whose name attribute value is "blob"
        if (!isFileLike(value)) {
          value =
            value instanceof Blob
              ? new File([value], "blob", { type: value.type })
              : new FileLike(value, "blob", { type: value.type });
        }

        // 2. If filename is given, then set value to a new File object,
        //    representing the same bytes, whose name attribute is filename.
        if (filename !== undefined) {
          /** @type {FilePropertyBag} */
          const options = {
            type: value.type,
            lastModified: value.lastModified,
          };

          value =
            (NativeFile && value instanceof NativeFile) ||
            value instanceof UndiciFile
              ? new File([value], filename, options)
              : new FileLike(value, filename, options);
        }
      }

      // 4. Return an entry whose name is name and whose value is value.
      return { name, value };
    }

    module.exports = { FormData };

    /***/
  },

  /***/ 1246: /***/ (module) => {
    // In case of breaking changes, increase the version
    // number to avoid conflicts.
    const globalOrigin = Symbol.for("undici.globalOrigin.1");

    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }

    function setGlobalOrigin(newOrigin) {
      if (newOrigin === undefined) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: undefined,
          writable: true,
          enumerable: false,
          configurable: false,
        });

        return;
      }

      const parsedURL = new URL(newOrigin);

      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(
          `Only http & https urls are allowed, received ${parsedURL.protocol}`
        );
      }

      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false,
      });
    }

    module.exports = {
      getGlobalOrigin,
      setGlobalOrigin,
    };

    /***/
  },

  /***/ 554: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // https://github.com/Ethan-Arrowood/undici-fetch

    const { kHeadersList, kConstruct } = __nccwpck_require__(2785);
    const { kGuard } = __nccwpck_require__(5861);
    const { kEnumerableProperty } = __nccwpck_require__(3983);
    const { makeIterator, isValidHeaderName, isValidHeaderValue } =
      __nccwpck_require__(2538);
    const { webidl } = __nccwpck_require__(1744);
    const assert = __nccwpck_require__(9491);

    const kHeadersMap = Symbol("headers map");
    const kHeadersSortedMap = Symbol("headers map sorted");

    /**
     * @param {number} code
     */
    function isHTTPWhiteSpaceCharCode(code) {
      return (
        code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020
      );
    }

    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
     * @param {string} potentialValue
     */
    function headerValueNormalize(potentialValue) {
      //  To normalize a byte sequence potentialValue, remove
      //  any leading and trailing HTTP whitespace bytes from
      //  potentialValue.
      let i = 0;
      let j = potentialValue.length;

      while (
        j > i &&
        isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))
      )
        --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
        ++i;

      return i === 0 && j === potentialValue.length
        ? potentialValue
        : potentialValue.substring(i, j);
    }

    function fill(headers, object) {
      // To fill a Headers object headers with a given object object, run these steps:

      // 1. If object is a sequence, then for each header in object:
      // Note: webidl conversion to array has already been done.
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          // 1. If header does not contain exactly two items, then throw a TypeError.
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`,
            });
          }

          // 2. Append (header’s first item, header’s second item) to headers.
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        // Note: null should throw

        // 2. Otherwise, object is a record, then for each key → value in object,
        //    append (key, value) to headers
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: [
            "sequence<sequence<ByteString>>",
            "record<ByteString, ByteString>",
          ],
        });
      }
    }

    /**
     * @see https://fetch.spec.whatwg.org/#concept-headers-append
     */
    function appendHeader(headers, name, value) {
      // 1. Normalize value.
      value = headerValueNormalize(value);

      // 2. If name is not a header name or value is not a
      //    header value, then throw a TypeError.
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name",
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value",
        });
      }

      // 3. If headers’s guard is "immutable", then throw a TypeError.
      // 4. Otherwise, if headers’s guard is "request" and name is a
      //    forbidden header name, return.
      // Note: undici does not implement forbidden header names
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
        // 5. Otherwise, if headers’s guard is "request-no-cors":
        // TODO
      }

      // 6. Otherwise, if headers’s guard is "response" and name is a
      //    forbidden response-header name, return.

      // 7. Append (name, value) to headers’s header list.
      return headers[kHeadersList].append(name, value);

      // 8. If headers’s guard is "request-no-cors", then remove
      //    privileged no-CORS request headers from headers
    }

    class HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;

      constructor(init) {
        if (init instanceof HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }

      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        // A header list list contains a header name name if list
        // contains a header whose name is a byte-case-insensitive
        // match for name.
        name = name.toLowerCase();

        return this[kHeadersMap].has(name);
      }

      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }

      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;

        // 1. If list contains name, then set name to the first such
        //    header’s name.
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);

        // 2. Append (name, value) to list.
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`,
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }

        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }

      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();

        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }

        // 1. If list contains name, then set the value of
        //    the first such header to value and remove the
        //    others.
        // 2. Otherwise, append header (name, value) to list.
        this[kHeadersMap].set(lowercaseName, { name, value });
      }

      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;

        name = name.toLowerCase();

        if (name === "set-cookie") {
          this.cookies = null;
        }

        this[kHeadersMap].delete(name);
      }

      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());

        // 1. If list does not contain name, then return null.
        // 2. Return the values of all headers in list whose name
        //    is a byte-case-insensitive match for name,
        //    separated from each other by 0x2C 0x20, in order.
        return value === undefined ? null : value.value;
      }

      *[Symbol.iterator]() {
        // use the lowercased name
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }

      get entries() {
        const headers = {};

        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }

        return headers;
      }
    }

    // https://fetch.spec.whatwg.org/#headers-class
    class Headers {
      constructor(init = undefined) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();

        // The new Headers(init) constructor steps are:

        // 1. Set this’s guard to "none".
        this[kGuard] = "none";

        // 2. If init is given, then fill this with init.
        if (init !== undefined) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }

      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, Headers);

        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });

        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);

        return appendHeader(this, name, value);
      }

      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, Headers);

        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });

        name = webidl.converters.ByteString(name);

        // 1. If name is not a header name, then throw a TypeError.
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name",
          });
        }

        // 2. If this’s guard is "immutable", then throw a TypeError.
        // 3. Otherwise, if this’s guard is "request" and name is a
        //    forbidden header name, return.
        // 4. Otherwise, if this’s guard is "request-no-cors", name
        //    is not a no-CORS-safelisted request-header name, and
        //    name is not a privileged no-CORS request-header name,
        //    return.
        // 5. Otherwise, if this’s guard is "response" and name is
        //    a forbidden response-header name, return.
        // Note: undici does not implement forbidden header names
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
          // TODO
        }

        // 6. If this’s header list does not contain name, then
        //    return.
        if (!this[kHeadersList].contains(name)) {
          return;
        }

        // 7. Delete name from this’s header list.
        // 8. If this’s guard is "request-no-cors", then remove
        //    privileged no-CORS request headers from this.
        this[kHeadersList].delete(name);
      }

      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, Headers);

        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });

        name = webidl.converters.ByteString(name);

        // 1. If name is not a header name, then throw a TypeError.
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name",
          });
        }

        // 2. Return the result of getting name from this’s header
        //    list.
        return this[kHeadersList].get(name);
      }

      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, Headers);

        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });

        name = webidl.converters.ByteString(name);

        // 1. If name is not a header name, then throw a TypeError.
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name",
          });
        }

        // 2. Return true if this’s header list contains name;
        //    otherwise false.
        return this[kHeadersList].contains(name);
      }

      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, Headers);

        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });

        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);

        // 1. Normalize value.
        value = headerValueNormalize(value);

        // 2. If name is not a header name or value is not a
        //    header value, then throw a TypeError.
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name",
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value",
          });
        }

        // 3. If this’s guard is "immutable", then throw a TypeError.
        // 4. Otherwise, if this’s guard is "request" and name is a
        //    forbidden header name, return.
        // 5. Otherwise, if this’s guard is "request-no-cors" and
        //    name/value is not a no-CORS-safelisted request-header,
        //    return.
        // 6. Otherwise, if this’s guard is "response" and name is a
        //    forbidden response-header name, return.
        // Note: undici does not implement forbidden header names
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
          // TODO
        }

        // 7. Set (name, value) in this’s header list.
        // 8. If this’s guard is "request-no-cors", then remove
        //    privileged no-CORS request headers from this
        this[kHeadersList].set(name, value);
      }

      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, Headers);

        // 1. If this’s header list does not contain `Set-Cookie`, then return « ».
        // 2. Return the values of all headers in this’s header list whose name is
        //    a byte-case-insensitive match for `Set-Cookie`, in order.

        const list = this[kHeadersList].cookies;

        if (list) {
          return [...list];
        }

        return [];
      }

      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }

        // 1. Let headers be an empty list of headers with the key being the name
        //    and value the value.
        const headers = [];

        // 2. Let names be the result of convert header names to a sorted-lowercase
        //    set with all the names of the headers in list.
        const names = [...this[kHeadersList]].sort((a, b) =>
          a[0] < b[0] ? -1 : 1
        );
        const cookies = this[kHeadersList].cookies;

        // 3. For each name of names:
        for (let i = 0; i < names.length; ++i) {
          const [name, value] = names[i];
          // 1. If name is `set-cookie`, then:
          if (name === "set-cookie") {
            // 1. Let values be a list of all values of headers in list whose name
            //    is a byte-case-insensitive match for name, in order.

            // 2. For each value of values:
            // 1. Append (name, value) to headers.
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            // 2. Otherwise:

            // 1. Let value be the result of getting name from list.

            // 2. Assert: value is non-null.
            assert(value !== null);

            // 3. Append (name, value) to headers.
            headers.push([name, value]);
          }
        }

        this[kHeadersList][kHeadersSortedMap] = headers;

        // 4. Return headers.
        return headers;
      }

      keys() {
        webidl.brandCheck(this, Headers);

        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(() => value, "Headers", "key");
        }

        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }

      values() {
        webidl.brandCheck(this, Headers);

        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(() => value, "Headers", "value");
        }

        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }

      entries() {
        webidl.brandCheck(this, Headers);

        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(() => value, "Headers", "key+value");
        }

        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }

      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, Headers);

        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });

        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }

        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }

      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, Headers);

        return this[kHeadersList];
      }
    }

    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;

    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true,
      },
    });

    webidl.converters.HeadersInit = function (V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }

        return webidl.converters["record<ByteString, ByteString>"](V);
      }

      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: [
          "sequence<sequence<ByteString>>",
          "record<ByteString, ByteString>",
        ],
      });
    };

    module.exports = {
      fill,
      Headers,
      HeadersList,
    };

    /***/
  },

  /***/ 4881: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // https://github.com/Ethan-Arrowood/undici-fetch

    const {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse,
    } = __nccwpck_require__(7823);
    const { Headers } = __nccwpck_require__(554);
    const { Request, makeRequest } = __nccwpck_require__(8359);
    const zlib = __nccwpck_require__(9796);
    const {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme,
    } = __nccwpck_require__(2538);
    const { kState, kHeaders, kGuard, kRealm } = __nccwpck_require__(5861);
    const assert = __nccwpck_require__(9491);
    const { safelyExtractBody } = __nccwpck_require__(1472);
    const {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException,
    } = __nccwpck_require__(1037);
    const { kHeadersList } = __nccwpck_require__(2785);
    const EE = __nccwpck_require__(2361);
    const { Readable, pipeline } = __nccwpck_require__(2781);
    const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } =
      __nccwpck_require__(3983);
    const { dataURLProcessor, serializeAMimeType } = __nccwpck_require__(685);
    const { TransformStream } = __nccwpck_require__(5356);
    const { getGlobalDispatcher } = __nccwpck_require__(1892);
    const { webidl } = __nccwpck_require__(1744);
    const { STATUS_CODES } = __nccwpck_require__(3685);
    const GET_OR_HEAD = ["GET", "HEAD"];

    /** @type {import('buffer').resolveObjectURL} */
    let resolveObjectURL;
    let ReadableStream = globalThis.ReadableStream;

    class Fetch extends EE {
      constructor(dispatcher) {
        super();

        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        // 2 terminated listeners get added per request,
        // but only 1 gets removed. If there are 20 redirects,
        // 21 listeners will be added.
        // See https://github.com/nodejs/undici/issues/1711
        // TODO (fix): Find and fix root cause for leaked listener.
        this.setMaxListeners(21);
      }

      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }

        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }

      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }

        // 1. Set controller’s state to "aborted".
        this.state = "aborted";

        // 2. Let fallbackError be an "AbortError" DOMException.
        // 3. Set error to fallbackError if it is not given.
        if (!error) {
          error = new DOMException("The operation was aborted.", "AbortError");
        }

        // 4. Let serializedError be StructuredSerialize(error).
        //    If that threw an exception, catch it, and let
        //    serializedError be StructuredSerialize(fallbackError).

        // 5. Set controller’s serialized abort reason to serializedError.
        this.serializedAbortReason = error;

        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    }

    // https://fetch.spec.whatwg.org/#fetch-method
    function fetch(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });

      // 1. Let p be a new promise.
      const p = createDeferredPromise();

      // 2. Let requestObject be the result of invoking the initial value of
      // Request as constructor with input and init as arguments. If this throws
      // an exception, reject p with it and return p.
      let requestObject;

      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }

      // 3. Let request be requestObject’s request.
      const request = requestObject[kState];

      // 4. If requestObject’s signal’s aborted flag is set, then:
      if (requestObject.signal.aborted) {
        // 1. Abort the fetch() call with p, request, null, and
        //    requestObject’s signal’s abort reason.
        abortFetch(p, request, null, requestObject.signal.reason);

        // 2. Return p.
        return p.promise;
      }

      // 5. Let globalObject be request’s client’s global object.
      const globalObject = request.client.globalObject;

      // 6. If globalObject is a ServiceWorkerGlobalScope object, then set
      // request’s service-workers mode to "none".
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }

      // 7. Let responseObject be null.
      let responseObject = null;

      // 8. Let relevantRealm be this’s relevant Realm.
      const relevantRealm = null;

      // 9. Let locallyAborted be false.
      let locallyAborted = false;

      // 10. Let controller be null.
      let controller = null;

      // 11. Add the following abort steps to requestObject’s signal:
      addAbortListener(requestObject.signal, () => {
        // 1. Set locallyAborted to true.
        locallyAborted = true;

        // 2. Assert: controller is non-null.
        assert(controller != null);

        // 3. Abort controller with requestObject’s signal’s abort reason.
        controller.abort(requestObject.signal.reason);

        // 4. Abort the fetch() call with p, request, responseObject,
        //    and requestObject’s signal’s abort reason.
        abortFetch(p, request, responseObject, requestObject.signal.reason);
      });

      // 12. Let handleFetchDone given response response be to finalize and
      // report timing with response, globalObject, and "fetch".
      const handleFetchDone = (response) =>
        finalizeAndReportTiming(response, "fetch");

      // 13. Set controller to the result of calling fetch given request,
      // with processResponseEndOfBody set to handleFetchDone, and processResponse
      // given response being these substeps:

      const processResponse = (response) => {
        // 1. If locallyAborted is true, terminate these substeps.
        if (locallyAborted) {
          return Promise.resolve();
        }

        // 2. If response’s aborted flag is set, then:
        if (response.aborted) {
          // 1. Let deserializedError be the result of deserialize a serialized
          //    abort reason given controller’s serialized abort reason and
          //    relevantRealm.

          // 2. Abort the fetch() call with p, request, responseObject, and
          //    deserializedError.

          abortFetch(
            p,
            request,
            responseObject,
            controller.serializedAbortReason
          );
          return Promise.resolve();
        }

        // 3. If response is a network error, then reject p with a TypeError
        // and terminate these substeps.
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), {
              cause: response.error,
            })
          );
          return Promise.resolve();
        }

        // 4. Set responseObject to the result of creating a Response object,
        // given response, "immutable", and relevantRealm.
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;

        // 5. Resolve p with responseObject.
        p.resolve(responseObject);
      };

      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher(), // undici
      });

      // 14. Return p.
      return p.promise;
    }

    // https://fetch.spec.whatwg.org/#finalize-and-report-timing
    function finalizeAndReportTiming(response, initiatorType = "other") {
      // 1. If response is an aborted network error, then return.
      if (response.type === "error" && response.aborted) {
        return;
      }

      // 2. If response’s URL list is null or empty, then return.
      if (!response.urlList?.length) {
        return;
      }

      // 3. Let originalURL be response’s URL list[0].
      const originalURL = response.urlList[0];

      // 4. Let timingInfo be response’s timing info.
      let timingInfo = response.timingInfo;

      // 5. Let cacheState be response’s cache state.
      let cacheState = response.cacheState;

      // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }

      // 7. If timingInfo is null, then return.
      if (timingInfo === null) {
        return;
      }

      // 8. If response’s timing allow passed flag is not set, then:
      if (!response.timingAllowPassed) {
        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime,
        });

        //  2. Set cacheState to the empty string.
        cacheState = "";
      }

      // 9. Set timingInfo’s end time to the coarsened shared current time
      // given global’s relevant settings object’s cross-origin isolated
      // capability.
      // TODO: given global’s relevant settings object’s cross-origin isolated
      // capability?
      timingInfo.endTime = coarsenedSharedCurrentTime();

      // 10. Set response’s timing info to timingInfo.
      response.timingInfo = timingInfo;

      // 11. Mark resource timing for timingInfo, originalURL, initiatorType,
      // global, and cacheState.
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }

    // https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
    function markResourceTiming(
      timingInfo,
      originalURL,
      initiatorType,
      globalThis,
      cacheState
    ) {
      if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
        performance.markResourceTiming(
          timingInfo,
          originalURL.href,
          initiatorType,
          globalThis,
          cacheState
        );
      }
    }

    // https://fetch.spec.whatwg.org/#abort-fetch
    function abortFetch(p, request, responseObject, error) {
      // Note: AbortSignal.reason was added in node v17.2.0
      // which would give us an undefined error to reject with.
      // Remove this once node v16 is no longer supported.
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }

      // 1. Reject promise with error.
      p.reject(error);

      // 2. If request’s body is not null and is readable, then cancel request’s
      // body with error.
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            // Node bug?
            return;
          }
          throw err;
        });
      }

      // 3. If responseObject is null, then return.
      if (responseObject == null) {
        return;
      }

      // 4. Let response be responseObject’s response.
      const response = responseObject[kState];

      // 5. If response’s body is not null and is readable, then error response’s
      // body with error.
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            // Node bug?
            return;
          }
          throw err;
        });
      }
    }

    // https://fetch.spec.whatwg.org/#fetching
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher, // undici
    }) {
      // 1. Let taskDestination be null.
      let taskDestination = null;

      // 2. Let crossOriginIsolatedCapability be false.
      let crossOriginIsolatedCapability = false;

      // 3. If request’s client is non-null, then:
      if (request.client != null) {
        // 1. Set taskDestination to request’s client’s global object.
        taskDestination = request.client.globalObject;

        // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin
        // isolated capability.
        crossOriginIsolatedCapability =
          request.client.crossOriginIsolatedCapability;
      }

      // 4. If useParallelQueue is true, then set taskDestination to the result of
      // starting a new parallel queue.
      // TODO

      // 5. Let timingInfo be a new fetch timing info whose start time and
      // post-redirect start time are the coarsened shared current time given
      // crossOriginIsolatedCapability.
      const currenTime = coarsenedSharedCurrentTime(
        crossOriginIsolatedCapability
      );
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime,
      });

      // 6. Let fetchParams be a new fetch params whose
      // request is request,
      // timing info is timingInfo,
      // process request body chunk length is processRequestBodyChunkLength,
      // process request end-of-body is processRequestEndOfBody,
      // process response is processResponse,
      // process response consume body is processResponseConsumeBody,
      // process response end-of-body is processResponseEndOfBody,
      // task destination is taskDestination,
      // and cross-origin isolated capability is crossOriginIsolatedCapability.
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability,
      };

      // 7. If request’s body is a byte sequence, then set request’s body to
      //    request’s body as a body.
      // NOTE: Since fetching is only called from fetch, body should already be
      // extracted.
      assert(!request.body || request.body.stream);

      // 8. If request’s window is "client", then set request’s window to request’s
      // client, if request’s client’s global object is a Window object; otherwise
      // "no-window".
      if (request.window === "client") {
        // TODO: What if request.client is null?
        request.window =
          request.client?.globalObject?.constructor?.name === "Window"
            ? request.client
            : "no-window";
      }

      // 9. If request’s origin is "client", then set request’s origin to request’s
      // client’s origin.
      if (request.origin === "client") {
        // TODO: What if request.client is null?
        request.origin = request.client?.origin;
      }

      // 10. If all of the following conditions are true:
      // TODO

      // 11. If request’s policy container is "client", then:
      if (request.policyContainer === "client") {
        // 1. If request’s client is non-null, then set request’s policy
        // container to a clone of request’s client’s policy container. [HTML]
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          // 2. Otherwise, set request’s policy container to a new policy
          // container.
          request.policyContainer = makePolicyContainer();
        }
      }

      // 12. If request’s header list does not contain `Accept`, then:
      if (!request.headersList.contains("accept")) {
        // 1. Let value be `*/*`.
        const value = "*/*";

        // 2. A user agent should set value to the first matching statement, if
        // any, switching on request’s destination:
        // "document"
        // "frame"
        // "iframe"
        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
        // "image"
        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
        // "style"
        // `text/css,*/*;q=0.1`
        // TODO

        // 3. Append `Accept`/value to request’s header list.
        request.headersList.append("accept", value);
      }

      // 13. If request’s header list does not contain `Accept-Language`, then
      // user agents should append `Accept-Language`/an appropriate value to
      // request’s header list.
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }

      // 14. If request’s priority is null, then use request’s initiator and
      // destination appropriately in setting request’s priority to a
      // user-agent-defined object.
      if (request.priority === null) {
        // TODO
      }

      // 15. If request is a subresource request, then:
      if (subresourceSet.has(request.destination)) {
        // TODO
      }

      // 16. Run main fetch given fetchParams.
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });

      // 17. Return fetchParam's controller
      return fetchParams.controller;
    }

    // https://fetch.spec.whatwg.org/#concept-main-fetch
    async function mainFetch(fetchParams, recursive = false) {
      // 1. Let request be fetchParams’s request.
      const request = fetchParams.request;

      // 2. Let response be null.
      let response = null;

      // 3. If request’s local-URLs-only flag is set and request’s current URL is
      // not local, then set response to a network error.
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }

      // 4. Run report Content Security Policy violations for request.
      // TODO

      // 5. Upgrade request to a potentially trustworthy URL, if appropriate.
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);

      // 6. If should request be blocked due to a bad port, should fetching request
      // be blocked as mixed content, or should request be blocked by Content
      // Security Policy returns blocked, then set response to a network error.
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      // TODO: should fetching request be blocked as mixed content?
      // TODO: should request be blocked by Content Security Policy?

      // 7. If request’s referrer policy is the empty string, then set request’s
      // referrer policy to request’s policy container’s referrer policy.
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }

      // 8. If request’s referrer is not "no-referrer", then set request’s
      // referrer to the result of invoking determine request’s referrer.
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }

      // 9. Set request’s current URL’s scheme to "https" if all of the following
      // conditions are true:
      // - request’s current URL’s scheme is "http"
      // - request’s current URL’s host is a domain
      // - Matching request’s current URL’s host per Known HSTS Host Domain Name
      //   Matching results in either a superdomain match with an asserted
      //   includeSubDomains directive or a congruent match (with or without an
      //   asserted includeSubDomains directive). [HSTS]
      // TODO

      // 10. If recursive is false, then run the remaining steps in parallel.
      // TODO

      // 11. If response is null, then set response to the result of running
      // the steps corresponding to the first matching statement:
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);

          if (
            // - request’s current URL’s origin is same origin with request’s origin,
            //   and request’s response tainting is "basic"
            (sameOrigin(currentURL, request.url) &&
              request.responseTainting === "basic") ||
            // request’s current URL’s scheme is "data"
            currentURL.protocol === "data:" ||
            // - request’s mode is "navigate" or "websocket"
            request.mode === "navigate" ||
            request.mode === "websocket"
          ) {
            // 1. Set request’s response tainting to "basic".
            request.responseTainting = "basic";

            // 2. Return the result of running scheme fetch given fetchParams.
            return await schemeFetch(fetchParams);
          }

          // request’s mode is "same-origin"
          if (request.mode === "same-origin") {
            // 1. Return a network error.
            return makeNetworkError('request mode cannot be "same-origin"');
          }

          // request’s mode is "no-cors"
          if (request.mode === "no-cors") {
            // 1. If request’s redirect mode is not "follow", then return a network
            // error.
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }

            // 2. Set request’s response tainting to "opaque".
            request.responseTainting = "opaque";

            // 3. Return the result of running scheme fetch given fetchParams.
            return await schemeFetch(fetchParams);
          }

          // request’s current URL’s scheme is not an HTTP(S) scheme
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            // Return a network error.
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }

          // - request’s use-CORS-preflight flag is set
          // - request’s unsafe-request flag is set and either request’s method is
          //   not a CORS-safelisted method or CORS-unsafe request-header names with
          //   request’s header list is not empty
          //    1. Set request’s response tainting to "cors".
          //    2. Let corsWithPreflightResponse be the result of running HTTP fetch
          //    given fetchParams and true.
          //    3. If corsWithPreflightResponse is a network error, then clear cache
          //    entries using request.
          //    4. Return corsWithPreflightResponse.
          // TODO

          // Otherwise
          //    1. Set request’s response tainting to "cors".
          request.responseTainting = "cors";

          //    2. Return the result of running HTTP fetch given fetchParams.
          return await httpFetch(fetchParams);
        })();
      }

      // 12. If recursive is true, then return response.
      if (recursive) {
        return response;
      }

      // 13. If response is not a network error and response is not a filtered
      // response, then:
      if (response.status !== 0 && !response.internalResponse) {
        // If request’s response tainting is "cors", then:
        if (request.responseTainting === "cors") {
          // 1. Let headerNames be the result of extracting header list values
          // given `Access-Control-Expose-Headers` and response’s header list.
          // TODO
          // 2. If request’s credentials mode is not "include" and headerNames
          // contains `*`, then set response’s CORS-exposed header-name list to
          // all unique header names in response’s header list.
          // TODO
          // 3. Otherwise, if headerNames is not null or failure, then set
          // response’s CORS-exposed header-name list to headerNames.
          // TODO
        }

        // Set response to the following filtered response with response as its
        // internal response, depending on request’s response tainting:
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }

      // 14. Let internalResponse be response, if response is a network error,
      // and response’s internal response otherwise.
      let internalResponse =
        response.status === 0 ? response : response.internalResponse;

      // 15. If internalResponse’s URL list is empty, then set it to a clone of
      // request’s URL list.
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }

      // 16. If request’s timing allow failed flag is unset, then set
      // internalResponse’s timing allow passed flag.
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }

      // 17. If response is not a network error and any of the following returns
      // blocked
      // - should internalResponse to request be blocked as mixed content
      // - should internalResponse to request be blocked by Content Security Policy
      // - should internalResponse to request be blocked due to its MIME type
      // - should internalResponse to request be blocked due to nosniff
      // TODO

      // 18. If response’s type is "opaque", internalResponse’s status is 206,
      // internalResponse’s range-requested flag is set, and request’s header
      // list does not contain `Range`, then set response and internalResponse
      // to a network error.
      if (
        response.type === "opaque" &&
        internalResponse.status === 206 &&
        internalResponse.rangeRequested &&
        !request.headers.contains("range")
      ) {
        response = internalResponse = makeNetworkError();
      }

      // 19. If response is not a network error and either request’s method is
      // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,
      // set internalResponse’s body to null and disregard any enqueuing toward
      // it (if any).
      if (
        response.status !== 0 &&
        (request.method === "HEAD" ||
          request.method === "CONNECT" ||
          nullBodyStatus.includes(internalResponse.status))
      ) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }

      // 20. If request’s integrity metadata is not the empty string, then:
      if (request.integrity) {
        // 1. Let processBodyError be this step: run fetch finale given fetchParams
        // and a network error.
        const processBodyError = (reason) =>
          fetchFinale(fetchParams, makeNetworkError(reason));

        // 2. If request’s response tainting is "opaque", or response’s body is null,
        // then run processBodyError and abort these steps.
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }

        // 3. Let processBody given bytes be these steps:
        const processBody = (bytes) => {
          // 1. If bytes do not match request’s integrity metadata,
          // then run processBodyError and abort these steps. [SRI]
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }

          // 2. Set response’s body to bytes as a body.
          response.body = safelyExtractBody(bytes)[0];

          // 3. Run fetch finale given fetchParams and response.
          fetchFinale(fetchParams, response);
        };

        // 4. Fully read response’s body given processBody and processBodyError.
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        // 21. Otherwise, run fetch finale given fetchParams and response.
        fetchFinale(fetchParams, response);
      }
    }

    // https://fetch.spec.whatwg.org/#concept-scheme-fetch
    // given a fetch params fetchParams
    function schemeFetch(fetchParams) {
      // Note: since the connection is destroyed on redirect, which sets fetchParams to a
      // cancelled state, we do not want this condition to trigger *unless* there have been
      // no redirects. See https://github.com/nodejs/undici/issues/1776
      // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }

      // 2. Let request be fetchParams’s request.
      const { request } = fetchParams;

      const { protocol: scheme } = requestCurrentURL(request);

      // 3. Switch on request’s current URL’s scheme and run the associated steps:
      switch (scheme) {
        case "about:": {
          // If request’s current URL’s path is the string "blank", then return a new response
          // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,
          // and body is the empty byte sequence as a body.

          // Otherwise, return a network error.
          return Promise.resolve(
            makeNetworkError("about scheme is not supported")
          );
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = __nccwpck_require__(4300).resolveObjectURL;
          }

          // 1. Let blobURLEntry be request’s current URL’s blob URL entry.
          const blobURLEntry = requestCurrentURL(request);

          // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
          // Buffer.resolveObjectURL does not ignore URL queries.
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(
              makeNetworkError(
                "NetworkError when attempting to fetch resource."
              )
            );
          }

          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());

          // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s
          //    object is not a Blob object, then return a network error.
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }

          // 3. Let bodyWithType be the result of safely extracting blobURLEntry’s object.
          const bodyWithType = safelyExtractBody(blobURLEntryObject);

          // 4. Let body be bodyWithType’s body.
          const body = bodyWithType[0];

          // 5. Let length be body’s length, serialized and isomorphic encoded.
          const length = isomorphicEncode(`${body.length}`);

          // 6. Let type be bodyWithType’s type if it is non-null; otherwise the empty byte sequence.
          const type = bodyWithType[1] ?? "";

          // 7. Return a new response whose status message is `OK`, header list is
          //    « (`Content-Length`, length), (`Content-Type`, type) », and body is body.
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }],
            ],
          });

          response.body = body;

          return Promise.resolve(response);
        }
        case "data:": {
          // 1. Let dataURLStruct be the result of running the
          //    data: URL processor on request’s current URL.
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);

          // 2. If dataURLStruct is failure, then return a
          //    network error.
          if (dataURLStruct === "failure") {
            return Promise.resolve(
              makeNetworkError("failed to fetch the data URL")
            );
          }

          // 3. Let mimeType be dataURLStruct’s MIME type, serialized.
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);

          // 4. Return a response whose status message is `OK`,
          //    header list is « (`Content-Type`, mimeType) »,
          //    and body is dataURLStruct’s body as a body.
          return Promise.resolve(
            makeResponse({
              statusText: "OK",
              headersList: [
                ["content-type", { name: "Content-Type", value: mimeType }],
              ],
              body: safelyExtractBody(dataURLStruct.body)[0],
            })
          );
        }
        case "file:": {
          // For now, unfortunate as it is, file URLs are left as an exercise for the reader.
          // When in doubt, return a network error.
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          // Return the result of running HTTP fetch given fetchParams.

          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }

    // https://fetch.spec.whatwg.org/#finalize-response
    function finalizeResponse(fetchParams, response) {
      // 1. Set fetchParams’s request’s done flag.
      fetchParams.request.done = true;

      // 2, If fetchParams’s process response done is not null, then queue a fetch
      // task to run fetchParams’s process response done given response, with
      // fetchParams’s task destination.
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }

    // https://fetch.spec.whatwg.org/#fetch-finale
    function fetchFinale(fetchParams, response) {
      // 1. If response is a network error, then:
      if (response.type === "error") {
        // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».
        response.urlList = [fetchParams.request.urlList[0]];

        // 2. Set response’s timing info to the result of creating an opaque timing
        // info for fetchParams’s timing info.
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime,
        });
      }

      // 2. Let processResponseEndOfBody be the following steps:
      const processResponseEndOfBody = () => {
        // 1. Set fetchParams’s request’s done flag.
        fetchParams.request.done = true;

        // If fetchParams’s process response end-of-body is not null,
        // then queue a fetch task to run fetchParams’s process response
        // end-of-body given response with fetchParams’s task destination.
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };

      // 3. If fetchParams’s process response is non-null, then queue a fetch task
      // to run fetchParams’s process response given response, with fetchParams’s
      // task destination.
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }

      // 4. If response’s body is null, then run processResponseEndOfBody.
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        // 5. Otherwise:

        // 1. Let transformStream be a new a TransformStream.

        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,
        // enqueues chunk in transformStream.
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };

        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm
        // and flushAlgorithm set to processResponseEndOfBody.
        const transformStream = new TransformStream(
          {
            start() {},
            transform: identityTransformAlgorithm,
            flush: processResponseEndOfBody,
          },
          {
            size() {
              return 1;
            },
          },
          {
            size() {
              return 1;
            },
          }
        );

        // 4. Set response’s body to the result of piping response’s body through transformStream.
        response.body = {
          stream: response.body.stream.pipeThrough(transformStream),
        };
      }

      // 6. If fetchParams’s process response consume body is non-null, then:
      if (fetchParams.processResponseConsumeBody != null) {
        // 1. Let processBody given nullOrBytes be this step: run fetchParams’s
        // process response consume body given response and nullOrBytes.
        const processBody = (nullOrBytes) =>
          fetchParams.processResponseConsumeBody(response, nullOrBytes);

        // 2. Let processBodyError be this step: run fetchParams’s process
        // response consume body given response and failure.
        const processBodyError = (failure) =>
          fetchParams.processResponseConsumeBody(response, failure);

        // 3. If response’s body is null, then queue a fetch task to run processBody
        // given null, with fetchParams’s task destination.
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          // 4. Otherwise, fully read response’s body given processBody, processBodyError,
          // and fetchParams’s task destination.
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }

    // https://fetch.spec.whatwg.org/#http-fetch
    async function httpFetch(fetchParams) {
      // 1. Let request be fetchParams’s request.
      const request = fetchParams.request;

      // 2. Let response be null.
      let response = null;

      // 3. Let actualResponse be null.
      let actualResponse = null;

      // 4. Let timingInfo be fetchParams’s timing info.
      const timingInfo = fetchParams.timingInfo;

      // 5. If request’s service-workers mode is "all", then:
      if (request.serviceWorkers === "all") {
        // TODO
      }

      // 6. If response is null, then:
      if (response === null) {
        // 1. If makeCORSPreflight is true and one of these conditions is true:
        // TODO

        // 2. If request’s redirect mode is "follow", then set request’s
        // service-workers mode to "none".
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }

        // 3. Set response and actualResponse to the result of running
        // HTTP-network-or-cache fetch given fetchParams.
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);

        // 4. If request’s response tainting is "cors" and a CORS check
        // for request and response returns failure, then return a network error.
        if (
          request.responseTainting === "cors" &&
          corsCheck(request, response) === "failure"
        ) {
          return makeNetworkError("cors failure");
        }

        // 5. If the TAO check for request and response returns failure, then set
        // request’s timing allow failed flag.
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }

      // 7. If either request’s response tainting or response’s type
      // is "opaque", and the cross-origin resource policy check with
      // request’s origin, request’s client, request’s destination,
      // and actualResponse returns blocked, then return a network error.
      if (
        (request.responseTainting === "opaque" || response.type === "opaque") &&
        crossOriginResourcePolicyCheck(
          request.origin,
          request.client,
          request.destination,
          actualResponse
        ) === "blocked"
      ) {
        return makeNetworkError("blocked");
      }

      // 8. If actualResponse’s status is a redirect status, then:
      if (redirectStatusSet.has(actualResponse.status)) {
        // 1. If actualResponse’s status is not 303, request’s body is not null,
        // and the connection uses HTTP/2, then user agents may, and are even
        // encouraged to, transmit an RST_STREAM frame.
        // See, https://github.com/whatwg/fetch/issues/1288
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }

        // 2. Switch on request’s redirect mode:
        if (request.redirect === "error") {
          // Set response to a network error.
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          // Set response to an opaque-redirect filtered response whose internal
          // response is actualResponse.
          // NOTE(spec): On the web this would return an `opaqueredirect` response,
          // but that doesn't make sense server side.
          // See https://github.com/nodejs/undici/issues/1193.
          response = actualResponse;
        } else if (request.redirect === "follow") {
          // Set response to the result of running HTTP-redirect fetch given
          // fetchParams and response.
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }

      // 9. Set response’s timing info to timingInfo.
      response.timingInfo = timingInfo;

      // 10. Return response.
      return response;
    }

    // https://fetch.spec.whatwg.org/#http-redirect-fetch
    function httpRedirectFetch(fetchParams, response) {
      // 1. Let request be fetchParams’s request.
      const request = fetchParams.request;

      // 2. Let actualResponse be response, if response is not a filtered response,
      // and response’s internal response otherwise.
      const actualResponse = response.internalResponse
        ? response.internalResponse
        : response;

      // 3. Let locationURL be actualResponse’s location URL given request’s current
      // URL’s fragment.
      let locationURL;

      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );

        // 4. If locationURL is null, then return response.
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        // 5. If locationURL is failure, then return a network error.
        return Promise.resolve(makeNetworkError(err));
      }

      // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network
      // error.
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(
          makeNetworkError("URL scheme must be a HTTP(S) scheme")
        );
      }

      // 7. If request’s redirect count is 20, then return a network error.
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }

      // 8. Increase request’s redirect count by 1.
      request.redirectCount += 1;

      // 9. If request’s mode is "cors", locationURL includes credentials, and
      // request’s origin is not same origin with locationURL’s origin, then return
      //  a network error.
      if (
        request.mode === "cors" &&
        (locationURL.username || locationURL.password) &&
        !sameOrigin(request, locationURL)
      ) {
        return Promise.resolve(
          makeNetworkError('cross origin not allowed for request mode "cors"')
        );
      }

      // 10. If request’s response tainting is "cors" and locationURL includes
      // credentials, then return a network error.
      if (
        request.responseTainting === "cors" &&
        (locationURL.username || locationURL.password)
      ) {
        return Promise.resolve(
          makeNetworkError(
            'URL cannot contain credentials for request mode "cors"'
          )
        );
      }

      // 11. If actualResponse’s status is not 303, request’s body is non-null,
      // and request’s body’s source is null, then return a network error.
      if (
        actualResponse.status !== 303 &&
        request.body != null &&
        request.body.source == null
      ) {
        return Promise.resolve(makeNetworkError());
      }

      // 12. If one of the following is true
      // - actualResponse’s status is 301 or 302 and request’s method is `POST`
      // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`
      if (
        ([301, 302].includes(actualResponse.status) &&
          request.method === "POST") ||
        (actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method))
      ) {
        // then:
        // 1. Set request’s method to `GET` and request’s body to null.
        request.method = "GET";
        request.body = null;

        // 2. For each headerName of request-body-header name, delete headerName from
        // request’s header list.
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }

      // 13. If request’s current URL’s origin is not same origin with locationURL’s
      //     origin, then for each headerName of CORS non-wildcard request-header name,
      //     delete headerName from request’s header list.
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name
        request.headersList.delete("authorization");

        // https://fetch.spec.whatwg.org/#authentication-entries
        request.headersList.delete("proxy-authorization", true);

        // "Cookie" and "Host" are forbidden request-headers, which undici doesn't implement.
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }

      // 14. If request’s body is non-null, then set request’s body to the first return
      // value of safely extracting request’s body’s source.
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }

      // 15. Let timingInfo be fetchParams’s timing info.
      const timingInfo = fetchParams.timingInfo;

      // 16. Set timingInfo’s redirect end time and post-redirect start time to the
      // coarsened shared current time given fetchParams’s cross-origin isolated
      // capability.
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
        coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);

      // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s
      //  redirect start time to timingInfo’s start time.
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }

      // 18. Append locationURL to request’s URL list.
      request.urlList.push(locationURL);

      // 19. Invoke set request’s referrer policy on redirect on request and
      // actualResponse.
      setRequestReferrerPolicyOnRedirect(request, actualResponse);

      // 20. Return the result of running main fetch given fetchParams and true.
      return mainFetch(fetchParams, true);
    }

    // https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
    async function httpNetworkOrCacheFetch(
      fetchParams,
      isAuthenticationFetch = false,
      isNewConnectionFetch = false
    ) {
      // 1. Let request be fetchParams’s request.
      const request = fetchParams.request;

      // 2. Let httpFetchParams be null.
      let httpFetchParams = null;

      // 3. Let httpRequest be null.
      let httpRequest = null;

      // 4. Let response be null.
      let response = null;

      // 5. Let storedResponse be null.
      // TODO: cache

      // 6. Let httpCache be null.
      const httpCache = null;

      // 7. Let the revalidatingFlag be unset.
      const revalidatingFlag = false;

      // 8. Run these steps, but abort when the ongoing fetch is terminated:

      //    1. If request’s window is "no-window" and request’s redirect mode is
      //    "error", then set httpFetchParams to fetchParams and httpRequest to
      //    request.
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        // Otherwise:

        // 1. Set httpRequest to a clone of request.
        httpRequest = makeRequest(request);

        // 2. Set httpFetchParams to a copy of fetchParams.
        httpFetchParams = { ...fetchParams };

        // 3. Set httpFetchParams’s request to httpRequest.
        httpFetchParams.request = httpRequest;
      }

      //    3. Let includeCredentials be true if one of
      const includeCredentials =
        request.credentials === "include" ||
        (request.credentials === "same-origin" &&
          request.responseTainting === "basic");

      //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s
      //    body is non-null; otherwise null.
      const contentLength = httpRequest.body ? httpRequest.body.length : null;

      //    5. Let contentLengthHeaderValue be null.
      let contentLengthHeaderValue = null;

      //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or
      //    `PUT`, then set contentLengthHeaderValue to `0`.
      if (
        httpRequest.body == null &&
        ["POST", "PUT"].includes(httpRequest.method)
      ) {
        contentLengthHeaderValue = "0";
      }

      //    7. If contentLength is non-null, then set contentLengthHeaderValue to
      //    contentLength, serialized and isomorphic encoded.
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }

      //    8. If contentLengthHeaderValue is non-null, then append
      //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header
      //    list.
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append(
          "content-length",
          contentLengthHeaderValue
        );
      }

      //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
      //    contentLengthHeaderValue) to httpRequest’s header list.

      //    10. If contentLength is non-null and httpRequest’s keepalive is true,
      //    then:
      if (contentLength != null && httpRequest.keepalive) {
        // NOTE: keepalive is a noop outside of browser context.
      }

      //    11. If httpRequest’s referrer is a URL, then append
      //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,
      //     to httpRequest’s header list.
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append(
          "referer",
          isomorphicEncode(httpRequest.referrer.href)
        );
      }

      //    12. Append a request `Origin` header for httpRequest.
      appendRequestOriginHeader(httpRequest);

      //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
      appendFetchMetadata(httpRequest);

      //    14. If httpRequest’s header list does not contain `User-Agent`, then
      //    user agents should append `User-Agent`/default `User-Agent` value to
      //    httpRequest’s header list.
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append(
          "user-agent",
          typeof esbuildDetection === "undefined" ? "undici" : "node"
        );
      }

      //    15. If httpRequest’s cache mode is "default" and httpRequest’s header
      //    list contains `If-Modified-Since`, `If-None-Match`,
      //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
      //    httpRequest’s cache mode to "no-store".
      if (
        httpRequest.cache === "default" &&
        (httpRequest.headersList.contains("if-modified-since") ||
          httpRequest.headersList.contains("if-none-match") ||
          httpRequest.headersList.contains("if-unmodified-since") ||
          httpRequest.headersList.contains("if-match") ||
          httpRequest.headersList.contains("if-range"))
      ) {
        httpRequest.cache = "no-store";
      }

      //    16. If httpRequest’s cache mode is "no-cache", httpRequest’s prevent
      //    no-cache cache-control header modification flag is unset, and
      //    httpRequest’s header list does not contain `Cache-Control`, then append
      //    `Cache-Control`/`max-age=0` to httpRequest’s header list.
      if (
        httpRequest.cache === "no-cache" &&
        !httpRequest.preventNoCacheCacheControlHeaderModification &&
        !httpRequest.headersList.contains("cache-control")
      ) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }

      //    17. If httpRequest’s cache mode is "no-store" or "reload", then:
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        // 1. If httpRequest’s header list does not contain `Pragma`, then append
        // `Pragma`/`no-cache` to httpRequest’s header list.
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }

        // 2. If httpRequest’s header list does not contain `Cache-Control`,
        // then append `Cache-Control`/`no-cache` to httpRequest’s header list.
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }

      //    18. If httpRequest’s header list contains `Range`, then append
      //    `Accept-Encoding`/`identity` to httpRequest’s header list.
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }

      //    19. Modify httpRequest’s header list per HTTP. Do not append a given
      //    header if httpRequest’s header list contains that header’s name.
      //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append(
            "accept-encoding",
            "br, gzip, deflate"
          );
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }

      httpRequest.headersList.delete("host");

      //    20. If includeCredentials is true, then:
      if (includeCredentials) {
        // 1. If the user agent is not configured to block cookies for httpRequest
        // (see section 7 of [COOKIES]), then:
        // TODO: credentials
        // 2. If httpRequest’s header list does not contain `Authorization`, then:
        // TODO: credentials
      }

      //    21. If there’s a proxy-authentication entry, use it as appropriate.
      //    TODO: proxy-authentication

      //    22. Set httpCache to the result of determining the HTTP cache
      //    partition, given httpRequest.
      //    TODO: cache

      //    23. If httpCache is null, then set httpRequest’s cache mode to
      //    "no-store".
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }

      //    24. If httpRequest’s cache mode is neither "no-store" nor "reload",
      //    then:
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
        // TODO: cache
      }

      // 9. If aborted, then return the appropriate network error for fetchParams.
      // TODO

      // 10. If response is null, then:
      if (response == null) {
        // 1. If httpRequest’s cache mode is "only-if-cached", then return a
        // network error.
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }

        // 2. Let forwardResponse be the result of running HTTP-network fetch
        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );

        // 3. If httpRequest’s method is unsafe and forwardResponse’s status is
        // in the range 200 to 399, inclusive, invalidate appropriate stored
        // responses in httpCache, as per the "Invalidation" chapter of HTTP
        // Caching, and set storedResponse to null. [HTTP-CACHING]
        if (
          !safeMethodsSet.has(httpRequest.method) &&
          forwardResponse.status >= 200 &&
          forwardResponse.status <= 399
        ) {
          // TODO: cache
        }

        // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,
        // then:
        if (revalidatingFlag && forwardResponse.status === 304) {
          // TODO: cache
        }

        // 5. If response is null, then:
        if (response == null) {
          // 1. Set response to forwardResponse.
          response = forwardResponse;

          // 2. Store httpRequest and forwardResponse in httpCache, as per the
          // "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
          // TODO: cache
        }
      }

      // 11. Set response’s URL list to a clone of httpRequest’s URL list.
      response.urlList = [...httpRequest.urlList];

      // 12. If httpRequest’s header list contains `Range`, then set response’s
      // range-requested flag.
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }

      // 13. Set response’s request-includes-credentials to includeCredentials.
      response.requestIncludesCredentials = includeCredentials;

      // 14. If response’s status is 401, httpRequest’s response tainting is not
      // "cors", includeCredentials is true, and request’s window is an environment
      // settings object, then:
      // TODO

      // 15. If response’s status is 407, then:
      if (response.status === 407) {
        // 1. If request’s window is "no-window", then return a network error.
        if (request.window === "no-window") {
          return makeNetworkError();
        }

        // 2. ???

        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }

        // 4. Prompt the end user as appropriate in request’s window and store
        // the result as a proxy-authentication entry. [HTTP-AUTH]
        // TODO: Invoke some kind of callback?

        // 5. Set response to the result of running HTTP-network-or-cache fetch given
        // fetchParams.
        // TODO
        return makeNetworkError("proxy authentication required");
      }

      // 16. If all of the following are true
      if (
        // response’s status is 421
        response.status === 421 &&
        // isNewConnectionFetch is false
        !isNewConnectionFetch &&
        // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        // then:

        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }

        // 2. Set response to the result of running HTTP-network-or-cache
        // fetch given fetchParams, isAuthenticationFetch, and true.

        // TODO (spec): The spec doesn't specify this but we need to cancel
        // the active response before we can start a new one.
        // https://github.com/whatwg/fetch/issues/1293
        fetchParams.controller.connection.destroy();

        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }

      // 17. If isAuthenticationFetch is true, then create an authentication entry
      if (isAuthenticationFetch) {
        // TODO
      }

      // 18. Return response.
      return response;
    }

    // https://fetch.spec.whatwg.org/#http-network-fetch
    async function httpNetworkFetch(
      fetchParams,
      includeCredentials = false,
      forceNewConnection = false
    ) {
      assert(
        !fetchParams.controller.connection ||
          fetchParams.controller.connection.destroyed
      );

      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(
              err ??
                new DOMException("The operation was aborted.", "AbortError")
            );
          }
        },
      };

      // 1. Let request be fetchParams’s request.
      const request = fetchParams.request;

      // 2. Let response be null.
      let response = null;

      // 3. Let timingInfo be fetchParams’s timing info.
      const timingInfo = fetchParams.timingInfo;

      // 4. Let httpCache be the result of determining the HTTP cache partition,
      // given request.
      // TODO: cache
      const httpCache = null;

      // 5. If httpCache is null, then set request’s cache mode to "no-store".
      if (httpCache == null) {
        request.cache = "no-store";
      }

      // 6. Let networkPartitionKey be the result of determining the network
      // partition key given request.
      // TODO

      // 7. Let newConnection be "yes" if forceNewConnection is true; otherwise
      // "no".
      const newConnection = forceNewConnection ? "yes" : "no"; // eslint-disable-line no-unused-vars

      // 8. Switch on request’s mode:
      if (request.mode === "websocket") {
        // Let connection be the result of obtaining a WebSocket connection,
        // given request’s current URL.
        // TODO
      } else {
        // Let connection be the result of obtaining a connection, given
        // networkPartitionKey, request’s current URL’s origin,
        // includeCredentials, and forceNewConnection.
        // TODO
      }

      // 9. Run these steps, but abort when the ongoing fetch is terminated:

      //    1. If connection is failure, then return a network error.

      //    2. Set timingInfo’s final connection timing info to the result of
      //    calling clamp and coarsen connection timing info with connection’s
      //    timing info, timingInfo’s post-redirect start time, and fetchParams’s
      //    cross-origin isolated capability.

      //    3. If connection is not an HTTP/2 connection, request’s body is non-null,
      //    and request’s body’s source is null, then append (`Transfer-Encoding`,
      //    `chunked`) to request’s header list.

      //    4. Set timingInfo’s final network-request start time to the coarsened
      //    shared current time given fetchParams’s cross-origin isolated
      //    capability.

      //    5. Set response to the result of making an HTTP request over connection
      //    using request with the following caveats:

      //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
      //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

      //        - If request’s body is non-null, and request’s body’s source is null,
      //        then the user agent may have a buffer of up to 64 kibibytes and store
      //        a part of request’s body in that buffer. If the user agent reads from
      //        request’s body beyond that buffer’s size and the user agent needs to
      //        resend request, then instead return a network error.

      //        - Set timingInfo’s final network-response start time to the coarsened
      //        shared current time given fetchParams’s cross-origin isolated capability,
      //        immediately after the user agent’s HTTP parser receives the first byte
      //        of the response (e.g., frame header bytes for HTTP/2 or response status
      //        line for HTTP/1.x).

      //        - Wait until all the headers are transmitted.

      //        - Any responses whose status is in the range 100 to 199, inclusive,
      //        and is not 101, are to be ignored, except for the purposes of setting
      //        timingInfo’s final network-response start time above.

      //    - If request’s header list contains `Transfer-Encoding`/`chunked` and
      //    response is transferred via HTTP/1.0 or older, then return a network
      //    error.

      //    - If the HTTP request results in a TLS client certificate dialog, then:

      //        1. If request’s window is an environment settings object, make the
      //        dialog available in request’s window.

      //        2. Otherwise, return a network error.

      // To transmit request’s body body, run these steps:
      let requestBody = null;
      // 1. If body is null and fetchParams’s process request end-of-body is
      // non-null, then queue a fetch task given fetchParams’s process request
      // end-of-body and fetchParams’s task destination.
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        // 2. Otherwise, if body is non-null:

        //    1. Let processBodyChunk given bytes be these steps:
        const processBodyChunk = async function* (bytes) {
          // 1. If the ongoing fetch is terminated, then abort these steps.
          if (isCancelled(fetchParams)) {
            return;
          }

          // 2. Run this step in parallel: transmit bytes.
          yield bytes;

          // 3. If fetchParams’s process request body is non-null, then run
          // fetchParams’s process request body given bytes’s length.
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };

        // 2. Let processEndOfBody be these steps:
        const processEndOfBody = () => {
          // 1. If fetchParams is canceled, then abort these steps.
          if (isCancelled(fetchParams)) {
            return;
          }

          // 2. If fetchParams’s process request end-of-body is non-null,
          // then run fetchParams’s process request end-of-body.
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };

        // 3. Let processBodyError given e be these steps:
        const processBodyError = (e) => {
          // 1. If fetchParams is canceled, then abort these steps.
          if (isCancelled(fetchParams)) {
            return;
          }

          // 2. If e is an "AbortError" DOMException, then abort fetchParams’s controller.
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };

        // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,
        // processBodyError, and fetchParams’s task destination.
        requestBody = (async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        })();
      }

      try {
        // socket is only provided for websockets
        const { body, status, statusText, headersList, socket } =
          await dispatch({ body: requestBody });

        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();

          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        // 10. If aborted, then:
        if (err.name === "AbortError") {
          // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
          fetchParams.controller.connection.destroy();

          // 2. Return the appropriate network error for fetchParams.
          return makeAppropriateNetworkError(fetchParams, err);
        }

        return makeNetworkError(err);
      }

      // 11. Let pullAlgorithm be an action that resumes the ongoing fetch
      // if it is suspended.
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };

      // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s
      // controller with reason, given reason.
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };

      // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
      // the user agent.
      // TODO

      // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
      // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
      // TODO

      // 15. Let stream be a new ReadableStream.
      // 16. Set up stream with pullAlgorithm set to pullAlgorithm,
      // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to
      // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.
      if (!ReadableStream) {
        ReadableStream = __nccwpck_require__(5356).ReadableStream;
      }

      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          },
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          },
        }
      );

      // 17. Run these steps, but abort when the ongoing fetch is terminated:

      //    1. Set response’s body to a new body whose stream is stream.
      response.body = { stream };

      //    2. If response is not a network error and request’s cache mode is
      //    not "no-store", then update response in httpCache for request.
      //    TODO

      //    3. If includeCredentials is true and the user agent is not configured
      //    to block cookies for request (see section 7 of [COOKIES]), then run the
      //    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
      //    the value of each header whose name is a byte-case-insensitive match for
      //    `Set-Cookie` in response’s header list, if any, and request’s current URL.
      //    TODO

      // 18. If aborted, then:
      // TODO

      // 19. Run these steps in parallel:

      //    1. Run these steps, but abort when fetchParams is canceled:
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        // 1. While true
        while (true) {
          // 1-3. See onData...

          // 4. Set bytes to the result of handling content codings given
          // codings and bytes.
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();

            if (isAborted(fetchParams)) {
              break;
            }

            bytes = done ? undefined : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              // zlib doesn't like empty streams.
              bytes = undefined;
            } else {
              bytes = err;

              // err may be propagated from the result of calling readablestream.cancel,
              // which might not be an error. https://github.com/nodejs/undici/issues/2009
              isFailure = true;
            }
          }

          if (bytes === undefined) {
            // 2. Otherwise, if the bytes transmission for response’s message
            // body is done normally and stream is readable, then close
            // stream, finalize response for fetchParams and response, and
            // abort these in-parallel steps.
            readableStreamClose(fetchParams.controller.controller);

            finalizeResponse(fetchParams, response);

            return;
          }

          // 5. Increase timingInfo’s decoded body size by bytes’s length.
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;

          // 6. If bytes is failure, then terminate fetchParams’s controller.
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }

          // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
          // into stream.
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));

          // 8. If stream is errored, then terminate the ongoing fetch.
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }

          // 9. If stream doesn’t need more data ask the user agent to suspend
          // the ongoing fetch.
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };

      //    2. If aborted, then:
      function onAborted(reason) {
        // 2. If fetchParams is aborted, then:
        if (isAborted(fetchParams)) {
          // 1. Set response’s aborted flag.
          response.aborted = true;

          // 2. If stream is readable, then error stream with the result of
          //    deserialize a serialized abort reason given fetchParams’s
          //    controller’s serialized abort reason and an
          //    implementation-defined realm.
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          // 3. Otherwise, if stream is readable, error stream with a TypeError.
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              new TypeError("terminated", {
                cause: isErrorLike(reason) ? reason : undefined,
              })
            );
          }
        }

        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
        fetchParams.controller.connection.destroy();
      }

      // 20. Return response.
      return response;

      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        /** @type {import('../..').Agent} */
        const agent = fetchParams.controller.dispatcher;

        return new Promise((resolve, reject) =>
          agent.dispatch(
            {
              path: url.pathname + url.search,
              origin: url.origin,
              method: request.method,
              body: fetchParams.controller.dispatcher.isMockActive
                ? request.body && (request.body.source || request.body.stream)
                : body,
              headers: request.headersList.entries,
              maxRedirections: 0,
              upgrade: request.mode === "websocket" ? "websocket" : undefined,
            },
            {
              body: null,
              abort: null,

              onConnect(abort) {
                // TODO (fix): Do we need connection here?
                const { connection } = fetchParams.controller;

                if (connection.destroyed) {
                  abort(
                    new DOMException("The operation was aborted.", "AbortError")
                  );
                } else {
                  fetchParams.controller.on("terminated", abort);
                  this.abort = connection.abort = abort;
                }
              },

              onHeaders(status, headersList, resume, statusText) {
                if (status < 200) {
                  return;
                }

                let codings = [];
                let location = "";

                const headers = new Headers();

                // For H2, the headers are a plain JS object
                // We distinguish between them and iterate accordingly
                if (Array.isArray(headersList)) {
                  for (let n = 0; n < headersList.length; n += 2) {
                    const key = headersList[n + 0].toString("latin1");
                    const val = headersList[n + 1].toString("latin1");
                    if (key.toLowerCase() === "content-encoding") {
                      // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
                      // "All content-coding values are case-insensitive..."
                      codings = val
                        .toLowerCase()
                        .split(",")
                        .map((x) => x.trim());
                    } else if (key.toLowerCase() === "location") {
                      location = val;
                    }

                    headers[kHeadersList].append(key, val);
                  }
                } else {
                  const keys = Object.keys(headersList);
                  for (const key of keys) {
                    const val = headersList[key];
                    if (key.toLowerCase() === "content-encoding") {
                      // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
                      // "All content-coding values are case-insensitive..."
                      codings = val
                        .toLowerCase()
                        .split(",")
                        .map((x) => x.trim())
                        .reverse();
                    } else if (key.toLowerCase() === "location") {
                      location = val;
                    }

                    headers[kHeadersList].append(key, val);
                  }
                }

                this.body = new Readable({ read: resume });

                const decoders = [];

                const willFollow =
                  request.redirect === "follow" &&
                  location &&
                  redirectStatusSet.has(status);

                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
                if (
                  request.method !== "HEAD" &&
                  request.method !== "CONNECT" &&
                  !nullBodyStatus.includes(status) &&
                  !willFollow
                ) {
                  for (const coding of codings) {
                    // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
                    if (coding === "x-gzip" || coding === "gzip") {
                      decoders.push(
                        zlib.createGunzip({
                          // Be less strict when decoding compressed responses, since sometimes
                          // servers send slightly invalid responses that are still accepted
                          // by common browsers.
                          // Always using Z_SYNC_FLUSH is what cURL does.
                          flush: zlib.constants.Z_SYNC_FLUSH,
                          finishFlush: zlib.constants.Z_SYNC_FLUSH,
                        })
                      );
                    } else if (coding === "deflate") {
                      decoders.push(zlib.createInflate());
                    } else if (coding === "br") {
                      decoders.push(zlib.createBrotliDecompress());
                    } else {
                      decoders.length = 0;
                      break;
                    }
                  }
                }

                resolve({
                  status,
                  statusText,
                  headersList: headers[kHeadersList],
                  body: decoders.length
                    ? pipeline(this.body, ...decoders, () => {})
                    : this.body.on("error", () => {}),
                });

                return true;
              },

              onData(chunk) {
                if (fetchParams.controller.dump) {
                  return;
                }

                // 1. If one or more bytes have been transmitted from response’s
                // message body, then:

                //  1. Let bytes be the transmitted bytes.
                const bytes = chunk;

                //  2. Let codings be the result of extracting header list values
                //  given `Content-Encoding` and response’s header list.
                //  See pullAlgorithm.

                //  3. Increase timingInfo’s encoded body size by bytes’s length.
                timingInfo.encodedBodySize += bytes.byteLength;

                //  4. See pullAlgorithm...

                return this.body.push(bytes);
              },

              onComplete() {
                if (this.abort) {
                  fetchParams.controller.off("terminated", this.abort);
                }

                fetchParams.controller.ended = true;

                this.body.push(null);
              },

              onError(error) {
                if (this.abort) {
                  fetchParams.controller.off("terminated", this.abort);
                }

                this.body?.destroy(error);

                fetchParams.controller.terminate(error);

                reject(error);
              },

              onUpgrade(status, headersList, socket) {
                if (status !== 101) {
                  return;
                }

                const headers = new Headers();

                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");

                  headers[kHeadersList].append(key, val);
                }

                resolve({
                  status,
                  statusText: STATUS_CODES[status],
                  headersList: headers[kHeadersList],
                  socket,
                });

                return true;
              },
            }
          )
        );
      }
    }

    module.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming,
    };

    /***/
  },

  /***/ 8359: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /* globals AbortController */

    const { extractBody, mixinBody, cloneBody } = __nccwpck_require__(1472);
    const {
      Headers,
      fill: fillHeaders,
      HeadersList,
    } = __nccwpck_require__(554);
    const { FinalizationRegistry } = __nccwpck_require__(6436)();
    const util = __nccwpck_require__(3983);
    const {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord,
    } = __nccwpck_require__(2538);
    const {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex,
    } = __nccwpck_require__(1037);
    const { kEnumerableProperty } = util;
    const { kHeaders, kSignal, kState, kGuard, kRealm } =
      __nccwpck_require__(5861);
    const { webidl } = __nccwpck_require__(1744);
    const { getGlobalOrigin } = __nccwpck_require__(1246);
    const { URLSerializer } = __nccwpck_require__(685);
    const { kHeadersList, kConstruct } = __nccwpck_require__(2785);
    const assert = __nccwpck_require__(9491);
    const {
      getMaxListeners,
      setMaxListeners,
      getEventListeners,
      defaultMaxListeners,
    } = __nccwpck_require__(2361);

    let TransformStream = globalThis.TransformStream;

    const kAbortController = Symbol("abortController");

    const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });

    // https://fetch.spec.whatwg.org/#request-class
    class Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct) {
          return;
        }

        webidl.argumentLengthCheck(arguments, 1, {
          header: "Request constructor",
        });

        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);

        // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer(),
          },
        };

        // 1. Let request be null.
        let request = null;

        // 2. Let fallbackMode be null.
        let fallbackMode = null;

        // 3. Let baseURL be this’s relevant settings object’s API base URL.
        const baseUrl = this[kRealm].settingsObject.baseUrl;

        // 4. Let signal be null.
        let signal = null;

        // 5. If input is a string, then:
        if (typeof input === "string") {
          // 1. Let parsedURL be the result of parsing input with baseURL.
          // 2. If parsedURL is failure, then throw a TypeError.
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, {
              cause: err,
            });
          }

          // 3. If parsedURL includes credentials, then throw a TypeError.
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " +
                input
            );
          }

          // 4. Set request to a new request whose URL is parsedURL.
          request = makeRequest({ urlList: [parsedURL] });

          // 5. Set fallbackMode to "cors".
          fallbackMode = "cors";
        } else {
          // 6. Otherwise:

          // 7. Assert: input is a Request object.
          assert(input instanceof Request);

          // 8. Set request to input’s request.
          request = input[kState];

          // 9. Set signal to input’s signal.
          signal = input[kSignal];
        }

        // 7. Let origin be this’s relevant settings object’s origin.
        const origin = this[kRealm].settingsObject.origin;

        // 8. Let window be "client".
        let window = "client";

        // 9. If request’s window is an environment settings object and its origin
        // is same origin with origin, then set window to request’s window.
        if (
          request.window?.constructor?.name === "EnvironmentSettingsObject" &&
          sameOrigin(request.window, origin)
        ) {
          window = request.window;
        }

        // 10. If init["window"] exists and is non-null, then throw a TypeError.
        if (init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }

        // 11. If init["window"] exists, then set window to "no-window".
        if ("window" in init) {
          window = "no-window";
        }

        // 12. Set request to a new request with the following properties:
        request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList],
        });

        const initHasKey = Object.keys(init).length !== 0;

        // 13. If init is not empty, then:
        if (initHasKey) {
          // 1. If request’s mode is "navigate", then set it to "same-origin".
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }

          // 2. Unset request’s reload-navigation flag.
          request.reloadNavigation = false;

          // 3. Unset request’s history-navigation flag.
          request.historyNavigation = false;

          // 4. Set request’s origin to "client".
          request.origin = "client";

          // 5. Set request’s referrer to "client"
          request.referrer = "client";

          // 6. Set request’s referrer policy to the empty string.
          request.referrerPolicy = "";

          // 7. Set request’s URL to request’s current URL.
          request.url = request.urlList[request.urlList.length - 1];

          // 8. Set request’s URL list to « request’s URL ».
          request.urlList = [request.url];
        }

        // 14. If init["referrer"] exists, then:
        if (init.referrer !== undefined) {
          // 1. Let referrer be init["referrer"].
          const referrer = init.referrer;

          // 2. If referrer is the empty string, then set request’s referrer to "no-referrer".
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            // 1. Let parsedReferrer be the result of parsing referrer with
            // baseURL.
            // 2. If parsedReferrer is failure, then throw a TypeError.
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(
                `Referrer "${referrer}" is not a valid URL.`,
                { cause: err }
              );
            }

            // 3. If one of the following is true
            // - parsedReferrer’s scheme is "about" and path is the string "client"
            // - parsedReferrer’s origin is not same origin with origin
            // then set request’s referrer to "client".
            if (
              (parsedReferrer.protocol === "about:" &&
                parsedReferrer.hostname === "client") ||
              (origin &&
                !sameOrigin(
                  parsedReferrer,
                  this[kRealm].settingsObject.baseUrl
                ))
            ) {
              request.referrer = "client";
            } else {
              // 4. Otherwise, set request’s referrer to parsedReferrer.
              request.referrer = parsedReferrer;
            }
          }
        }

        // 15. If init["referrerPolicy"] exists, then set request’s referrer policy
        // to it.
        if (init.referrerPolicy !== undefined) {
          request.referrerPolicy = init.referrerPolicy;
        }

        // 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
        let mode;
        if (init.mode !== undefined) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }

        // 17. If mode is "navigate", then throw a TypeError.
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate.",
          });
        }

        // 18. If mode is non-null, set request’s mode to mode.
        if (mode != null) {
          request.mode = mode;
        }

        // 19. If init["credentials"] exists, then set request’s credentials mode
        // to it.
        if (init.credentials !== undefined) {
          request.credentials = init.credentials;
        }

        // 18. If init["cache"] exists, then set request’s cache mode to it.
        if (init.cache !== undefined) {
          request.cache = init.cache;
        }

        // 21. If request’s cache mode is "only-if-cached" and request’s mode is
        // not "same-origin", then throw a TypeError.
        if (
          request.cache === "only-if-cached" &&
          request.mode !== "same-origin"
        ) {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }

        // 22. If init["redirect"] exists, then set request’s redirect mode to it.
        if (init.redirect !== undefined) {
          request.redirect = init.redirect;
        }

        // 23. If init["integrity"] exists, then set request’s integrity metadata to it.
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }

        // 24. If init["keepalive"] exists, then set request’s keepalive to it.
        if (init.keepalive !== undefined) {
          request.keepalive = Boolean(init.keepalive);
        }

        // 25. If init["method"] exists, then:
        if (init.method !== undefined) {
          // 1. Let method be init["method"].
          let method = init.method;

          // 2. If method is not a method or method is a forbidden method, then
          // throw a TypeError.
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }

          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }

          // 3. Normalize method.
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);

          // 4. Set request’s method to method.
          request.method = method;
        }

        // 26. If init["signal"] exists, then set signal to it.
        if (init.signal !== undefined) {
          signal = init.signal;
        }

        // 27. Set this’s request to request.
        this[kState] = request;

        // 28. Set this’s signal to a new AbortSignal object with this’s relevant
        // Realm.
        // TODO: could this be simplified with AbortSignal.any
        // (https://dom.spec.whatwg.org/#dom-abortsignal-any)
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];

        // 29. If signal is not null, then make this’s signal follow signal.
        if (signal != null) {
          if (
            !signal ||
            typeof signal.aborted !== "boolean" ||
            typeof signal.addEventListener !== "function"
          ) {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }

          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            // Keep a strong ref to ac while request object
            // is alive. This is needed to prevent AbortController
            // from being prematurely garbage collected.
            // See, https://github.com/nodejs/undici/issues/1926.
            this[kAbortController] = ac;

            const acRef = new WeakRef(ac);
            const abort = function () {
              const ac = acRef.deref();
              if (ac !== undefined) {
                ac.abort(this.reason);
              }
            };

            // Third-party AbortControllers may not work with these.
            // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.
            try {
              // If the max amount of listeners is equal to the default, increase it
              // This is only available in node >= v19.9.0
              if (
                typeof getMaxListeners === "function" &&
                getMaxListeners(signal) === defaultMaxListeners
              ) {
                setMaxListeners(100, signal);
              } else if (
                getEventListeners(signal, "abort").length >= defaultMaxListeners
              ) {
                setMaxListeners(100, signal);
              }
            } catch {}

            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }

        // 30. Set this’s headers to a new Headers object with this’s relevant
        // Realm, whose header list is request’s header list and guard is
        // "request".
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];

        // 31. If this’s request’s mode is "no-cors", then:
        if (mode === "no-cors") {
          // 1. If this’s request’s method is not a CORS-safelisted method,
          // then throw a TypeError.
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }

          // 2. Set this’s headers’s guard to "request-no-cors".
          this[kHeaders][kGuard] = "request-no-cors";
        }

        // 32. If init is not empty, then:
        if (initHasKey) {
          /** @type {HeadersList} */
          const headersList = this[kHeaders][kHeadersList];
          // 1. Let headers be a copy of this’s headers and its associated header
          // list.
          // 2. If init["headers"] exists, then set headers to init["headers"].
          const headers =
            init.headers !== undefined
              ? init.headers
              : new HeadersList(headersList);

          // 3. Empty this’s headers’s header list.
          headersList.clear();

          // 4. If headers is a Headers object, then for each header in its header
          // list, append header’s name/header’s value to this’s headers.
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            // Note: Copy the `set-cookie` meta-data.
            headersList.cookies = headers.cookies;
          } else {
            // 5. Otherwise, fill this’s headers with headers.
            fillHeaders(this[kHeaders], headers);
          }
        }

        // 33. Let inputBody be input’s request’s body if input is a Request
        // object; otherwise null.
        const inputBody = input instanceof Request ? input[kState].body : null;

        // 34. If either init["body"] exists and is non-null or inputBody is
        // non-null, and request’s method is `GET` or `HEAD`, then throw a
        // TypeError.
        if (
          (init.body != null || inputBody != null) &&
          (request.method === "GET" || request.method === "HEAD")
        ) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }

        // 35. Let initBody be null.
        let initBody = null;

        // 36. If init["body"] exists and is non-null, then:
        if (init.body != null) {
          // 1. Let Content-Type be null.
          // 2. Set initBody and Content-Type to the result of extracting
          // init["body"], with keepalive set to request’s keepalive.
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;

          // 3, If Content-Type is non-null and this’s headers’s header list does
          // not contain `Content-Type`, then append `Content-Type`/Content-Type to
          // this’s headers.
          if (
            contentType &&
            !this[kHeaders][kHeadersList].contains("content-type")
          ) {
            this[kHeaders].append("content-type", contentType);
          }
        }

        // 37. Let inputOrInitBody be initBody if it is non-null; otherwise
        // inputBody.
        const inputOrInitBody = initBody ?? inputBody;

        // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is
        // null, then:
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          // 1. If initBody is non-null and init["duplex"] does not exist,
          //    then throw a TypeError.
          if (initBody != null && init.duplex == null) {
            throw new TypeError(
              "RequestInit: duplex option is required when sending a body."
            );
          }

          // 2. If this’s request’s mode is neither "same-origin" nor "cors",
          // then throw a TypeError.
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }

          // 3. Set this’s request’s use-CORS-preflight flag.
          request.useCORSPreflightFlag = true;
        }

        // 39. Let finalBody be inputOrInitBody.
        let finalBody = inputOrInitBody;

        // 40. If initBody is null and inputBody is non-null, then:
        if (initBody == null && inputBody != null) {
          // 1. If input is unusable, then throw a TypeError.
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }

          // 2. Set finalBody to the result of creating a proxy for inputBody.
          if (!TransformStream) {
            TransformStream = __nccwpck_require__(5356).TransformStream;
          }

          // https://streams.spec.whatwg.org/#readablestream-create-a-proxy
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable,
          };
        }

        // 41. Set this’s request’s body to finalBody.
        this[kState].body = finalBody;
      }

      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, Request);

        // The method getter steps are to return this’s request’s method.
        return this[kState].method;
      }

      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, Request);

        // The url getter steps are to return this’s request’s URL, serialized.
        return URLSerializer(this[kState].url);
      }

      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, Request);

        // The headers getter steps are to return this’s headers.
        return this[kHeaders];
      }

      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, Request);

        // The destination getter are to return this’s request’s destination.
        return this[kState].destination;
      }

      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, Request);

        // 1. If this’s request’s referrer is "no-referrer", then return the
        // empty string.
        if (this[kState].referrer === "no-referrer") {
          return "";
        }

        // 2. If this’s request’s referrer is "client", then return
        // "about:client".
        if (this[kState].referrer === "client") {
          return "about:client";
        }

        // Return this’s request’s referrer, serialized.
        return this[kState].referrer.toString();
      }

      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, Request);

        // The referrerPolicy getter steps are to return this’s request’s referrer policy.
        return this[kState].referrerPolicy;
      }

      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, Request);

        // The mode getter steps are to return this’s request’s mode.
        return this[kState].mode;
      }

      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        // The credentials getter steps are to return this’s request’s credentials mode.
        return this[kState].credentials;
      }

      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, Request);

        // The cache getter steps are to return this’s request’s cache mode.
        return this[kState].cache;
      }

      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, Request);

        // The redirect getter steps are to return this’s request’s redirect mode.
        return this[kState].redirect;
      }

      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, Request);

        // The integrity getter steps are to return this’s request’s integrity
        // metadata.
        return this[kState].integrity;
      }

      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, Request);

        // The keepalive getter steps are to return this’s request’s keepalive.
        return this[kState].keepalive;
      }

      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, Request);

        // The isReloadNavigation getter steps are to return true if this’s
        // request’s reload-navigation flag is set; otherwise false.
        return this[kState].reloadNavigation;
      }

      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, Request);

        // The isHistoryNavigation getter steps are to return true if this’s request’s
        // history-navigation flag is set; otherwise false.
        return this[kState].historyNavigation;
      }

      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, Request);

        // The signal getter steps are to return this’s signal.
        return this[kSignal];
      }

      get body() {
        webidl.brandCheck(this, Request);

        return this[kState].body ? this[kState].body.stream : null;
      }

      get bodyUsed() {
        webidl.brandCheck(this, Request);

        return (
          !!this[kState].body && util.isDisturbed(this[kState].body.stream)
        );
      }

      get duplex() {
        webidl.brandCheck(this, Request);

        return "half";
      }

      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, Request);

        // 1. If this is unusable, then throw a TypeError.
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }

        // 2. Let clonedRequest be the result of cloning this’s request.
        const clonedRequest = cloneRequest(this[kState]);

        // 3. Let clonedRequestObject be the result of creating a Request object,
        // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.
        const clonedRequestObject = new Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];

        // 4. Make clonedRequestObject’s signal follow this’s signal.
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(this.signal, () => {
            ac.abort(this.signal.reason);
          });
        }
        clonedRequestObject[kSignal] = ac.signal;

        // 4. Return clonedRequestObject.
        return clonedRequestObject;
      }
    }

    mixinBody(Request);

    function makeRequest(init) {
      // https://fetch.spec.whatwg.org/#requests
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList
          ? new HeadersList(init.headersList)
          : new HeadersList(),
      };
      request.url = request.urlList[0];
      return request;
    }

    // https://fetch.spec.whatwg.org/#concept-request-clone
    function cloneRequest(request) {
      // To clone a request request, run these steps:

      // 1. Let newRequest be a copy of request, except for its body.
      const newRequest = makeRequest({ ...request, body: null });

      // 2. If request’s body is non-null, set newRequest’s body to the
      // result of cloning request’s body.
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }

      // 3. Return newRequest.
      return newRequest;
    }

    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true,
      },
    });

    webidl.converters.Request = webidl.interfaceConverter(Request);

    // https://fetch.spec.whatwg.org/#requestinfo
    webidl.converters.RequestInfo = function (V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }

      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }

      return webidl.converters.USVString(V);
    };

    webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);

    // https://fetch.spec.whatwg.org/#requestinit
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString,
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit,
      },
      {
        key: "body",
        converter: webidl.nullableConverter(webidl.converters.BodyInit),
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString,
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy,
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode,
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials,
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache,
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect,
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString,
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean,
      },
      {
        key: "signal",
        converter: webidl.nullableConverter((signal) =>
          webidl.converters.AbortSignal(signal, { strict: false })
        ),
      },
      {
        key: "window",
        converter: webidl.converters.any,
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex,
      },
    ]);

    module.exports = { Request, makeRequest };

    /***/
  },

  /***/ 7823: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { Headers, HeadersList, fill } = __nccwpck_require__(554);
    const { extractBody, cloneBody, mixinBody } = __nccwpck_require__(1472);
    const util = __nccwpck_require__(3983);
    const { kEnumerableProperty } = util;
    const {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode,
    } = __nccwpck_require__(2538);
    const { redirectStatusSet, nullBodyStatus, DOMException } =
      __nccwpck_require__(1037);
    const { kState, kHeaders, kGuard, kRealm } = __nccwpck_require__(5861);
    const { webidl } = __nccwpck_require__(1744);
    const { FormData } = __nccwpck_require__(2015);
    const { getGlobalOrigin } = __nccwpck_require__(1246);
    const { URLSerializer } = __nccwpck_require__(685);
    const { kHeadersList, kConstruct } = __nccwpck_require__(2785);
    const assert = __nccwpck_require__(9491);
    const { types } = __nccwpck_require__(3837);

    const ReadableStream =
      globalThis.ReadableStream || __nccwpck_require__(5356).ReadableStream;
    const textEncoder = new TextEncoder("utf-8");

    // https://fetch.spec.whatwg.org/#response-class
    class Response {
      // Creates network error Response.
      static error() {
        // TODO
        const relevantRealm = { settingsObject: {} };

        // The static error() method steps are to return the result of creating a
        // Response object, given a new network error, "immutable", and this’s
        // relevant Realm.
        const responseObject = new Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] =
          responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }

      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });

        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }

        // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );

        // 2. Let body be the result of extracting bytes.
        const body = extractBody(bytes);

        // 3. Let responseObject be the result of creating a Response object, given a new response,
        //    "response", and this’s relevant Realm.
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;

        // 4. Perform initialize a response given responseObject, init, and (body, "application/json").
        initializeResponse(responseObject, init, {
          body: body[0],
          type: "application/json",
        });

        // 5. Return responseObject.
        return responseObject;
      }

      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };

        webidl.argumentLengthCheck(arguments, 1, {
          header: "Response.redirect",
        });

        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);

        // 1. Let parsedURL be the result of parsing url with current settings
        // object’s API base URL.
        // 2. If parsedURL is failure, then throw a TypeError.
        // TODO: base-URL?
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(
            new TypeError("Failed to parse URL from " + url),
            {
              cause: err,
            }
          );
        }

        // 3. If status is not a redirect status, then throw a RangeError.
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }

        // 4. Let responseObject be the result of creating a Response object,
        // given a new response, "immutable", and this’s relevant Realm.
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;

        // 5. Set responseObject’s response’s status to status.
        responseObject[kState].status = status;

        // 6. Let value be parsedURL, serialized and isomorphic encoded.
        const value = isomorphicEncode(URLSerializer(parsedURL));

        // 7. Append `Location`/value to responseObject’s response’s header list.
        responseObject[kState].headersList.append("location", value);

        // 8. Return responseObject.
        return responseObject;
      }

      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }

        init = webidl.converters.ResponseInit(init);

        // TODO
        this[kRealm] = { settingsObject: {} };

        // 1. Set this’s response to a new response.
        this[kState] = makeResponse({});

        // 2. Set this’s headers to a new Headers object with this’s relevant
        // Realm, whose header list is this’s response’s header list and guard
        // is "response".
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];

        // 3. Let bodyWithType be null.
        let bodyWithType = null;

        // 4. If body is non-null, then set bodyWithType to the result of extracting body.
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }

        // 5. Perform initialize a response given this, init, and bodyWithType.
        initializeResponse(this, init, bodyWithType);
      }

      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, Response);

        // The type getter steps are to return this’s response’s type.
        return this[kState].type;
      }

      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, Response);

        const urlList = this[kState].urlList;

        // The url getter steps are to return the empty string if this’s
        // response’s URL is null; otherwise this’s response’s URL,
        // serialized with exclude fragment set to true.
        const url = urlList[urlList.length - 1] ?? null;

        if (url === null) {
          return "";
        }

        return URLSerializer(url, true);
      }

      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, Response);

        // The redirected getter steps are to return true if this’s response’s URL
        // list has more than one item; otherwise false.
        return this[kState].urlList.length > 1;
      }

      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, Response);

        // The status getter steps are to return this’s response’s status.
        return this[kState].status;
      }

      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, Response);

        // The ok getter steps are to return true if this’s response’s status is an
        // ok status; otherwise false.
        return this[kState].status >= 200 && this[kState].status <= 299;
      }

      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, Response);

        // The statusText getter steps are to return this’s response’s status
        // message.
        return this[kState].statusText;
      }

      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, Response);

        // The headers getter steps are to return this’s headers.
        return this[kHeaders];
      }

      get body() {
        webidl.brandCheck(this, Response);

        return this[kState].body ? this[kState].body.stream : null;
      }

      get bodyUsed() {
        webidl.brandCheck(this, Response);

        return (
          !!this[kState].body && util.isDisturbed(this[kState].body.stream)
        );
      }

      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, Response);

        // 1. If this is unusable, then throw a TypeError.
        if (this.bodyUsed || (this.body && this.body.locked)) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed.",
          });
        }

        // 2. Let clonedResponse be the result of cloning this’s response.
        const clonedResponse = cloneResponse(this[kState]);

        // 3. Return the result of creating a Response object, given
        // clonedResponse, this’s headers’s guard, and this’s relevant Realm.
        const clonedResponseObject = new Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] =
          clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];

        return clonedResponseObject;
      }
    }

    mixinBody(Response);

    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true,
      },
    });

    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty,
    });

    // https://fetch.spec.whatwg.org/#concept-response-clone
    function cloneResponse(response) {
      // To clone a response response, run these steps:

      // 1. If response is a filtered response, then return a new identical
      // filtered response whose internal response is a clone of response’s
      // internal response.
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }

      // 2. Let newResponse be a copy of response, except for its body.
      const newResponse = makeResponse({ ...response, body: null });

      // 3. If response’s body is non-null, then set newResponse’s body to the
      // result of cloning response’s body.
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }

      // 4. Return newResponse.
      return newResponse;
    }

    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList
          ? new HeadersList(init.headersList)
          : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : [],
      };
    }

    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError",
      });
    }

    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state,
      };

      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        },
      });
    }

    // https://fetch.spec.whatwg.org/#concept-filtered-response
    function filterResponse(response, type) {
      // Set response to the following filtered response with response as its
      // internal response, depending on request’s response tainting:
      if (type === "basic") {
        // A basic filtered response is a filtered response whose type is "basic"
        // and header list excludes any headers in internal response’s header list
        // whose name is a forbidden response-header name.

        // Note: undici does not implement forbidden response-header names
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList,
        });
      } else if (type === "cors") {
        // A CORS filtered response is a filtered response whose type is "cors"
        // and header list excludes any headers in internal response’s header
        // list whose name is not a CORS-safelisted response-header name, given
        // internal response’s CORS-exposed header-name list.

        // Note: undici does not implement CORS-safelisted response-header names
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList,
        });
      } else if (type === "opaque") {
        // An opaque filtered response is a filtered response whose type is
        // "opaque", URL list is the empty list, status is 0, status message
        // is the empty byte sequence, header list is empty, and body is null.

        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null,
        });
      } else if (type === "opaqueredirect") {
        // An opaque-redirect filtered response is a filtered response whose type
        // is "opaqueredirect", status is 0, status message is the empty byte
        // sequence, header list is empty, and body is null.

        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null,
        });
      } else {
        assert(false);
      }
    }

    // https://fetch.spec.whatwg.org/#appropriate-network-error
    function makeAppropriateNetworkError(fetchParams, err = null) {
      // 1. Assert: fetchParams is canceled.
      assert(isCancelled(fetchParams));

      // 2. Return an aborted network error if fetchParams is aborted;
      // otherwise return a network error.
      return isAborted(fetchParams)
        ? makeNetworkError(
            Object.assign(
              new DOMException("The operation was aborted.", "AbortError"),
              { cause: err }
            )
          )
        : makeNetworkError(
            Object.assign(new DOMException("Request was cancelled."), {
              cause: err,
            })
          );
    }

    // https://whatpr.org/fetch/1392.html#initialize-a-response
    function initializeResponse(response, init, body) {
      // 1. If init["status"] is not in the range 200 to 599, inclusive, then
      //    throw a RangeError.
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError(
          'init["status"] must be in the range of 200 to 599, inclusive.'
        );
      }

      // 2. If init["statusText"] does not match the reason-phrase token production,
      //    then throw a TypeError.
      if ("statusText" in init && init.statusText != null) {
        // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
        //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }

      // 3. Set response’s response’s status to init["status"].
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }

      // 4. Set response’s response’s status message to init["statusText"].
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }

      // 5. If init["headers"] exists, then fill response’s headers with init["headers"].
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }

      // 6. If body was given, then:
      if (body) {
        // 1. If response's status is a null body status, then throw a TypeError.
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status,
          });
        }

        // 2. Set response's body to body's body.
        response[kState].body = body.body;

        // 3. If body's type is non-null and response's header list does not contain
        //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
        if (
          body.type != null &&
          !response[kState].headersList.contains("Content-Type")
        ) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }

    webidl.converters.ReadableStream =
      webidl.interfaceConverter(ReadableStream);

    webidl.converters.FormData = webidl.interfaceConverter(FormData);

    webidl.converters.URLSearchParams =
      webidl.interfaceConverter(URLSearchParams);

    // https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
    webidl.converters.XMLHttpRequestBodyInit = function (V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }

      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }

      if (
        types.isArrayBuffer(V) ||
        types.isTypedArray(V) ||
        types.isDataView(V)
      ) {
        return webidl.converters.BufferSource(V);
      }

      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }

      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }

      return webidl.converters.DOMString(V);
    };

    // https://fetch.spec.whatwg.org/#bodyinit
    webidl.converters.BodyInit = function (V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }

      // Note: the spec doesn't include async iterables,
      // this is an undici extension.
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }

      return webidl.converters.XMLHttpRequestBodyInit(V);
    };

    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200,
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: "",
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit,
      },
    ]);

    module.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse,
    };

    /***/
  },

  /***/ 5861: /***/ (module) => {
    module.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm"),
    };

    /***/
  },

  /***/ 2538: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const {
      redirectStatusSet,
      referrerPolicySet: referrerPolicyTokens,
      badPortsSet,
    } = __nccwpck_require__(1037);
    const { getGlobalOrigin } = __nccwpck_require__(1246);
    const { performance } = __nccwpck_require__(4074);
    const { isBlobLike, toUSVString, ReadableStreamFrom } =
      __nccwpck_require__(3983);
    const assert = __nccwpck_require__(9491);
    const { isUint8Array } = __nccwpck_require__(9830);

    let supportedHashes = [];

    // https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable
    /** @type {import('crypto')|undefined} */
    let crypto;

    try {
      crypto = __nccwpck_require__(6113);
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto
        .getHashes()
        .filter((hash) => possibleRelevantHashes.includes(hash));
      /* c8 ignore next 3 */
    } catch {}

    function responseURL(response) {
      // https://fetch.spec.whatwg.org/#responses
      // A response has an associated URL. It is a pointer to the last URL
      // in response’s URL list and null if response’s URL list is empty.
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }

    // https://fetch.spec.whatwg.org/#concept-response-location-url
    function responseLocationURL(response, requestFragment) {
      // 1. If response’s status is not a redirect status, then return null.
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }

      // 2. Let location be the result of extracting header list values given
      // `Location` and response’s header list.
      let location = response.headersList.get("location");

      // 3. If location is a header value, then set location to the result of
      //    parsing location with response’s URL.
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }

      // 4. If location is a URL whose fragment is null, then set location’s
      // fragment to requestFragment.
      if (location && !location.hash) {
        location.hash = requestFragment;
      }

      // 5. Return location.
      return location;
    }

    /** @returns {URL} */
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }

    function requestBadPort(request) {
      // 1. Let url be request’s current URL.
      const url = requestCurrentURL(request);

      // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,
      // then return blocked.
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }

      // 3. Return allowed.
      return "allowed";
    }

    function isErrorLike(object) {
      return (
        object instanceof Error ||
        object?.constructor?.name === "Error" ||
        object?.constructor?.name === "DOMException"
      );
    }

    // Check whether |statusText| is a ByteString and
    // matches the Reason-Phrase token production.
    // RFC 2616: https://tools.ietf.org/html/rfc2616
    // RFC 7230: https://tools.ietf.org/html/rfc7230
    // "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
    // https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (
          !(
            (
              c === 0x09 || // HTAB
              (c >= 0x20 && c <= 0x7e) || // SP / VCHAR
              (c >= 0x80 && c <= 0xff)
            ) // obs-text
          )
        ) {
          return false;
        }
      }
      return true;
    }

    /**
     * @see https://tools.ietf.org/html/rfc7230#section-3.2.6
     * @param {number} c
     */
    function isTokenCharCode(c) {
      switch (c) {
        case 0x22:
        case 0x28:
        case 0x29:
        case 0x2c:
        case 0x2f:
        case 0x3a:
        case 0x3b:
        case 0x3c:
        case 0x3d:
        case 0x3e:
        case 0x3f:
        case 0x40:
        case 0x5b:
        case 0x5c:
        case 0x5d:
        case 0x7b:
        case 0x7d:
          // DQUOTE and "(),/:;<=>?@[\]{}"
          return false;
        default:
          // VCHAR %x21-7E
          return c >= 0x21 && c <= 0x7e;
      }
    }

    /**
     * @param {string} characters
     */
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }

    /**
     * @see https://fetch.spec.whatwg.org/#header-name
     * @param {string} potentialValue
     */
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }

    /**
     * @see https://fetch.spec.whatwg.org/#header-value
     * @param {string} potentialValue
     */
    function isValidHeaderValue(potentialValue) {
      // - Has no leading or trailing HTTP tab or space bytes.
      // - Contains no 0x00 (NUL) or HTTP newline bytes.
      if (
        potentialValue.startsWith("\t") ||
        potentialValue.startsWith(" ") ||
        potentialValue.endsWith("\t") ||
        potentialValue.endsWith(" ")
      ) {
        return false;
      }

      if (
        potentialValue.includes("\0") ||
        potentialValue.includes("\r") ||
        potentialValue.includes("\n")
      ) {
        return false;
      }

      return true;
    }

    // https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      //  Given a request request and a response actualResponse, this algorithm
      //  updates request’s referrer policy according to the Referrer-Policy
      //  header (if any) in actualResponse.

      // 1. Let policy be the result of executing § 8.1 Parse a referrer policy
      // from a Referrer-Policy header on actualResponse.

      // 8.1 Parse a referrer policy from a Referrer-Policy header
      // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.
      const { headersList } = actualResponse;
      // 2. Let policy be the empty string.
      // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.
      // 4. Return policy.
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(
        ","
      );

      // Note: As the referrer-policy can contain multiple policies
      // separated by comma, we need to loop through all of them
      // and pick the first valid one.
      // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy
      let policy = "";
      if (policyHeader.length > 0) {
        // The right-most policy takes precedence.
        // The left-most policy is the fallback.
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }

      // 2. If policy is not the empty string, then set request’s referrer policy to policy.
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }

    // https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
    function crossOriginResourcePolicyCheck() {
      // TODO
      return "allowed";
    }

    // https://fetch.spec.whatwg.org/#concept-cors-check
    function corsCheck() {
      // TODO
      return "success";
    }

    // https://fetch.spec.whatwg.org/#concept-tao-check
    function TAOCheck() {
      // TODO
      return "success";
    }

    function appendFetchMetadata(httpRequest) {
      //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
      //  TODO

      //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

      //  1. Assert: r’s url is a potentially trustworthy URL.
      //  TODO

      //  2. Let header be a Structured Header whose value is a token.
      let header = null;

      //  3. Set header’s value to r’s mode.
      header = httpRequest.mode;

      //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.
      httpRequest.headersList.set("sec-fetch-mode", header);

      //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
      //  TODO

      //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
      //  TODO
    }

    // https://fetch.spec.whatwg.org/#append-a-request-origin-header
    function appendRequestOriginHeader(request) {
      // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
      let serializedOrigin = request.origin;

      // 2. If request’s response tainting is "cors" or request’s mode is "websocket", then append (`Origin`, serializedOrigin) to request’s header list.
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }

        // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        // 1. Switch on request’s referrer policy:
        switch (request.referrerPolicy) {
          case "no-referrer":
            // Set serializedOrigin to `null`.
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            // If request’s origin is a tuple origin, its scheme is "https", and request’s current URL’s scheme is not "https", then set serializedOrigin to `null`.
            if (
              request.origin &&
              urlHasHttpsScheme(request.origin) &&
              !urlHasHttpsScheme(requestCurrentURL(request))
            ) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
          // Do nothing.
        }

        if (serializedOrigin) {
          // 2. Append (`Origin`, serializedOrigin) to request’s header list.
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }

    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      // TODO
      return performance.now();
    }

    // https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null,
      };
    }

    // https://html.spec.whatwg.org/multipage/origin.html#policy-container
    function makePolicyContainer() {
      // Note: the fetch spec doesn't make use of embedder policy or CSP list
      return {
        referrerPolicy: "strict-origin-when-cross-origin",
      };
    }

    // https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy,
      };
    }

    // https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
    function determineRequestsReferrer(request) {
      // 1. Let policy be request's referrer policy.
      const policy = request.referrerPolicy;

      // Note: policy cannot (shouldn't) be null or an empty string.
      assert(policy);

      // 2. Let environment be request’s client.

      let referrerSource = null;

      // 3. Switch on request’s referrer:
      if (request.referrer === "client") {
        // Note: node isn't a browser and doesn't implement document/iframes,
        // so we bypass this step and replace it with our own.

        const globalOrigin = getGlobalOrigin();

        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }

        // note: we need to clone it as it's mutated
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        // Let referrerSource be request’s referrer.
        referrerSource = request.referrer;
      }

      // 4. Let request’s referrerURL be the result of stripping referrerSource for
      //    use as a referrer.
      let referrerURL = stripURLForReferrer(referrerSource);

      // 5. Let referrerOrigin be the result of stripping referrerSource for use as
      //    a referrer, with the origin-only flag set to true.
      const referrerOrigin = stripURLForReferrer(referrerSource, true);

      // 6. If the result of serializing referrerURL is a string whose length is
      //    greater than 4096, set referrerURL to referrerOrigin.
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }

      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy =
        isURLPotentiallyTrustworthy(referrerURL) &&
        !isURLPotentiallyTrustworthy(request.url);

      // 8. Execute the switch statements corresponding to the value of policy:
      switch (policy) {
        case "origin":
          return referrerOrigin != null
            ? referrerOrigin
            : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);

          // 1. If the origin of referrerURL and the origin of request’s current
          //    URL are the same, then return referrerURL.
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }

          // 2. If referrerURL is a potentially trustworthy URL and request’s
          //    current URL is not a potentially trustworthy URL, then return no
          //    referrer.
          if (
            isURLPotentiallyTrustworthy(referrerURL) &&
            !isURLPotentiallyTrustworthy(currentURL)
          ) {
            return "no-referrer";
          }

          // 3. Return referrerOrigin.
          return referrerOrigin;
        }
        case "strict-origin": // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
         */
        case "no-referrer-when-downgrade": // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
         */

        default: // eslint-disable-line
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }

    /**
     * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
     * @param {URL} url
     * @param {boolean|undefined} originOnly
     */
    function stripURLForReferrer(url, originOnly) {
      // 1. Assert: url is a URL.
      assert(url instanceof URL);

      // 2. If url’s scheme is a local scheme, then return no referrer.
      if (
        url.protocol === "file:" ||
        url.protocol === "about:" ||
        url.protocol === "blank:"
      ) {
        return "no-referrer";
      }

      // 3. Set url’s username to the empty string.
      url.username = "";

      // 4. Set url’s password to the empty string.
      url.password = "";

      // 5. Set url’s fragment to null.
      url.hash = "";

      // 6. If the origin-only flag is true, then:
      if (originOnly) {
        // 1. Set url’s path to « the empty string ».
        url.pathname = "";

        // 2. Set url’s query to null.
        url.search = "";
      }

      // 7. Return url.
      return url;
    }

    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }

      // If child of about, return true
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }

      // If scheme is data, return true
      if (url.protocol === "data:") return true;

      // If file, return true
      if (url.protocol === "file:") return true;

      return isOriginPotentiallyTrustworthy(url.origin);

      function isOriginPotentiallyTrustworthy(origin) {
        // If origin is explicitly null, return false
        if (origin == null || origin === "null") return false;

        const originAsURL = new URL(origin);

        // If secure, return true
        if (
          originAsURL.protocol === "https:" ||
          originAsURL.protocol === "wss:"
        ) {
          return true;
        }

        // If localhost or variants, return true
        if (
          /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(
            originAsURL.hostname
          ) ||
          originAsURL.hostname === "localhost" ||
          originAsURL.hostname.includes("localhost.") ||
          originAsURL.hostname.endsWith(".localhost")
        ) {
          return true;
        }

        // If any other, return false
        return false;
      }
    }

    /**
     * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
     * @param {Uint8Array} bytes
     * @param {string} metadataList
     */
    function bytesMatch(bytes, metadataList) {
      // If node is not built with OpenSSL support, we cannot check
      // a request's integrity, so allow it by default (the spec will
      // allow requests if an invalid hash is given, as precedence).
      /* istanbul ignore if: only if node is built with --without-ssl */
      if (crypto === undefined) {
        return true;
      }

      // 1. Let parsedMetadata be the result of parsing metadataList.
      const parsedMetadata = parseMetadata(metadataList);

      // 2. If parsedMetadata is no metadata, return true.
      if (parsedMetadata === "no metadata") {
        return true;
      }

      // 3. If response is not eligible for integrity validation, return false.
      // TODO

      // 4. If parsedMetadata is the empty set, return true.
      if (parsedMetadata.length === 0) {
        return true;
      }

      // 5. Let metadata be the result of getting the strongest
      //    metadata from parsedMetadata.
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);

      // 6. For each item in metadata:
      for (const item of metadata) {
        // 1. Let algorithm be the alg component of item.
        const algorithm = item.algo;

        // 2. Let expectedValue be the val component of item.
        const expectedValue = item.hash;

        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e
        // "be liberal with padding". This is annoying, and it's not even in the spec.

        // 3. Let actualValue be the result of applying algorithm to bytes.
        let actualValue = crypto
          .createHash(algorithm)
          .update(bytes)
          .digest("base64");

        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }

        // 4. If actualValue is a case-sensitive match for expectedValue,
        //    return true.
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }

      // 7. Return false.
      return false;
    }

    // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options
    // https://www.w3.org/TR/CSP2/#source-list-syntax
    // https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
    const parseHashWithOptions =
      /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;

    /**
     * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
     * @param {string} metadata
     */
    function parseMetadata(metadata) {
      // 1. Let result be the empty set.
      /** @type {{ algo: string, hash: string }[]} */
      const result = [];

      // 2. Let empty be equal to true.
      let empty = true;

      // 3. For each token returned by splitting metadata on spaces:
      for (const token of metadata.split(" ")) {
        // 1. Set empty to false.
        empty = false;

        // 2. Parse token as a hash-with-options.
        const parsedToken = parseHashWithOptions.exec(token);

        // 3. If token does not parse, continue to the next token.
        if (
          parsedToken === null ||
          parsedToken.groups === undefined ||
          parsedToken.groups.algo === undefined
        ) {
          // Note: Chromium blocks the request at this point, but Firefox
          // gives a warning that an invalid integrity was given. The
          // correct behavior is to ignore these, and subsequently not
          // check the integrity of the resource.
          continue;
        }

        // 4. Let algorithm be the hash-algo component of token.
        const algorithm = parsedToken.groups.algo.toLowerCase();

        // 5. If algorithm is a hash function recognized by the user
        //    agent, add the parsed token to result.
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }

      // 4. Return no metadata if empty is true, otherwise return result.
      if (empty === true) {
        return "no metadata";
      }

      return result;
    }

    /**
     * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
     */
    function getStrongestMetadata(metadataList) {
      // Let algorithm be the algo component of the first item in metadataList.
      // Can be sha256
      let algorithm = metadataList[0].algo;
      // If the algorithm is sha512, then it is the strongest
      // and we can return immediately
      if (algorithm[3] === "5") {
        return algorithm;
      }

      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        // If the algorithm is sha512, then it is the strongest
        // and we can break the loop immediately
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
          // If the algorithm is sha384, then a potential sha256 or sha384 is ignored
        } else if (algorithm[3] === "3") {
          continue;
          // algorithm is sha256, check if algorithm is sha384 and if so, set it as
          // the strongest
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }

    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }

      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }

      metadataList.length = pos;

      return metadataList;
    }

    /**
     * Compares two base64 strings, allowing for base64url
     * in the second string.
     *
     * @param {string} actualValue always base64
     * @param {string} expectedValue base64 or base64url
     * @returns {boolean}
     */
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (
            (actualValue[i] === "+" && expectedValue[i] === "-") ||
            (actualValue[i] === "/" && expectedValue[i] === "_")
          ) {
            continue;
          }
          return false;
        }
      }

      return true;
    }

    // https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
      // TODO
    }

    /**
     * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
     * @param {URL} A
     * @param {URL} B
     */
    function sameOrigin(A, B) {
      // 1. If A and B are the same opaque origin, then return true.
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }

      // 2. If A and B are both tuple origins and their schemes,
      //    hosts, and port are identical, then return true.
      if (
        A.protocol === B.protocol &&
        A.hostname === B.hostname &&
        A.port === B.port
      ) {
        return true;
      }

      // 3. Return false.
      return false;
    }

    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });

      return { promise, resolve: res, reject: rej };
    }

    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }

    function isCancelled(fetchParams) {
      return (
        fetchParams.controller.state === "aborted" ||
        fetchParams.controller.state === "terminated"
      );
    }

    const normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT",
    };

    // Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
    Object.setPrototypeOf(normalizeMethodRecord, null);

    /**
     * @see https://fetch.spec.whatwg.org/#concept-method-normalize
     * @param {string} method
     */
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }

    // https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
    function serializeJavascriptValueToJSONString(value) {
      // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).
      const result = JSON.stringify(value);

      // 2. If result is undefined, then throw a TypeError.
      if (result === undefined) {
        throw new TypeError("Value is not JSON serializable");
      }

      // 3. Assert: result is a string.
      assert(typeof result === "string");

      // 4. Return result.
      return result;
    }

    // https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
    const esIteratorPrototype = Object.getPrototypeOf(
      Object.getPrototypeOf([][Symbol.iterator]())
    );

    /**
     * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
     * @param {() => unknown[]} iterator
     * @param {string} name name of the instance
     * @param {'key'|'value'|'key+value'} kind
     */
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator,
      };

      const i = {
        next() {
          // 1. Let interface be the interface for which the iterator prototype object exists.

          // 2. Let thisValue be the this value.

          // 3. Let object be ? ToObject(thisValue).

          // 4. If object is a platform object, then perform a security
          //    check, passing:

          // 5. If object is not a default iterator object for interface,
          //    then throw a TypeError.
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }

          // 6. Let index be object’s index.
          // 7. Let kind be object’s kind.
          // 8. Let values be object’s target's value pairs to iterate over.
          const { index, kind, target } = object;
          const values = target();

          // 9. Let len be the length of values.
          const len = values.length;

          // 10. If index is greater than or equal to len, then return
          //     CreateIterResultObject(undefined, true).
          if (index >= len) {
            return { value: undefined, done: true };
          }

          // 11. Let pair be the entry in values at index index.
          const pair = values[index];

          // 12. Set object’s index to index + 1.
          object.index = index + 1;

          // 13. Return the iterator result for pair and kind.
          return iteratorResult(pair, kind);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`,
      };

      // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
      Object.setPrototypeOf(i, esIteratorPrototype);
      // esIteratorPrototype needs to be the prototype of i
      // which is the prototype of an empty object. Yes, it's confusing.
      return Object.setPrototypeOf({}, i);
    }

    // https://webidl.spec.whatwg.org/#iterator-result
    function iteratorResult(pair, kind) {
      let result;

      // 1. Let result be a value determined by the value of kind:
      switch (kind) {
        case "key": {
          // 1. Let idlKey be pair’s key.
          // 2. Let key be the result of converting idlKey to an
          //    ECMAScript value.
          // 3. result is key.
          result = pair[0];
          break;
        }
        case "value": {
          // 1. Let idlValue be pair’s value.
          // 2. Let value be the result of converting idlValue to
          //    an ECMAScript value.
          // 3. result is value.
          result = pair[1];
          break;
        }
        case "key+value": {
          // 1. Let idlKey be pair’s key.
          // 2. Let idlValue be pair’s value.
          // 3. Let key be the result of converting idlKey to an
          //    ECMAScript value.
          // 4. Let value be the result of converting idlValue to
          //    an ECMAScript value.
          // 5. Let array be ! ArrayCreate(2).
          // 6. Call ! CreateDataProperty(array, "0", key).
          // 7. Call ! CreateDataProperty(array, "1", value).
          // 8. result is array.
          result = pair;
          break;
        }
      }

      // 2. Return CreateIterResultObject(result, false).
      return { value: result, done: false };
    }

    /**
     * @see https://fetch.spec.whatwg.org/#body-fully-read
     */
    async function fullyReadBody(body, processBody, processBodyError) {
      // 1. If taskDestination is null, then set taskDestination to
      //    the result of starting a new parallel queue.

      // 2. Let successSteps given a byte sequence bytes be to queue a
      //    fetch task to run processBody given bytes, with taskDestination.
      const successSteps = processBody;

      // 3. Let errorSteps be to queue a fetch task to run processBodyError,
      //    with taskDestination.
      const errorSteps = processBodyError;

      // 4. Let reader be the result of getting a reader for body’s stream.
      //    If that threw an exception, then run errorSteps with that
      //    exception and return.
      let reader;

      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }

      // 5. Read all bytes from reader, given successSteps and errorSteps.
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }

    /** @type {ReadableStream} */
    let ReadableStream = globalThis.ReadableStream;

    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = __nccwpck_require__(5356).ReadableStream;
      }

      return (
        stream instanceof ReadableStream ||
        (stream[Symbol.toStringTag] === "ReadableStream" &&
          typeof stream.tee === "function")
      );
    }

    const MAXIMUM_ARGUMENT_LENGTH = 65535;

    /**
     * @see https://infra.spec.whatwg.org/#isomorphic-decode
     * @param {number[]|Uint8Array} input
     */
    function isomorphicDecode(input) {
      // 1. To isomorphic decode a byte sequence input, return a string whose code point
      //    length is equal to input’s length and whose code points have the same values
      //    as the values of input’s bytes, in the same order.

      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }

      return input.reduce(
        (previous, current) => previous + String.fromCharCode(current),
        ""
      );
    }

    /**
     * @param {ReadableStreamController<Uint8Array>} controller
     */
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        // TODO: add comment explaining why this error occurs.
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }

    /**
     * @see https://infra.spec.whatwg.org/#isomorphic-encode
     * @param {string} input
     */
    function isomorphicEncode(input) {
      // 1. Assert: input contains no code points greater than U+00FF.
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 0xff);
      }

      // 2. Return a byte sequence whose length is equal to input’s code
      //    point length and whose bytes have the same values as the
      //    values of input’s code points, in the same order
      return input;
    }

    /**
     * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
     * @see https://streams.spec.whatwg.org/#read-loop
     * @param {ReadableStreamDefaultReader} reader
     */
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;

      while (true) {
        const { done, value: chunk } = await reader.read();

        if (done) {
          // 1. Call successSteps with bytes.
          return Buffer.concat(bytes, byteLength);
        }

        // 1. If chunk is not a Uint8Array object, call failureSteps
        //    with a TypeError and abort these steps.
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }

        // 2. Append the bytes represented by chunk to bytes.
        bytes.push(chunk);
        byteLength += chunk.length;

        // 3. Read-loop given reader, bytes, successSteps, and failureSteps.
      }
    }

    /**
     * @see https://fetch.spec.whatwg.org/#is-local
     * @param {URL} url
     */
    function urlIsLocal(url) {
      assert("protocol" in url); // ensure it's a url object

      const protocol = url.protocol;

      return (
        protocol === "about:" || protocol === "blob:" || protocol === "data:"
      );
    }

    /**
     * @param {string|URL} url
     */
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }

      return url.protocol === "https:";
    }

    /**
     * @see https://fetch.spec.whatwg.org/#http-scheme
     * @param {URL} url
     */
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url); // ensure it's a url object

      const protocol = url.protocol;

      return protocol === "http:" || protocol === "https:";
    }

    /**
     * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
     */
    const hasOwn =
      Object.hasOwn ||
      ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));

    module.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata,
    };

    /***/
  },

  /***/ 1744: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { types } = __nccwpck_require__(3837);
    const { hasOwn, toUSVString } = __nccwpck_require__(2538);

    /** @type {import('../../types/webidl').Webidl} */
    const webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};

    webidl.errors.exception = function (message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };

    webidl.errors.conversionFailed = function (context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message =
        `${context.argument} could not be converted to` +
        `${plural}: ${context.types.join(", ")}.`;

      return webidl.errors.exception({
        header: context.prefix,
        message,
      });
    };

    webidl.errors.invalidArgument = function (context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`,
      });
    };

    // https://webidl.spec.whatwg.org/#implements
    webidl.brandCheck = function (V, I, opts = undefined) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };

    webidl.argumentLengthCheck = function ({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message:
            `${min} argument${min !== 1 ? "s" : ""} required, ` +
            `but${length ? " only" : ""} ${length} found.`,
          ...ctx,
        });
      }
    };

    webidl.illegalConstructor = function () {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor",
      });
    };

    // https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
    webidl.util.Type = function (V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }

          return "Object";
        }
      }
    };

    // https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
    webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;

      // 1. If bitLength is 64, then:
      if (bitLength === 64) {
        // 1. Let upperBound be 2^53 − 1.
        upperBound = Math.pow(2, 53) - 1;

        // 2. If signedness is "unsigned", then let lowerBound be 0.
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          // 3. Otherwise let lowerBound be −2^53 + 1.
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        // 2. Otherwise, if signedness is "unsigned", then:

        // 1. Let lowerBound be 0.
        lowerBound = 0;

        // 2. Let upperBound be 2^bitLength − 1.
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        // 3. Otherwise:

        // 1. Let lowerBound be -2^bitLength − 1.
        lowerBound = Math.pow(-2, bitLength) - 1;

        // 2. Let upperBound be 2^bitLength − 1 − 1.
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }

      // 4. Let x be ? ToNumber(V).
      let x = Number(V);

      // 5. If x is −0, then set x to +0.
      if (x === 0) {
        x = 0;
      }

      // 6. If the conversion is to an IDL type associated
      //    with the [EnforceRange] extended attribute, then:
      if (opts.enforceRange === true) {
        // 1. If x is NaN, +∞, or −∞, then throw a TypeError.
        if (
          Number.isNaN(x) ||
          x === Number.POSITIVE_INFINITY ||
          x === Number.NEGATIVE_INFINITY
        ) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`,
          });
        }

        // 2. Set x to IntegerPart(x).
        x = webidl.util.IntegerPart(x);

        // 3. If x < lowerBound or x > upperBound, then
        //    throw a TypeError.
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`,
          });
        }

        // 4. Return x.
        return x;
      }

      // 7. If x is not NaN and the conversion is to an IDL
      //    type associated with the [Clamp] extended
      //    attribute, then:
      if (!Number.isNaN(x) && opts.clamp === true) {
        // 1. Set x to min(max(x, lowerBound), upperBound).
        x = Math.min(Math.max(x, lowerBound), upperBound);

        // 2. Round x to the nearest integer, choosing the
        //    even integer if it lies halfway between two,
        //    and choosing +0 rather than −0.
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }

        // 3. Return x.
        return x;
      }

      // 8. If x is NaN, +0, +∞, or −∞, then return +0.
      if (
        Number.isNaN(x) ||
        (x === 0 && Object.is(0, x)) ||
        x === Number.POSITIVE_INFINITY ||
        x === Number.NEGATIVE_INFINITY
      ) {
        return 0;
      }

      // 9. Set x to IntegerPart(x).
      x = webidl.util.IntegerPart(x);

      // 10. Set x to x modulo 2^bitLength.
      x = x % Math.pow(2, bitLength);

      // 11. If signedness is "signed" and x ≥ 2^bitLength − 1,
      //    then return x − 2^bitLength.
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }

      // 12. Otherwise, return x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
    webidl.util.IntegerPart = function (n) {
      // 1. Let r be floor(abs(n)).
      const r = Math.floor(Math.abs(n));

      // 2. If n < 0, then return -1 × r.
      if (n < 0) {
        return -1 * r;
      }

      // 3. Otherwise, return r.
      return r;
    };

    // https://webidl.spec.whatwg.org/#es-sequence
    webidl.sequenceConverter = function (converter) {
      return (V) => {
        // 1. If Type(V) is not Object, throw a TypeError.
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`,
          });
        }

        // 2. Let method be ? GetMethod(V, @@iterator).
        /** @type {Generator} */
        const method = V?.[Symbol.iterator]?.();
        const seq = [];

        // 3. If method is undefined, throw a TypeError.
        if (method === undefined || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator.",
          });
        }

        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable
        while (true) {
          const { done, value } = method.next();

          if (done) {
            break;
          }

          seq.push(converter(value));
        }

        return seq;
      };
    };

    // https://webidl.spec.whatwg.org/#es-to-record
    webidl.recordConverter = function (keyConverter, valueConverter) {
      return (O) => {
        // 1. If Type(O) is not Object, throw a TypeError.
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`,
          });
        }

        // 2. Let result be a new empty instance of record<K, V>.
        const result = {};

        if (!types.isProxy(O)) {
          // Object.keys only returns enumerable properties
          const keys = Object.keys(O);

          for (const key of keys) {
            // 1. Let typedKey be key converted to an IDL value of type K.
            const typedKey = keyConverter(key);

            // 2. Let value be ? Get(O, key).
            // 3. Let typedValue be value converted to an IDL value of type V.
            const typedValue = valueConverter(O[key]);

            // 4. Set result[typedKey] to typedValue.
            result[typedKey] = typedValue;
          }

          // 5. Return result.
          return result;
        }

        // 3. Let keys be ? O.[[OwnPropertyKeys]]().
        const keys = Reflect.ownKeys(O);

        // 4. For each key of keys.
        for (const key of keys) {
          // 1. Let desc be ? O.[[GetOwnProperty]](key).
          const desc = Reflect.getOwnPropertyDescriptor(O, key);

          // 2. If desc is not undefined and desc.[[Enumerable]] is true:
          if (desc?.enumerable) {
            // 1. Let typedKey be key converted to an IDL value of type K.
            const typedKey = keyConverter(key);

            // 2. Let value be ? Get(O, key).
            // 3. Let typedValue be value converted to an IDL value of type V.
            const typedValue = valueConverter(O[key]);

            // 4. Set result[typedKey] to typedValue.
            result[typedKey] = typedValue;
          }
        }

        // 5. Return result.
        return result;
      };
    };

    webidl.interfaceConverter = function (i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`,
          });
        }

        return V;
      };
    };

    webidl.dictionaryConverter = function (converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};

        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`,
          });
        }

        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;

          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`,
              });
            }
          }

          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");

          // Only use defaultValue if value is undefined and
          // a defaultValue options was provided.
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }

          // A key can be optional and have no default value.
          // When this happens, do not perform a conversion,
          // and do not assign the key a value.
          if (required || hasDefault || value !== undefined) {
            value = converter(value);

            if (
              options.allowedValues &&
              !options.allowedValues.includes(value)
            ) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`,
              });
            }

            dict[key] = value;
          }
        }

        return dict;
      };
    };

    webidl.nullableConverter = function (converter) {
      return (V) => {
        if (V === null) {
          return V;
        }

        return converter(V);
      };
    };

    // https://webidl.spec.whatwg.org/#es-DOMString
    webidl.converters.DOMString = function (V, opts = {}) {
      // 1. If V is null and the conversion is to an IDL type
      //    associated with the [LegacyNullToEmptyString]
      //    extended attribute, then return the DOMString value
      //    that represents the empty string.
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }

      // 2. Let x be ? ToString(V).
      if (typeof V === "symbol") {
        throw new TypeError(
          "Could not convert argument of type symbol to string."
        );
      }

      // 3. Return the IDL DOMString value that represents the
      //    same sequence of code units as the one the
      //    ECMAScript String value x represents.
      return String(V);
    };

    // https://webidl.spec.whatwg.org/#es-ByteString
    webidl.converters.ByteString = function (V) {
      // 1. Let x be ? ToString(V).
      // Note: DOMString converter perform ? ToString(V)
      const x = webidl.converters.DOMString(V);

      // 2. If the value of any element of x is greater than
      //    255, then throw a TypeError.
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            "Cannot convert argument to a ByteString because the character at " +
              `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }

      // 3. Return an IDL ByteString value whose length is the
      //    length of x, and where the value of each element is
      //    the value of the corresponding element of x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#es-USVString
    webidl.converters.USVString = toUSVString;

    // https://webidl.spec.whatwg.org/#es-boolean
    webidl.converters.boolean = function (V) {
      // 1. Let x be the result of computing ToBoolean(V).
      const x = Boolean(V);

      // 2. Return the IDL boolean value that is the one that represents
      //    the same truth value as the ECMAScript Boolean value x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#es-any
    webidl.converters.any = function (V) {
      return V;
    };

    // https://webidl.spec.whatwg.org/#es-long-long
    webidl.converters["long long"] = function (V) {
      // 1. Let x be ? ConvertToInt(V, 64, "signed").
      const x = webidl.util.ConvertToInt(V, 64, "signed");

      // 2. Return the IDL long long value that represents
      //    the same numeric value as x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#es-unsigned-long-long
    webidl.converters["unsigned long long"] = function (V) {
      // 1. Let x be ? ConvertToInt(V, 64, "unsigned").
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");

      // 2. Return the IDL unsigned long long value that
      //    represents the same numeric value as x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#es-unsigned-long
    webidl.converters["unsigned long"] = function (V) {
      // 1. Let x be ? ConvertToInt(V, 32, "unsigned").
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");

      // 2. Return the IDL unsigned long value that
      //    represents the same numeric value as x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#es-unsigned-short
    webidl.converters["unsigned short"] = function (V, opts) {
      // 1. Let x be ? ConvertToInt(V, 16, "unsigned").
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);

      // 2. Return the IDL unsigned short value that represents
      //    the same numeric value as x.
      return x;
    };

    // https://webidl.spec.whatwg.org/#idl-ArrayBuffer
    webidl.converters.ArrayBuffer = function (V, opts = {}) {
      // 1. If Type(V) is not Object, or V does not have an
      //    [[ArrayBufferData]] internal slot, then throw a
      //    TypeError.
      // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
      // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"],
        });
      }

      // 2. If the conversion is not to an IDL type associated
      //    with the [AllowShared] extended attribute, and
      //    IsSharedArrayBuffer(V) is true, then throw a
      //    TypeError.
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed.",
        });
      }

      // 3. If the conversion is not to an IDL type associated
      //    with the [AllowResizable] extended attribute, and
      //    IsResizableArrayBuffer(V) is true, then throw a
      //    TypeError.
      // Note: resizable ArrayBuffers are currently a proposal.

      // 4. Return the IDL ArrayBuffer value that is a
      //    reference to the same object as V.
      return V;
    };

    webidl.converters.TypedArray = function (V, T, opts = {}) {
      // 1. Let T be the IDL type V is being converted to.

      // 2. If Type(V) is not Object, or V does not have a
      //    [[TypedArrayName]] internal slot with a value
      //    equal to T’s name, then throw a TypeError.
      if (
        webidl.util.Type(V) !== "Object" ||
        !types.isTypedArray(V) ||
        V.constructor.name !== T.name
      ) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name],
        });
      }

      // 3. If the conversion is not to an IDL type associated
      //    with the [AllowShared] extended attribute, and
      //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
      //    true, then throw a TypeError.
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed.",
        });
      }

      // 4. If the conversion is not to an IDL type associated
      //    with the [AllowResizable] extended attribute, and
      //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
      //    true, then throw a TypeError.
      // Note: resizable array buffers are currently a proposal

      // 5. Return the IDL value of type T that is a reference
      //    to the same object as V.
      return V;
    };

    webidl.converters.DataView = function (V, opts = {}) {
      // 1. If Type(V) is not Object, or V does not have a
      //    [[DataView]] internal slot, then throw a TypeError.
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView.",
        });
      }

      // 2. If the conversion is not to an IDL type associated
      //    with the [AllowShared] extended attribute, and
      //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
      //    then throw a TypeError.
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed.",
        });
      }

      // 3. If the conversion is not to an IDL type associated
      //    with the [AllowResizable] extended attribute, and
      //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
      //    true, then throw a TypeError.
      // Note: resizable ArrayBuffers are currently a proposal

      // 4. Return the IDL DataView value that is a reference
      //    to the same object as V.
      return V;
    };

    // https://webidl.spec.whatwg.org/#BufferSource
    webidl.converters.BufferSource = function (V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }

      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }

      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }

      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };

    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );

    webidl.converters["sequence<sequence<ByteString>>"] =
      webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);

    webidl.converters["record<ByteString, ByteString>"] =
      webidl.recordConverter(
        webidl.converters.ByteString,
        webidl.converters.ByteString
      );

    module.exports = {
      webidl,
    };

    /***/
  },

  /***/ 4854: /***/ (module) => {
    /**
     * @see https://encoding.spec.whatwg.org/#concept-encoding-get
     * @param {string|undefined} label
     */
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }

      // 1. Remove any leading and trailing ASCII whitespace from label.
      // 2. If label is an ASCII case-insensitive match for any of the
      //    labels listed in the table below, then return the
      //    corresponding encoding; otherwise return failure.
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }

    module.exports = {
      getEncoding,
    };

    /***/
  },

  /***/ 1446: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { staticPropertyDescriptors, readOperation, fireAProgressEvent } =
      __nccwpck_require__(7530);
    const { kState, kError, kResult, kEvents, kAborted } =
      __nccwpck_require__(9054);
    const { webidl } = __nccwpck_require__(1744);
    const { kEnumerableProperty } = __nccwpck_require__(3983);

    class FileReader extends EventTarget {
      constructor() {
        super();

        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null,
        };
      }

      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, FileReader);

        webidl.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsArrayBuffer",
        });

        blob = webidl.converters.Blob(blob, { strict: false });

        // The readAsArrayBuffer(blob) method, when invoked,
        // must initiate a read operation for blob with ArrayBuffer.
        readOperation(this, blob, "ArrayBuffer");
      }

      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, FileReader);

        webidl.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsBinaryString",
        });

        blob = webidl.converters.Blob(blob, { strict: false });

        // The readAsBinaryString(blob) method, when invoked,
        // must initiate a read operation for blob with BinaryString.
        readOperation(this, blob, "BinaryString");
      }

      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = undefined) {
        webidl.brandCheck(this, FileReader);

        webidl.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsText",
        });

        blob = webidl.converters.Blob(blob, { strict: false });

        if (encoding !== undefined) {
          encoding = webidl.converters.DOMString(encoding);
        }

        // The readAsText(blob, encoding) method, when invoked,
        // must initiate a read operation for blob with Text and encoding.
        readOperation(this, blob, "Text", encoding);
      }

      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, FileReader);

        webidl.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsDataURL",
        });

        blob = webidl.converters.Blob(blob, { strict: false });

        // The readAsDataURL(blob) method, when invoked, must
        // initiate a read operation for blob with DataURL.
        readOperation(this, blob, "DataURL");
      }

      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        // 1. If this's state is "empty" or if this's state is
        //    "done" set this's result to null and terminate
        //    this algorithm.
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }

        // 2. If this's state is "loading" set this's state to
        //    "done" and set this's result to null.
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }

        // 3. If there are any tasks from this on the file reading
        //    task source in an affiliated task queue, then remove
        //    those tasks from that task queue.
        this[kAborted] = true;

        // 4. Terminate the algorithm for the read method being processed.
        // TODO

        // 5. Fire a progress event called abort at this.
        fireAProgressEvent("abort", this);

        // 6. If this's state is not "loading", fire a progress
        //    event called loadend at this.
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }

      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, FileReader);

        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }

      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, FileReader);

        // The result attribute’s getter, when invoked, must return
        // this's result.
        return this[kResult];
      }

      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, FileReader);

        // The error attribute’s getter, when invoked, must return
        // this's error.
        return this[kError];
      }

      get onloadend() {
        webidl.brandCheck(this, FileReader);

        return this[kEvents].loadend;
      }

      set onloadend(fn) {
        webidl.brandCheck(this, FileReader);

        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }

        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }

      get onerror() {
        webidl.brandCheck(this, FileReader);

        return this[kEvents].error;
      }

      set onerror(fn) {
        webidl.brandCheck(this, FileReader);

        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }

        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }

      get onloadstart() {
        webidl.brandCheck(this, FileReader);

        return this[kEvents].loadstart;
      }

      set onloadstart(fn) {
        webidl.brandCheck(this, FileReader);

        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }

        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }

      get onprogress() {
        webidl.brandCheck(this, FileReader);

        return this[kEvents].progress;
      }

      set onprogress(fn) {
        webidl.brandCheck(this, FileReader);

        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }

        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }

      get onload() {
        webidl.brandCheck(this, FileReader);

        return this[kEvents].load;
      }

      set onload(fn) {
        webidl.brandCheck(this, FileReader);

        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }

        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }

      get onabort() {
        webidl.brandCheck(this, FileReader);

        return this[kEvents].abort;
      }

      set onabort(fn) {
        webidl.brandCheck(this, FileReader);

        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }

        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    }

    // https://w3c.github.io/FileAPI/#dom-filereader-empty
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    // https://w3c.github.io/FileAPI/#dom-filereader-loading
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    // https://w3c.github.io/FileAPI/#dom-filereader-done
    FileReader.DONE = FileReader.prototype.DONE = 2;

    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true,
      },
    });

    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
    });

    module.exports = {
      FileReader,
    };

    /***/
  },

  /***/ 5504: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { webidl } = __nccwpck_require__(1744);

    const kState = Symbol("ProgressEvent state");

    /**
     * @see https://xhr.spec.whatwg.org/#progressevent
     */
    class ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(
          eventInitDict ?? {}
        );

        super(type, eventInitDict);

        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total,
        };
      }

      get lengthComputable() {
        webidl.brandCheck(this, ProgressEvent);

        return this[kState].lengthComputable;
      }

      get loaded() {
        webidl.brandCheck(this, ProgressEvent);

        return this[kState].loaded;
      }

      get total() {
        webidl.brandCheck(this, ProgressEvent);

        return this[kState].total;
      }
    }

    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0,
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0,
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
    ]);

    module.exports = {
      ProgressEvent,
    };

    /***/
  },

  /***/ 9054: /***/ (module) => {
    module.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol(
        "FileReader last progress event fired timestamp"
      ),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted"),
    };

    /***/
  },

  /***/ 7530: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kState, kError, kResult, kAborted, kLastProgressEventFired } =
      __nccwpck_require__(9054);
    const { ProgressEvent } = __nccwpck_require__(5504);
    const { getEncoding } = __nccwpck_require__(4854);
    const { DOMException } = __nccwpck_require__(1037);
    const { serializeAMimeType, parseMIMEType } = __nccwpck_require__(685);
    const { types } = __nccwpck_require__(3837);
    const { StringDecoder } = __nccwpck_require__(1576);
    const { btoa } = __nccwpck_require__(4300);

    /** @type {PropertyDescriptor} */
    const staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false,
    };

    /**
     * @see https://w3c.github.io/FileAPI/#readOperation
     * @param {import('./filereader').FileReader} fr
     * @param {import('buffer').Blob} blob
     * @param {string} type
     * @param {string?} encodingName
     */
    function readOperation(fr, blob, type, encodingName) {
      // 1. If fr’s state is "loading", throw an InvalidStateError
      //    DOMException.
      if (fr[kState] === "loading") {
        throw new DOMException("Invalid state", "InvalidStateError");
      }

      // 2. Set fr’s state to "loading".
      fr[kState] = "loading";

      // 3. Set fr’s result to null.
      fr[kResult] = null;

      // 4. Set fr’s error to null.
      fr[kError] = null;

      // 5. Let stream be the result of calling get stream on blob.
      /** @type {import('stream/web').ReadableStream} */
      const stream = blob.stream();

      // 6. Let reader be the result of getting a reader from stream.
      const reader = stream.getReader();

      // 7. Let bytes be an empty byte sequence.
      /** @type {Uint8Array[]} */
      const bytes = [];

      // 8. Let chunkPromise be the result of reading a chunk from
      //    stream with reader.
      let chunkPromise = reader.read();

      // 9. Let isFirstChunk be true.
      let isFirstChunk = true;

      // 10. In parallel, while true:
      // Note: "In parallel" just means non-blocking
      // Note 2: readOperation itself cannot be async as double
      // reading the body would then reject the promise, instead
      // of throwing an error.
      (async () => {
        while (!fr[kAborted]) {
          // 1. Wait for chunkPromise to be fulfilled or rejected.
          try {
            const { done, value } = await chunkPromise;

            // 2. If chunkPromise is fulfilled, and isFirstChunk is
            //    true, queue a task to fire a progress event called
            //    loadstart at fr.
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }

            // 3. Set isFirstChunk to false.
            isFirstChunk = false;

            // 4. If chunkPromise is fulfilled with an object whose
            //    done property is false and whose value property is
            //    a Uint8Array object, run these steps:
            if (!done && types.isUint8Array(value)) {
              // 1. Let bs be the byte sequence represented by the
              //    Uint8Array object.

              // 2. Append bs to bytes.
              bytes.push(value);

              // 3. If roughly 50ms have passed since these steps
              //    were last invoked, queue a task to fire a
              //    progress event called progress at fr.
              if (
                (fr[kLastProgressEventFired] === undefined ||
                  Date.now() - fr[kLastProgressEventFired] >= 50) &&
                !fr[kAborted]
              ) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }

              // 4. Set chunkPromise to the result of reading a
              //    chunk from stream with reader.
              chunkPromise = reader.read();
            } else if (done) {
              // 5. Otherwise, if chunkPromise is fulfilled with an
              //    object whose done property is true, queue a task
              //    to run the following steps and abort this algorithm:
              queueMicrotask(() => {
                // 1. Set fr’s state to "done".
                fr[kState] = "done";

                // 2. Let result be the result of package data given
                //    bytes, type, blob’s type, and encodingName.
                try {
                  const result = packageData(
                    bytes,
                    type,
                    blob.type,
                    encodingName
                  );

                  // 4. Else:

                  if (fr[kAborted]) {
                    return;
                  }

                  // 1. Set fr’s result to result.
                  fr[kResult] = result;

                  // 2. Fire a progress event called load at the fr.
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  // 3. If package data threw an exception error:

                  // 1. Set fr’s error to error.
                  fr[kError] = error;

                  // 2. Fire a progress event called error at fr.
                  fireAProgressEvent("error", fr);
                }

                // 5. If fr’s state is not "loading", fire a progress
                //    event called loadend at the fr.
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });

              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }

            // 6. Otherwise, if chunkPromise is rejected with an
            //    error error, queue a task to run the following
            //    steps and abort this algorithm:
            queueMicrotask(() => {
              // 1. Set fr’s state to "done".
              fr[kState] = "done";

              // 2. Set fr’s error to error.
              fr[kError] = error;

              // 3. Fire a progress event called error at fr.
              fireAProgressEvent("error", fr);

              // 4. If fr’s state is not "loading", fire a progress
              //    event called loadend at fr.
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });

            break;
          }
        }
      })();
    }

    /**
     * @see https://w3c.github.io/FileAPI/#fire-a-progress-event
     * @see https://dom.spec.whatwg.org/#concept-event-fire
     * @param {string} e The name of the event
     * @param {import('./filereader').FileReader} reader
     */
    function fireAProgressEvent(e, reader) {
      // The progress event e does not bubble. e.bubbles must be false
      // The progress event e is NOT cancelable. e.cancelable must be false
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false,
      });

      reader.dispatchEvent(event);
    }

    /**
     * @see https://w3c.github.io/FileAPI/#blob-package-data
     * @param {Uint8Array[]} bytes
     * @param {string} type
     * @param {string?} mimeType
     * @param {string?} encodingName
     */
    function packageData(bytes, type, mimeType, encodingName) {
      // 1. A Blob has an associated package data algorithm, given
      //    bytes, a type, a optional mimeType, and a optional
      //    encodingName, which switches on type and runs the
      //    associated steps:

      switch (type) {
        case "DataURL": {
          // 1. Return bytes as a DataURL [RFC2397] subject to
          //    the considerations below:
          //  * Use mimeType as part of the Data URL if it is
          //    available in keeping with the Data URL
          //    specification [RFC2397].
          //  * If mimeType is not available return a Data URL
          //    without a media-type. [RFC2397].

          // https://datatracker.ietf.org/doc/html/rfc2397#section-3
          // dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
          // mediatype  := [ type "/" subtype ] *( ";" parameter )
          // data       := *urlchar
          // parameter  := attribute "=" value
          let dataURL = "data:";

          const parsed = parseMIMEType(mimeType || "application/octet-stream");

          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }

          dataURL += ";base64,";

          const decoder = new StringDecoder("latin1");

          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }

          dataURL += btoa(decoder.end());

          return dataURL;
        }
        case "Text": {
          // 1. Let encoding be failure
          let encoding = "failure";

          // 2. If the encodingName is present, set encoding to the
          //    result of getting an encoding from encodingName.
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }

          // 3. If encoding is failure, and mimeType is present:
          if (encoding === "failure" && mimeType) {
            // 1. Let type be the result of parse a MIME type
            //    given mimeType.
            const type = parseMIMEType(mimeType);

            // 2. If type is not failure, set encoding to the result
            //    of getting an encoding from type’s parameters["charset"].
            if (type !== "failure") {
              encoding = getEncoding(type.parameters.get("charset"));
            }
          }

          // 4. If encoding is failure, then set encoding to UTF-8.
          if (encoding === "failure") {
            encoding = "UTF-8";
          }

          // 5. Decode bytes using fallback encoding encoding, and
          //    return the result.
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          // Return a new ArrayBuffer whose contents are bytes.
          const sequence = combineByteSequences(bytes);

          return sequence.buffer;
        }
        case "BinaryString": {
          // Return bytes as a binary string, in which every byte
          //  is represented by a code unit of equal value [0..255].
          let binaryString = "";

          const decoder = new StringDecoder("latin1");

          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }

          binaryString += decoder.end();

          return binaryString;
        }
      }
    }

    /**
     * @see https://encoding.spec.whatwg.org/#decode
     * @param {Uint8Array[]} ioQueue
     * @param {string} encoding
     */
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);

      // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.
      const BOMEncoding = BOMSniffing(bytes);

      let slice = 0;

      // 2. If BOMEncoding is non-null:
      if (BOMEncoding !== null) {
        // 1. Set encoding to BOMEncoding.
        encoding = BOMEncoding;

        // 2. Read three bytes from ioQueue, if BOMEncoding is
        //    UTF-8; otherwise read two bytes.
        //    (Do nothing with those bytes.)
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }

      // 3. Process a queue with an instance of encoding’s
      //    decoder, ioQueue, output, and "replacement".

      // 4. Return output.

      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }

    /**
     * @see https://encoding.spec.whatwg.org/#bom-sniff
     * @param {Uint8Array} ioQueue
     */
    function BOMSniffing(ioQueue) {
      // 1. Let BOM be the result of peeking 3 bytes from ioQueue,
      //    converted to a byte sequence.
      const [a, b, c] = ioQueue;

      // 2. For each of the rows in the table below, starting with
      //    the first one and going down, if BOM starts with the
      //    bytes given in the first column, then return the
      //    encoding given in the cell in the second column of that
      //    row. Otherwise, return null.
      if (a === 0xef && b === 0xbb && c === 0xbf) {
        return "UTF-8";
      } else if (a === 0xfe && b === 0xff) {
        return "UTF-16BE";
      } else if (a === 0xff && b === 0xfe) {
        return "UTF-16LE";
      }

      return null;
    }

    /**
     * @param {Uint8Array[]} sequences
     */
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);

      let offset = 0;

      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }

    module.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent,
    };

    /***/
  },

  /***/ 1892: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // We include a version number for the Dispatcher API. In case of breaking changes,
    // this version number must be increased to avoid conflicts.
    const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    const { InvalidArgumentError } = __nccwpck_require__(8045);
    const Agent = __nccwpck_require__(7890);

    if (getGlobalDispatcher() === undefined) {
      setGlobalDispatcher(new Agent());
    }

    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false,
      });
    }

    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }

    module.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher,
    };

    /***/
  },

  /***/ 6930: /***/ (module) => {
    module.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }

      onConnect(...args) {
        return this.handler.onConnect(...args);
      }

      onError(...args) {
        return this.handler.onError(...args);
      }

      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }

      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }

      onData(...args) {
        return this.handler.onData(...args);
      }

      onComplete(...args) {
        return this.handler.onComplete(...args);
      }

      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };

    /***/
  },

  /***/ 2860: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const util = __nccwpck_require__(3983);
    const { kBodyUsed } = __nccwpck_require__(2785);
    const assert = __nccwpck_require__(9491);
    const { InvalidArgumentError } = __nccwpck_require__(8045);
    const EE = __nccwpck_require__(2361);

    const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];

    const kBody = Symbol("body");

    class BodyAsyncIterable {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }

      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    }

    class RedirectHandler {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (
          maxRedirections != null &&
          (!Number.isInteger(maxRedirections) || maxRedirections < 0)
        ) {
          throw new InvalidArgumentError(
            "maxRedirections must be a positive number"
          );
        }

        util.validateHandler(handler, opts.method, opts.upgrade);

        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 }; // opts must be a copy
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];

        if (util.isStream(this.opts.body)) {
          // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
          // so that it can be dispatched again?
          // TODO (fix): Do we need 100-expect support to provide a way to do this properly?
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function () {
              assert(false);
            });
          }

          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function () {
              this[kBodyUsed] = true;
            });
          }
        } else if (
          this.opts.body &&
          typeof this.opts.body.pipeTo === "function"
        ) {
          // TODO (fix): We can't access ReadableStream internal state
          // to determine whether or not it has been disturbed. This is just
          // a workaround.
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (
          this.opts.body &&
          typeof this.opts.body !== "string" &&
          !ArrayBuffer.isView(this.opts.body) &&
          util.isIterable(this.opts.body)
        ) {
          // TODO: Should we allow re-using iterable if !this.opts.idempotent
          // or through some other flag?
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }

      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }

      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }

      onError(error) {
        this.handler.onError(error);
      }

      onHeaders(statusCode, headers, resume, statusText) {
        this.location =
          this.history.length >= this.maxRedirections ||
          util.isDisturbed(this.opts.body)
            ? null
            : parseLocation(statusCode, headers);

        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }

        if (!this.location) {
          return this.handler.onHeaders(
            statusCode,
            headers,
            resume,
            statusText
          );
        }

        const { origin, pathname, search } = util.parseURL(
          new URL(
            this.location,
            this.opts.origin && new URL(this.opts.path, this.opts.origin)
          )
        );
        const path = search ? `${pathname}${search}` : pathname;

        // Remove headers referring to the original URL.
        // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
        // https://tools.ietf.org/html/rfc7231#section-6.4
        this.opts.headers = cleanRequestHeaders(
          this.opts.headers,
          statusCode === 303,
          this.opts.origin !== origin
        );
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;

        // https://tools.ietf.org/html/rfc7231#section-6.4.4
        // In case of HTTP 303, always replace method to be either HEAD or GET
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }

      onData(chunk) {
        if (this.location) {
          /*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response bodies.

        Redirection is used to serve the requested resource from another URL, so it is assumes that
        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.

        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually
        (which means it's optional and not mandated) contain just an hyperlink to the value of
        the Location response header, so the body can be ignored safely.

        For status 300, which is "Multiple Choices", the spec mentions both generating a Location
        response header AND a response body with the other possible location to follow.
        Since the spec explicitily chooses not to specify a format for such body and leave it to
        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.
      */
        } else {
          return this.handler.onData(chunk);
        }
      }

      onComplete(trailers) {
        if (this.location) {
          /*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
        and neither are useful if present.

        See comment on onData method above for more detailed informations.
      */

          this.location = null;
          this.abort = null;

          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }

      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    }

    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }

      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }

    // https://tools.ietf.org/html/rfc7231#section-6.4.4
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (
        removeContent &&
        util.headerNameToString(header).startsWith("content-")
      ) {
        return true;
      }
      if (
        unknownOrigin &&
        (header.length === 13 || header.length === 6 || header.length === 19)
      ) {
        const name = util.headerNameToString(header);
        return (
          name === "authorization" ||
          name === "cookie" ||
          name === "proxy-authorization"
        );
      }
      return false;
    }

    // https://tools.ietf.org/html/rfc7231#section-6.4
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }

    module.exports = RedirectHandler;

    /***/
  },

  /***/ 2286: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const assert = __nccwpck_require__(9491);

    const { kRetryHandlerDefaultRetry } = __nccwpck_require__(2785);
    const { RequestRetryError } = __nccwpck_require__(8045);
    const { isDisturbed, parseHeaders, parseRangeHeader } =
      __nccwpck_require__(3983);

    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;

      return diff;
    }

    class RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes,
        } = retryOptions ?? {};

        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1000, // 30s,
          timeout: minTimeout ?? 500, // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? [
            "GET",
            "HEAD",
            "OPTIONS",
            "PUT",
            "DELETE",
            "TRACE",
          ],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
          ],
        };

        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;

        // Handle possible onConnect duplication
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }

      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }

      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }

      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }

      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }

      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods,
        } = retryOptions;
        let { counter, currentTimeout } = state;

        currentTimeout =
          currentTimeout != null && currentTimeout > 0
            ? currentTimeout
            : timeout;

        // Any code that is not a Undici's originated and allowed to retry
        if (
          code &&
          code !== "UND_ERR_REQ_RETRY" &&
          code !== "UND_ERR_SOCKET" &&
          !errorCodes.includes(code)
        ) {
          cb(err);
          return;
        }

        // If a set of method are provided and the current method is not in the list
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }

        // If a set of status code are provided and the current status code is not in the list
        if (
          statusCode != null &&
          Array.isArray(statusCodes) &&
          !statusCodes.includes(statusCode)
        ) {
          cb(err);
          return;
        }

        // If we reached the max number of retries
        if (counter > maxRetries) {
          cb(err);
          return;
        }

        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader)
            ? calculateRetryAfterHeader(retryAfterHeader)
            : retryAfterHeader * 1e3; // Retry-After is in seconds
        }

        const retryTimeout =
          retryAfterHeader > 0
            ? Math.min(retryAfterHeader, maxTimeout)
            : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);

        state.currentTimeout = retryTimeout;

        setTimeout(() => cb(null), retryTimeout);
      }

      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);

        this.retryCount += 1;

        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount,
            })
          );
          return false;
        }

        // Checkpoint for resume from where we left it
        if (this.resume != null) {
          this.resume = null;

          if (statusCode !== 206) {
            return true;
          }

          const contentRange = parseRangeHeader(headers["content-range"]);
          // If no content range
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount,
              })
            );
            return false;
          }

          // Let's start with a weak etag check
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount,
              })
            );
            return false;
          }

          const { start, size, end = size } = contentRange;

          assert(this.start === start, "content-range mismatch");
          assert(
            this.end == null || this.end === end,
            "content-range mismatch"
          );

          this.resume = resume;
          return true;
        }

        if (this.end == null) {
          if (statusCode === 206) {
            // First time we receive 206
            const range = parseRangeHeader(headers["content-range"]);

            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }

            const { start, size, end = size } = range;

            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );

            this.start = start;
            this.end = end;
          }

          // We make our best to checkpoint the body for further range headers
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }

          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );

          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;

          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }

        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount,
        });

        this.abort(err);

        return false;
      }

      onData(chunk) {
        this.start += chunk.length;

        return this.handler.onData(chunk);
      }

      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }

      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }

        this.retryOpts.retry(
          err,
          {
            state: {
              counter: this.retryCount++,
              currentTimeout: this.retryAfter,
            },
            opts: { retryOptions: this.retryOpts, ...this.opts },
          },
          onRetry.bind(this)
        );

        function onRetry(err) {
          if (err != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err);
          }

          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`,
              },
            };
          }

          try {
            this.dispatch(this.opts, this);
          } catch (err) {
            this.handler.onError(err);
          }
        }
      }
    }

    module.exports = RetryHandler;

    /***/
  },

  /***/ 8861: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const RedirectHandler = __nccwpck_require__(2860);

    function createRedirectInterceptor({
      maxRedirections: defaultMaxRedirections,
    }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;

          if (!maxRedirections) {
            return dispatch(opts, handler);
          }

          const redirectHandler = new RedirectHandler(
            dispatch,
            maxRedirections,
            opts,
            handler
          );
          opts = { ...opts, maxRedirections: 0 }; // Stop sub dispatcher from also redirecting.
          return dispatch(opts, redirectHandler);
        };
      };
    }

    module.exports = createRedirectInterceptor;

    /***/
  },

  /***/ 953: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPECIAL_HEADERS =
      exports.HEADER_STATE =
      exports.MINOR =
      exports.MAJOR =
      exports.CONNECTION_TOKEN_CHARS =
      exports.HEADER_CHARS =
      exports.TOKEN =
      exports.STRICT_TOKEN =
      exports.HEX =
      exports.URL_CHAR =
      exports.STRICT_URL_CHAR =
      exports.USERINFO_CHARS =
      exports.MARK =
      exports.ALPHANUM =
      exports.NUM =
      exports.HEX_MAP =
      exports.NUM_MAP =
      exports.ALPHA =
      exports.FINISH =
      exports.H_METHOD_MAP =
      exports.METHOD_MAP =
      exports.METHODS_RTSP =
      exports.METHODS_ICE =
      exports.METHODS_HTTP =
      exports.METHODS =
      exports.LENIENT_FLAGS =
      exports.FLAGS =
      exports.TYPE =
      exports.ERROR =
        void 0;
    const utils_1 = __nccwpck_require__(1891);
    // C headers
    var ERROR;
    (function (ERROR) {
      ERROR[(ERROR["OK"] = 0)] = "OK";
      ERROR[(ERROR["INTERNAL"] = 1)] = "INTERNAL";
      ERROR[(ERROR["STRICT"] = 2)] = "STRICT";
      ERROR[(ERROR["LF_EXPECTED"] = 3)] = "LF_EXPECTED";
      ERROR[(ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4)] =
        "UNEXPECTED_CONTENT_LENGTH";
      ERROR[(ERROR["CLOSED_CONNECTION"] = 5)] = "CLOSED_CONNECTION";
      ERROR[(ERROR["INVALID_METHOD"] = 6)] = "INVALID_METHOD";
      ERROR[(ERROR["INVALID_URL"] = 7)] = "INVALID_URL";
      ERROR[(ERROR["INVALID_CONSTANT"] = 8)] = "INVALID_CONSTANT";
      ERROR[(ERROR["INVALID_VERSION"] = 9)] = "INVALID_VERSION";
      ERROR[(ERROR["INVALID_HEADER_TOKEN"] = 10)] = "INVALID_HEADER_TOKEN";
      ERROR[(ERROR["INVALID_CONTENT_LENGTH"] = 11)] = "INVALID_CONTENT_LENGTH";
      ERROR[(ERROR["INVALID_CHUNK_SIZE"] = 12)] = "INVALID_CHUNK_SIZE";
      ERROR[(ERROR["INVALID_STATUS"] = 13)] = "INVALID_STATUS";
      ERROR[(ERROR["INVALID_EOF_STATE"] = 14)] = "INVALID_EOF_STATE";
      ERROR[(ERROR["INVALID_TRANSFER_ENCODING"] = 15)] =
        "INVALID_TRANSFER_ENCODING";
      ERROR[(ERROR["CB_MESSAGE_BEGIN"] = 16)] = "CB_MESSAGE_BEGIN";
      ERROR[(ERROR["CB_HEADERS_COMPLETE"] = 17)] = "CB_HEADERS_COMPLETE";
      ERROR[(ERROR["CB_MESSAGE_COMPLETE"] = 18)] = "CB_MESSAGE_COMPLETE";
      ERROR[(ERROR["CB_CHUNK_HEADER"] = 19)] = "CB_CHUNK_HEADER";
      ERROR[(ERROR["CB_CHUNK_COMPLETE"] = 20)] = "CB_CHUNK_COMPLETE";
      ERROR[(ERROR["PAUSED"] = 21)] = "PAUSED";
      ERROR[(ERROR["PAUSED_UPGRADE"] = 22)] = "PAUSED_UPGRADE";
      ERROR[(ERROR["PAUSED_H2_UPGRADE"] = 23)] = "PAUSED_H2_UPGRADE";
      ERROR[(ERROR["USER"] = 24)] = "USER";
    })((ERROR = exports.ERROR || (exports.ERROR = {})));
    var TYPE;
    (function (TYPE) {
      TYPE[(TYPE["BOTH"] = 0)] = "BOTH";
      TYPE[(TYPE["REQUEST"] = 1)] = "REQUEST";
      TYPE[(TYPE["RESPONSE"] = 2)] = "RESPONSE";
    })((TYPE = exports.TYPE || (exports.TYPE = {})));
    var FLAGS;
    (function (FLAGS) {
      FLAGS[(FLAGS["CONNECTION_KEEP_ALIVE"] = 1)] = "CONNECTION_KEEP_ALIVE";
      FLAGS[(FLAGS["CONNECTION_CLOSE"] = 2)] = "CONNECTION_CLOSE";
      FLAGS[(FLAGS["CONNECTION_UPGRADE"] = 4)] = "CONNECTION_UPGRADE";
      FLAGS[(FLAGS["CHUNKED"] = 8)] = "CHUNKED";
      FLAGS[(FLAGS["UPGRADE"] = 16)] = "UPGRADE";
      FLAGS[(FLAGS["CONTENT_LENGTH"] = 32)] = "CONTENT_LENGTH";
      FLAGS[(FLAGS["SKIPBODY"] = 64)] = "SKIPBODY";
      FLAGS[(FLAGS["TRAILING"] = 128)] = "TRAILING";
      // 1 << 8 is unused
      FLAGS[(FLAGS["TRANSFER_ENCODING"] = 512)] = "TRANSFER_ENCODING";
    })((FLAGS = exports.FLAGS || (exports.FLAGS = {})));
    var LENIENT_FLAGS;
    (function (LENIENT_FLAGS) {
      LENIENT_FLAGS[(LENIENT_FLAGS["HEADERS"] = 1)] = "HEADERS";
      LENIENT_FLAGS[(LENIENT_FLAGS["CHUNKED_LENGTH"] = 2)] = "CHUNKED_LENGTH";
      LENIENT_FLAGS[(LENIENT_FLAGS["KEEP_ALIVE"] = 4)] = "KEEP_ALIVE";
    })((LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {})));
    var METHODS;
    (function (METHODS) {
      METHODS[(METHODS["DELETE"] = 0)] = "DELETE";
      METHODS[(METHODS["GET"] = 1)] = "GET";
      METHODS[(METHODS["HEAD"] = 2)] = "HEAD";
      METHODS[(METHODS["POST"] = 3)] = "POST";
      METHODS[(METHODS["PUT"] = 4)] = "PUT";
      /* pathological */
      METHODS[(METHODS["CONNECT"] = 5)] = "CONNECT";
      METHODS[(METHODS["OPTIONS"] = 6)] = "OPTIONS";
      METHODS[(METHODS["TRACE"] = 7)] = "TRACE";
      /* WebDAV */
      METHODS[(METHODS["COPY"] = 8)] = "COPY";
      METHODS[(METHODS["LOCK"] = 9)] = "LOCK";
      METHODS[(METHODS["MKCOL"] = 10)] = "MKCOL";
      METHODS[(METHODS["MOVE"] = 11)] = "MOVE";
      METHODS[(METHODS["PROPFIND"] = 12)] = "PROPFIND";
      METHODS[(METHODS["PROPPATCH"] = 13)] = "PROPPATCH";
      METHODS[(METHODS["SEARCH"] = 14)] = "SEARCH";
      METHODS[(METHODS["UNLOCK"] = 15)] = "UNLOCK";
      METHODS[(METHODS["BIND"] = 16)] = "BIND";
      METHODS[(METHODS["REBIND"] = 17)] = "REBIND";
      METHODS[(METHODS["UNBIND"] = 18)] = "UNBIND";
      METHODS[(METHODS["ACL"] = 19)] = "ACL";
      /* subversion */
      METHODS[(METHODS["REPORT"] = 20)] = "REPORT";
      METHODS[(METHODS["MKACTIVITY"] = 21)] = "MKACTIVITY";
      METHODS[(METHODS["CHECKOUT"] = 22)] = "CHECKOUT";
      METHODS[(METHODS["MERGE"] = 23)] = "MERGE";
      /* upnp */
      METHODS[(METHODS["M-SEARCH"] = 24)] = "M-SEARCH";
      METHODS[(METHODS["NOTIFY"] = 25)] = "NOTIFY";
      METHODS[(METHODS["SUBSCRIBE"] = 26)] = "SUBSCRIBE";
      METHODS[(METHODS["UNSUBSCRIBE"] = 27)] = "UNSUBSCRIBE";
      /* RFC-5789 */
      METHODS[(METHODS["PATCH"] = 28)] = "PATCH";
      METHODS[(METHODS["PURGE"] = 29)] = "PURGE";
      /* CalDAV */
      METHODS[(METHODS["MKCALENDAR"] = 30)] = "MKCALENDAR";
      /* RFC-2068, section 19.6.1.2 */
      METHODS[(METHODS["LINK"] = 31)] = "LINK";
      METHODS[(METHODS["UNLINK"] = 32)] = "UNLINK";
      /* icecast */
      METHODS[(METHODS["SOURCE"] = 33)] = "SOURCE";
      /* RFC-7540, section 11.6 */
      METHODS[(METHODS["PRI"] = 34)] = "PRI";
      /* RFC-2326 RTSP */
      METHODS[(METHODS["DESCRIBE"] = 35)] = "DESCRIBE";
      METHODS[(METHODS["ANNOUNCE"] = 36)] = "ANNOUNCE";
      METHODS[(METHODS["SETUP"] = 37)] = "SETUP";
      METHODS[(METHODS["PLAY"] = 38)] = "PLAY";
      METHODS[(METHODS["PAUSE"] = 39)] = "PAUSE";
      METHODS[(METHODS["TEARDOWN"] = 40)] = "TEARDOWN";
      METHODS[(METHODS["GET_PARAMETER"] = 41)] = "GET_PARAMETER";
      METHODS[(METHODS["SET_PARAMETER"] = 42)] = "SET_PARAMETER";
      METHODS[(METHODS["REDIRECT"] = 43)] = "REDIRECT";
      METHODS[(METHODS["RECORD"] = 44)] = "RECORD";
      /* RAOP */
      METHODS[(METHODS["FLUSH"] = 45)] = "FLUSH";
    })((METHODS = exports.METHODS || (exports.METHODS = {})));
    exports.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE,
    ];
    exports.METHODS_ICE = [METHODS.SOURCE];
    exports.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST,
    ];
    exports.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports.H_METHOD_MAP = {};
    Object.keys(exports.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function (FINISH) {
      FINISH[(FINISH["SAFE"] = 0)] = "SAFE";
      FINISH[(FINISH["SAFE_WITH_CB"] = 1)] = "SAFE_WITH_CB";
      FINISH[(FINISH["UNSAFE"] = 2)] = "UNSAFE";
    })((FINISH = exports.FINISH || (exports.FINISH = {})));
    exports.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      // Upper case
      exports.ALPHA.push(String.fromCharCode(i));
      // Lower case
      exports.ALPHA.push(String.fromCharCode(i + 0x20));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 0xa,
      B: 0xb,
      C: 0xc,
      D: 0xd,
      E: 0xe,
      F: 0xf,
      a: 0xa,
      b: 0xb,
      c: 0xc,
      d: 0xd,
      e: 0xe,
      f: 0xf,
    };
    exports.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
      "%",
      ";",
      ":",
      "&",
      "=",
      "+",
      "$",
      ",",
    ]);
    // TODO(indutny): use RFC
    exports.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~",
    ].concat(exports.ALPHANUM);
    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
    // All characters with 0x80 bit set to 1
    for (let i = 0x80; i <= 0xff; i++) {
      exports.URL_CHAR.push(i);
    }
    exports.HEX = exports.NUM.concat([
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
    ]);
    /* Tokens as defined by rfc 2616. Also lowercases them.
     *        token       = 1*<any CHAR except CTLs or separators>
     *     separators     = "(" | ")" | "<" | ">" | "@"
     *                    | "," | ";" | ":" | "\" | <">
     *                    | "/" | "[" | "]" | "?" | "="
     *                    | "{" | "}" | SP | HT
     */
    exports.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~",
    ].concat(exports.ALPHANUM);
    exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
    /*
     * Verify that a char is a valid visible (printable) US-ASCII
     * character or %x80-FF
     */
    exports.HEADER_CHARS = ["\t"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports.HEADER_CHARS.push(i);
      }
    }
    // ',' = \x44
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter(
      (c) => c !== 44
    );
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    var HEADER_STATE;
    (function (HEADER_STATE) {
      HEADER_STATE[(HEADER_STATE["GENERAL"] = 0)] = "GENERAL";
      HEADER_STATE[(HEADER_STATE["CONNECTION"] = 1)] = "CONNECTION";
      HEADER_STATE[(HEADER_STATE["CONTENT_LENGTH"] = 2)] = "CONTENT_LENGTH";
      HEADER_STATE[(HEADER_STATE["TRANSFER_ENCODING"] = 3)] =
        "TRANSFER_ENCODING";
      HEADER_STATE[(HEADER_STATE["UPGRADE"] = 4)] = "UPGRADE";
      HEADER_STATE[(HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5)] =
        "CONNECTION_KEEP_ALIVE";
      HEADER_STATE[(HEADER_STATE["CONNECTION_CLOSE"] = 6)] = "CONNECTION_CLOSE";
      HEADER_STATE[(HEADER_STATE["CONNECTION_UPGRADE"] = 7)] =
        "CONNECTION_UPGRADE";
      HEADER_STATE[(HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8)] =
        "TRANSFER_ENCODING_CHUNKED";
    })((HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {})));
    exports.SPECIAL_HEADERS = {
      connection: HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      upgrade: HEADER_STATE.UPGRADE,
    };
    //# sourceMappingURL=constants.js.map

    /***/
  },

  /***/ 1145: /***/ (module) => {
    module.exports =
      "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";

    /***/
  },

  /***/ 5627: /***/ (module) => {
    module.exports =
      "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";

    /***/
  },

  /***/ 1891: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports.enumToMap = enumToMap;
    //# sourceMappingURL=utils.js.map

    /***/
  },

  /***/ 6771: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kClients } = __nccwpck_require__(2785);
    const Agent = __nccwpck_require__(7890);
    const {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory,
    } = __nccwpck_require__(4347);
    const MockClient = __nccwpck_require__(8687);
    const MockPool = __nccwpck_require__(6193);
    const { matchValue, buildMockOptions } = __nccwpck_require__(9323);
    const { InvalidArgumentError, UndiciError } = __nccwpck_require__(8045);
    const Dispatcher = __nccwpck_require__(412);
    const Pluralizer = __nccwpck_require__(8891);
    const PendingInterceptorsFormatter = __nccwpck_require__(6823);

    class FakeWeakRef {
      constructor(value) {
        this.value = value;
      }

      deref() {
        return this.value;
      }
    }

    class MockAgent extends Dispatcher {
      constructor(opts) {
        super(opts);

        this[kNetConnect] = true;
        this[kIsMockActive] = true;

        // Instantiate Agent and encapsulate
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError(
            "Argument opts.agent must implement Agent"
          );
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;

        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }

      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);

        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }

      dispatch(opts, handler) {
        // Call MockAgent.get to perform additional setup before dispatching as normal
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }

      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }

      deactivate() {
        this[kIsMockActive] = false;
      }

      activate() {
        this[kIsMockActive] = true;
      }

      enableNetConnect(matcher) {
        if (
          typeof matcher === "string" ||
          typeof matcher === "function" ||
          matcher instanceof RegExp
        ) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError(
            "Unsupported matcher. Must be one of String|Function|RegExp."
          );
        }
      }

      disableNetConnect() {
        this[kNetConnect] = false;
      }

      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }

      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }

      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1
          ? new MockClient(origin, mockOptions)
          : new MockPool(origin, mockOptions);
      }

      [kMockAgentGet](origin) {
        // First check if we can immediately find it
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }

        // If the origin is not a string create a dummy parent pool and return to user
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }

        // If we match, create a pool and assign the same dispatches
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (
            nonExplicitDispatcher &&
            typeof keyMatcher !== "string" &&
            matchValue(keyMatcher, origin)
          ) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }

      [kGetNetConnect]() {
        return this[kNetConnect];
      }

      pendingInterceptors() {
        const mockAgentClients = this[kClients];

        return Array.from(mockAgentClients.entries())
          .flatMap(([origin, scope]) =>
            scope
              .deref()
              [kDispatches].map((dispatch) => ({ ...dispatch, origin }))
          )
          .filter(({ pending }) => pending);
      }

      assertNoPendingInterceptors({
        pendingInterceptorsFormatter = new PendingInterceptorsFormatter(),
      } = {}) {
        const pending = this.pendingInterceptors();

        if (pending.length === 0) {
          return;
        }

        const pluralizer = new Pluralizer(
          "interceptor",
          "interceptors"
        ).pluralize(pending.length);

        throw new UndiciError(
          `
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim()
        );
      }
    }

    module.exports = MockAgent;

    /***/
  },

  /***/ 8687: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { promisify } = __nccwpck_require__(3837);
    const Client = __nccwpck_require__(3598);
    const { buildMockDispatch } = __nccwpck_require__(9323);
    const {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
    } = __nccwpck_require__(4347);
    const { MockInterceptor } = __nccwpck_require__(410);
    const Symbols = __nccwpck_require__(2785);
    const { InvalidArgumentError } = __nccwpck_require__(8045);

    /**
     * MockClient provides an API that extends the Client to influence the mockDispatches.
     */
    class MockClient extends Client {
      constructor(origin, opts) {
        super(origin, opts);

        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError(
            "Argument opts.agent must implement Agent"
          );
        }

        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);

        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }

      get [Symbols.kConnected]() {
        return this[kConnected];
      }

      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }

      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    }

    module.exports = MockClient;

    /***/
  },

  /***/ 888: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { UndiciError } = __nccwpck_require__(8045);

    class MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message =
          message ||
          "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    }

    module.exports = {
      MockNotMatchedError,
    };

    /***/
  },

  /***/ 410: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { getResponseData, buildKey, addMockDispatch } =
      __nccwpck_require__(9323);
    const {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch,
    } = __nccwpck_require__(4347);
    const { InvalidArgumentError } = __nccwpck_require__(8045);
    const { buildURL } = __nccwpck_require__(3983);

    /**
     * Defines the scope API for an interceptor reply
     */
    class MockScope {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }

      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (
          typeof waitInMs !== "number" ||
          !Number.isInteger(waitInMs) ||
          waitInMs <= 0
        ) {
          throw new InvalidArgumentError(
            "waitInMs must be a valid integer > 0"
          );
        }

        this[kMockDispatch].delay = waitInMs;
        return this;
      }

      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }

      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (
          typeof repeatTimes !== "number" ||
          !Number.isInteger(repeatTimes) ||
          repeatTimes <= 0
        ) {
          throw new InvalidArgumentError(
            "repeatTimes must be a valid integer > 0"
          );
        }

        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    }

    /**
     * Defines an interceptor for a Mock
     */
    class MockInterceptor {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        // See https://github.com/nodejs/undici/issues/1245
        // As per RFC 3986, clients are not supposed to send URI
        // fragments to servers when they retrieve a document,
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }

        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }

      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength]
          ? { "content-length": responseData.length }
          : {};
        const headers = {
          ...this[kDefaultHeaders],
          ...contentLength,
          ...responseOptions.headers,
        };
        const trailers = {
          ...this[kDefaultTrailers],
          ...responseOptions.trailers,
        };

        return { statusCode, data, headers, trailers };
      }

      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }

      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        // Values of reply aren't available right now as they
        // can only be available when the reply callback is invoked.
        if (typeof replyData === "function") {
          // We'll first wrap the provided callback in another function,
          // this function will properly resolve the data from the callback
          // when invoked.
          const wrappedDefaultsCallback = (opts) => {
            // Our reply options callback contains the parameter for statusCode, data and options.
            const resolvedData = replyData(opts);

            // Check if it is in the right format
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError(
                "reply options callback must return an object"
              );
            }

            const {
              statusCode,
              data = "",
              responseOptions = {},
            } = resolvedData;
            this.validateReplyParameters(statusCode, data, responseOptions);
            // Since the values can be obtained immediately we return them
            // from this higher order function that will be resolved later.
            return {
              ...this.createMockScopeDispatchData(
                statusCode,
                data,
                responseOptions
              ),
            };
          };

          // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
          const newMockDispatch = addMockDispatch(
            this[kDispatches],
            this[kDispatchKey],
            wrappedDefaultsCallback
          );
          return new MockScope(newMockDispatch);
        }

        // We can have either one or three parameters, if we get here,
        // we should have 1-3 parameters. So we spread the arguments of
        // this function to obtain the parameters, since replyData will always
        // just be the statusCode.
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);

        // Send in-already provided data like usual
        const dispatchData = this.createMockScopeDispatchData(
          statusCode,
          data,
          responseOptions
        );
        const newMockDispatch = addMockDispatch(
          this[kDispatches],
          this[kDispatchKey],
          dispatchData
        );
        return new MockScope(newMockDispatch);
      }

      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }

        const newMockDispatch = addMockDispatch(
          this[kDispatches],
          this[kDispatchKey],
          { error }
        );
        return new MockScope(newMockDispatch);
      }

      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }

        this[kDefaultHeaders] = headers;
        return this;
      }

      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }

        this[kDefaultTrailers] = trailers;
        return this;
      }

      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    }

    module.exports.MockInterceptor = MockInterceptor;
    module.exports.MockScope = MockScope;

    /***/
  },

  /***/ 6193: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { promisify } = __nccwpck_require__(3837);
    const Pool = __nccwpck_require__(4634);
    const { buildMockDispatch } = __nccwpck_require__(9323);
    const {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
    } = __nccwpck_require__(4347);
    const { MockInterceptor } = __nccwpck_require__(410);
    const Symbols = __nccwpck_require__(2785);
    const { InvalidArgumentError } = __nccwpck_require__(8045);

    /**
     * MockPool provides an API that extends the Pool to influence the mockDispatches.
     */
    class MockPool extends Pool {
      constructor(origin, opts) {
        super(origin, opts);

        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError(
            "Argument opts.agent must implement Agent"
          );
        }

        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);

        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }

      get [Symbols.kConnected]() {
        return this[kConnected];
      }

      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }

      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    }

    module.exports = MockPool;

    /***/
  },

  /***/ 4347: /***/ (module) => {
    module.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected"),
    };

    /***/
  },

  /***/ 9323: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { MockNotMatchedError } = __nccwpck_require__(888);
    const {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect,
    } = __nccwpck_require__(4347);
    const { buildURL, nop } = __nccwpck_require__(3983);
    const { STATUS_CODES } = __nccwpck_require__(3685);
    const {
      types: { isPromise },
    } = __nccwpck_require__(3837);

    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }

    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }

    /**
     * @param {import('../../index').Headers|string[]|Record<string, string>} headers
     * @param {string} key
     */
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }

        return undefined;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }

    /** @param {string[]} headers */
    function buildHeadersFromArray(headers) {
      // fetch HeadersList
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }

    function matchHeaders(mockDispatch, headers) {
      if (typeof mockDispatch.headers === "function") {
        if (Array.isArray(headers)) {
          // fetch HeadersList
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch.headers === "undefined") {
        return true;
      }
      if (
        typeof headers !== "object" ||
        typeof mockDispatch.headers !== "object"
      ) {
        return false;
      }

      for (const [matchHeaderName, matchHeaderValue] of Object.entries(
        mockDispatch.headers
      )) {
        const headerValue = getHeaderByName(headers, matchHeaderName);

        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }

    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }

      const pathSegments = path.split("?");

      if (pathSegments.length !== 2) {
        return path;
      }

      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }

    function matchKey(mockDispatch, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch.path, path);
      const methodMatch = matchValue(mockDispatch.method, method);
      const bodyMatch =
        typeof mockDispatch.body !== "undefined"
          ? matchValue(mockDispatch.body, body)
          : true;
      const headersMatch = matchHeaders(mockDispatch, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }

    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }

    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath =
        typeof basePath === "string" ? safeUrl(basePath) : basePath;

      // Match path
      let matchedMockDispatches = mockDispatches
        .filter(({ consumed }) => !consumed)
        .filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(
          `Mock dispatch not matched for path '${resolvedPath}'`
        );
      }

      // Match method
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) =>
        matchValue(method, key.method)
      );
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(
          `Mock dispatch not matched for method '${key.method}'`
        );
      }

      // Match body
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) =>
        typeof body !== "undefined" ? matchValue(body, key.body) : true
      );
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(
          `Mock dispatch not matched for body '${key.body}'`
        );
      }

      // Match headers
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) =>
        matchHeaders(mockDispatch, key.headers)
      );
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(
          `Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`
        );
      }

      return matchedMockDispatches[0];
    }

    function addMockDispatch(mockDispatches, key, data) {
      const baseData = {
        timesInvoked: 0,
        times: 1,
        persist: false,
        consumed: false,
      };
      const replyData =
        typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = {
        ...baseData,
        ...key,
        pending: true,
        data: { error: null, ...replyData },
      };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }

    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }

    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query,
      };
    }

    function generateKeyValues(data) {
      return Object.entries(data).reduce(
        (keyValuePairs, [key, value]) => [
          ...keyValuePairs,
          Buffer.from(`${key}`),
          Array.isArray(value)
            ? value.map((x) => Buffer.from(`${x}`))
            : Buffer.from(`${value}`),
        ],
        []
      );
    }

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
     * @param {number} statusCode
     */
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }

    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }

    /**
     * Mock dispatch function used to simulate undici dispatches
     */
    function mockDispatch(opts, handler) {
      // Get mock dispatch from built key
      const key = buildKey(opts);
      const mockDispatch = getMockDispatch(this[kDispatches], key);

      mockDispatch.timesInvoked++;

      // Here's where we resolve a callback if a callback is present for the dispatch data.
      if (mockDispatch.data.callback) {
        mockDispatch.data = {
          ...mockDispatch.data,
          ...mockDispatch.data.callback(opts),
        };
      }

      // Parse mockDispatch data
      const {
        data: { statusCode, data, headers, trailers, error },
        delay,
        persist,
      } = mockDispatch;
      const { timesInvoked, times } = mockDispatch;

      // If it's used up and not persistent, mark as consumed
      mockDispatch.consumed = !persist && timesInvoked >= times;
      mockDispatch.pending = timesInvoked < times;

      // If specified, trigger dispatch error
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }

      // Handle the request with a delay if necessary
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }

      function handleReply(mockDispatches, _data = data) {
        // fetch's HeadersList is a 1D string array
        const optsHeaders = Array.isArray(opts.headers)
          ? buildHeadersFromArray(opts.headers)
          : opts.headers;
        const body =
          typeof _data === "function"
            ? _data({ ...opts, headers: optsHeaders })
            : _data;

        // util.types.isPromise is likely needed for jest.
        if (isPromise(body)) {
          // If handleReply is asynchronous, throwing an error
          // in the callback will reject the promise, rather than
          // synchronously throw the error, which breaks some tests.
          // Rather, we wait for the callback to resolve if it is a
          // promise, and then re-run handleReply with the new body.
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }

        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);

        handler.abort = nop;
        handler.onHeaders(
          statusCode,
          responseHeaders,
          resume,
          getStatusText(statusCode)
        );
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }

      function resume() {}

      return true;
    }

    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];

      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(
                  `${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`
                );
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(
                  `${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`
                );
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }

    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (
        Array.isArray(netConnect) &&
        netConnect.some((matcher) => matchValue(matcher, url.host))
      ) {
        return true;
      }
      return false;
    }

    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }

    module.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName,
    };

    /***/
  },

  /***/ 6823: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { Transform } = __nccwpck_require__(2781);
    const { Console } = __nccwpck_require__(6206);

    /**
     * Gets the output of `console.table(…)` as a string.
     */
    module.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          },
        });

        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI,
          },
        });
      }

      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({
            method,
            path,
            data: { statusCode },
            persist,
            times,
            timesInvoked,
            origin,
          }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "✅" : "❌",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked,
          })
        );

        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };

    /***/
  },

  /***/ 8891: /***/ (module) => {
    const singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this",
    };

    const plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these",
    };

    module.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }

      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };

    /***/
  },

  /***/ 8266: /***/ (module) => {
    /* eslint-disable */

    // Extracted from node/lib/internal/fixed_queue.js

    // Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
    const kSize = 2048;
    const kMask = kSize - 1;

    // The FixedQueue is implemented as a singly-linked list of fixed-size
    // circular buffers. It looks something like this:
    //
    //  head                                                       tail
    //    |                                                          |
    //    v                                                          v
    // +-----------+ <-----\       +-----------+ <------\         +-----------+
    // |  [null]   |        \----- |   next    |         \------- |   next    |
    // +-----------+               +-----------+                  +-----------+
    // |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
    // |   item    |               |   item    |                  |  [empty]  |
    // |   item    |               |   item    |                  |  [empty]  |
    // |   item    |               |   item    |                  |  [empty]  |
    // |   item    |               |   item    |       bottom --> |   item    |
    // |   item    |               |   item    |                  |   item    |
    // |    ...    |               |    ...    |                  |    ...    |
    // |   item    |               |   item    |                  |   item    |
    // |   item    |               |   item    |                  |   item    |
    // |  [empty]  | <-- top       |   item    |                  |   item    |
    // |  [empty]  |               |   item    |                  |   item    |
    // |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
    // +-----------+               +-----------+                  +-----------+
    //
    // Or, if there is only one circular buffer, it looks something
    // like either of these:
    //
    //  head   tail                                 head   tail
    //    |     |                                     |     |
    //    v     v                                     v     v
    // +-----------+                               +-----------+
    // |  [null]   |                               |  [null]   |
    // +-----------+                               +-----------+
    // |  [empty]  |                               |   item    |
    // |  [empty]  |                               |   item    |
    // |   item    | <-- bottom            top --> |  [empty]  |
    // |   item    |                               |  [empty]  |
    // |  [empty]  | <-- top            bottom --> |   item    |
    // |  [empty]  |                               |   item    |
    // +-----------+                               +-----------+
    //
    // Adding a value means moving `top` forward by one, removing means
    // moving `bottom` forward by one. After reaching the end, the queue
    // wraps around.
    //
    // When `top === bottom` the current queue is empty and when
    // `top + 1 === bottom` it's full. This wastes a single space of storage
    // but allows much quicker checks.

    class FixedCircularBuffer {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }

      isEmpty() {
        return this.top === this.bottom;
      }

      isFull() {
        return ((this.top + 1) & kMask) === this.bottom;
      }

      push(data) {
        this.list[this.top] = data;
        this.top = (this.top + 1) & kMask;
      }

      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) return null;
        this.list[this.bottom] = undefined;
        this.bottom = (this.bottom + 1) & kMask;
        return nextItem;
      }
    }

    module.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }

      isEmpty() {
        return this.head.isEmpty();
      }

      push(data) {
        if (this.head.isFull()) {
          // Head is full: Creates a new queue, sets the old queue's `.next` to it,
          // and sets it as the new main queue.
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }

      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          // If there is another queue, it forms the new tail.
          this.tail = tail.next;
        }
        return next;
      }
    };

    /***/
  },

  /***/ 3198: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const DispatcherBase = __nccwpck_require__(4839);
    const FixedQueue = __nccwpck_require__(8266);
    const {
      kConnected,
      kSize,
      kRunning,
      kPending,
      kQueued,
      kBusy,
      kFree,
      kUrl,
      kClose,
      kDestroy,
      kDispatch,
    } = __nccwpck_require__(2785);
    const PoolStats = __nccwpck_require__(9689);

    const kClients = Symbol("clients");
    const kNeedDrain = Symbol("needDrain");
    const kQueue = Symbol("queue");
    const kClosedResolve = Symbol("closed resolve");
    const kOnDrain = Symbol("onDrain");
    const kOnConnect = Symbol("onConnect");
    const kOnDisconnect = Symbol("onDisconnect");
    const kOnConnectionError = Symbol("onConnectionError");
    const kGetDispatcher = Symbol("get dispatcher");
    const kAddClient = Symbol("add client");
    const kRemoveClient = Symbol("remove client");
    const kStats = Symbol("stats");

    class PoolBase extends DispatcherBase {
      constructor() {
        super();

        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;

        const pool = this;

        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];

          let needDrain = false;

          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }

          this[kNeedDrain] = needDrain;

          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }

          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(
              pool[kClosedResolve]
            );
          }
        };

        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };

        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };

        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };

        this[kStats] = new PoolStats(this);
      }

      get [kBusy]() {
        return this[kNeedDrain];
      }

      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }

      get [kFree]() {
        return this[kClients].filter(
          (client) => client[kConnected] && !client[kNeedDrain]
        ).length;
      }

      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }

      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }

      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }

      get stats() {
        return this[kStats];
      }

      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }

      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }

        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }

      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();

        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }

        return !this[kNeedDrain];
      }

      [kAddClient](client) {
        client
          .on("drain", this[kOnDrain])
          .on("connect", this[kOnConnect])
          .on("disconnect", this[kOnDisconnect])
          .on("connectionError", this[kOnConnectionError]);

        this[kClients].push(client);

        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }

        return this;
      }

      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });

        this[kNeedDrain] = this[kClients].some(
          (dispatcher) =>
            !dispatcher[kNeedDrain] &&
            dispatcher.closed !== true &&
            dispatcher.destroyed !== true
        );
      }
    }

    module.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher,
    };

    /***/
  },

  /***/ 9689: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kFree, kConnected, kPending, kQueued, kRunning, kSize } =
      __nccwpck_require__(2785);
    const kPool = Symbol("pool");

    class PoolStats {
      constructor(pool) {
        this[kPool] = pool;
      }

      get connected() {
        return this[kPool][kConnected];
      }

      get free() {
        return this[kPool][kFree];
      }

      get pending() {
        return this[kPool][kPending];
      }

      get queued() {
        return this[kPool][kQueued];
      }

      get running() {
        return this[kPool][kRunning];
      }

      get size() {
        return this[kPool][kSize];
      }
    }

    module.exports = PoolStats;

    /***/
  },

  /***/ 4634: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } =
      __nccwpck_require__(3198);
    const Client = __nccwpck_require__(3598);
    const { InvalidArgumentError } = __nccwpck_require__(8045);
    const util = __nccwpck_require__(3983);
    const { kUrl, kInterceptors } = __nccwpck_require__(2785);
    const buildConnector = __nccwpck_require__(2067);

    const kOptions = Symbol("options");
    const kConnections = Symbol("connections");
    const kFactory = Symbol("factory");

    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }

    class Pool extends PoolBase {
      constructor(
        origin,
        {
          connections,
          factory = defaultFactory,
          connect,
          connectTimeout,
          tls,
          maxCachedSessions,
          socketPath,
          autoSelectFamily,
          autoSelectFamilyAttemptTimeout,
          allowH2,
          ...options
        } = {}
      ) {
        super();

        if (
          connections != null &&
          (!Number.isFinite(connections) || connections < 0)
        ) {
          throw new InvalidArgumentError("invalid connections");
        }

        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }

        if (
          connect != null &&
          typeof connect !== "function" &&
          typeof connect !== "object"
        ) {
          throw new InvalidArgumentError(
            "connect must be a function or an object"
          );
        }

        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...(util.nodeHasAutoSelectFamily && autoSelectFamily
              ? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
              : undefined),
            ...connect,
          });
        }

        this[kInterceptors] =
          options.interceptors &&
          options.interceptors.Pool &&
          Array.isArray(options.interceptors.Pool)
            ? options.interceptors.Pool
            : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors
          ? { ...options.interceptors }
          : undefined;
        this[kFactory] = factory;
      }

      [kGetDispatcher]() {
        let dispatcher = this[kClients].find(
          (dispatcher) => !dispatcher[kNeedDrain]
        );

        if (dispatcher) {
          return dispatcher;
        }

        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }

        return dispatcher;
      }
    }

    module.exports = Pool;

    /***/
  },

  /***/ 7858: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kProxy, kClose, kDestroy, kInterceptors } =
      __nccwpck_require__(2785);
    const { URL } = __nccwpck_require__(7310);
    const Agent = __nccwpck_require__(7890);
    const Pool = __nccwpck_require__(4634);
    const DispatcherBase = __nccwpck_require__(4839);
    const { InvalidArgumentError, RequestAbortedError } =
      __nccwpck_require__(8045);
    const buildConnector = __nccwpck_require__(2067);

    const kAgent = Symbol("proxy agent");
    const kClient = Symbol("proxy client");
    const kProxyHeaders = Symbol("proxy headers");
    const kRequestTls = Symbol("request tls settings");
    const kProxyTls = Symbol("proxy tls settings");
    const kConnectEndpoint = Symbol("connect endpoint function");

    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }

    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }

      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }

      return {
        uri: opts.uri,
        protocol: opts.protocol || "https",
      };
    }

    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }

    class ProxyAgent extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] =
          opts.interceptors &&
          opts.interceptors.ProxyAgent &&
          Array.isArray(opts.interceptors.ProxyAgent)
            ? opts.interceptors.ProxyAgent
            : [];

        if (typeof opts === "string") {
          opts = { uri: opts };
        }

        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }

        const { clientFactory = defaultFactory } = opts;

        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError(
            "Proxy opts.clientFactory must be a function."
          );
        }

        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};

        const resolvedUrl = new URL(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;

        if (opts.auth && opts.token) {
          throw new InvalidArgumentError(
            "opts.auth cannot be used in combination with opts.token"
          );
        } else if (opts.auth) {
          /* @deprecated in favour of opts.token */
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] =
            `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }

        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts, callback) => {
            let requestedHost = opts.host;
            if (!opts.port) {
              requestedHost += `:${defaultProtocolPort(opts.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host,
                },
              });
              if (statusCode !== 200) {
                socket.on("error", () => {}).destroy();
                callback(
                  new RequestAbortedError(
                    `Proxy response (${statusCode}) !== 200 when HTTP Tunneling`
                  )
                );
              }
              if (opts.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts.servername;
              }
              this[kConnectEndpoint](
                { ...opts, servername, httpSocket: socket },
                callback
              );
            } catch (err) {
              callback(err);
            }
          },
        });
      }

      dispatch(opts, handler) {
        const { host } = new URL(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host,
            },
          },
          handler
        );
      }

      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }

      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    }

    /**
     * @param {string[] | Record<string, string>} headers
     * @returns {Record<string, string>}
     */
    function buildHeaders(headers) {
      // When using undici.fetch, the headers list is stored
      // as an array.
      if (Array.isArray(headers)) {
        /** @type {Record<string, string>} */
        const headersPair = {};

        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }

        return headersPair;
      }

      return headers;
    }

    /**
     * @param {Record<string, string>} headers
     *
     * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
     * Nevertheless, it was changed and to avoid a security vulnerability by end users
     * this check was created.
     * It should be removed in the next major version for performance reasons
     */
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth =
        headers &&
        Object.keys(headers).find(
          (key) => key.toLowerCase() === "proxy-authorization"
        );
      if (existProxyAuth) {
        throw new InvalidArgumentError(
          "Proxy-Authorization should be sent in ProxyAgent constructor"
        );
      }
    }

    module.exports = ProxyAgent;

    /***/
  },

  /***/ 9459: /***/ (module) => {
    let fastNow = Date.now();
    let fastNowTimeout;

    const fastTimers = [];

    function onTimeout() {
      fastNow = Date.now();

      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];

        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }

        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }

      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }

    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }

    class Timeout {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;

        //  -2 not in timer list
        //  -1 in timer list but inactive
        //   0 in timer list waiting for time
        // > 0 in timer list waiting for time to expire
        this.state = -2;

        this.refresh();
      }

      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }

        this.state = 0;
      }

      clear() {
        this.state = -1;
      }
    }

    module.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3
          ? setTimeout(callback, delay, opaque)
          : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      },
    };

    /***/
  },

  /***/ 5354: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const diagnosticsChannel = __nccwpck_require__(7643);
    const { uid, states } = __nccwpck_require__(9188);
    const { kReadyState, kSentClose, kByteParser, kReceivedClose } =
      __nccwpck_require__(7578);
    const { fireEvent, failWebsocketConnection } = __nccwpck_require__(5515);
    const { CloseEvent } = __nccwpck_require__(2611);
    const { makeRequest } = __nccwpck_require__(8359);
    const { fetching } = __nccwpck_require__(4881);
    const { Headers } = __nccwpck_require__(554);
    const { getGlobalDispatcher } = __nccwpck_require__(1892);
    const { kHeadersList } = __nccwpck_require__(2785);

    const channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel(
      "undici:websocket:socket_error"
    );

    /** @type {import('crypto')} */
    let crypto;
    try {
      crypto = __nccwpck_require__(6113);
    } catch {}

    /**
     * @see https://websockets.spec.whatwg.org/#concept-websocket-establish
     * @param {URL} url
     * @param {string|string[]} protocols
     * @param {import('./websocket').WebSocket} ws
     * @param {(response: any) => void} onEstablish
     * @param {Partial<import('../../types/websocket').WebSocketInit>} options
     */
    function establishWebSocketConnection(
      url,
      protocols,
      ws,
      onEstablish,
      options
    ) {
      // 1. Let requestURL be a copy of url, with its scheme set to "http", if url’s
      //    scheme is "ws", and to "https" otherwise.
      const requestURL = url;

      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";

      // 2. Let request be a new request, whose URL is requestURL, client is client,
      //    service-workers mode is "none", referrer is "no-referrer", mode is
      //    "websocket", credentials mode is "include", cache mode is "no-store" ,
      //    and redirect mode is "error".
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error",
      });

      // Note: undici extension, allow setting custom headers.
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];

        request.headersList = headersList;
      }

      // 3. Append (`Upgrade`, `websocket`) to request’s header list.
      // 4. Append (`Connection`, `Upgrade`) to request’s header list.
      // Note: both of these are handled by undici currently.
      // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397

      // 5. Let keyValue be a nonce consisting of a randomly selected
      //    16-byte value that has been forgiving-base64-encoded and
      //    isomorphic encoded.
      const keyValue = crypto.randomBytes(16).toString("base64");

      // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s
      //    header list.
      request.headersList.append("sec-websocket-key", keyValue);

      // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s
      //    header list.
      request.headersList.append("sec-websocket-version", "13");

      // 8. For each protocol in protocols, combine
      //    (`Sec-WebSocket-Protocol`, protocol) in request’s header
      //    list.
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }

      // 9. Let permessageDeflate be a user-agent defined
      //    "permessage-deflate" extension header value.
      // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673
      // TODO: enable once permessage-deflate is supported
      const permessageDeflate = ""; // 'permessage-deflate; 15'

      // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to
      //     request’s header list.
      // request.headersList.append('sec-websocket-extensions', permessageDeflate)

      // 11. Fetch request with useParallelQueue set to true, and
      //     processResponse given response being these steps:
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          // 1. If response is a network error or its status is not 101,
          //    fail the WebSocket connection.
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(
              ws,
              "Received network error or non-101 status code."
            );
            return;
          }

          // 2. If protocols is not the empty list and extracting header
          //    list values given `Sec-WebSocket-Protocol` and response’s
          //    header list results in null, failure, or the empty byte
          //    sequence, then fail the WebSocket connection.
          if (
            protocols.length !== 0 &&
            !response.headersList.get("Sec-WebSocket-Protocol")
          ) {
            failWebsocketConnection(
              ws,
              "Server did not respond with sent protocols."
            );
            return;
          }

          // 3. Follow the requirements stated step 2 to step 6, inclusive,
          //    of the last set of steps in section 4.1 of The WebSocket
          //    Protocol to validate response. This either results in fail
          //    the WebSocket connection or the WebSocket connection is
          //    established.

          // 2. If the response lacks an |Upgrade| header field or the |Upgrade|
          //    header field contains a value that is not an ASCII case-
          //    insensitive match for the value "websocket", the client MUST
          //    _Fail the WebSocket Connection_.
          if (
            response.headersList.get("Upgrade")?.toLowerCase() !== "websocket"
          ) {
            failWebsocketConnection(
              ws,
              'Server did not set Upgrade header to "websocket".'
            );
            return;
          }

          // 3. If the response lacks a |Connection| header field or the
          //    |Connection| header field doesn't contain a token that is an
          //    ASCII case-insensitive match for the value "Upgrade", the client
          //    MUST _Fail the WebSocket Connection_.
          if (
            response.headersList.get("Connection")?.toLowerCase() !== "upgrade"
          ) {
            failWebsocketConnection(
              ws,
              'Server did not set Connection header to "upgrade".'
            );
            return;
          }

          // 4. If the response lacks a |Sec-WebSocket-Accept| header field or
          //    the |Sec-WebSocket-Accept| contains a value other than the
          //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-
          //    Key| (as a string, not base64-decoded) with the string "258EAFA5-
          //    E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and
          //    trailing whitespace, the client MUST _Fail the WebSocket
          //    Connection_.
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto
            .createHash("sha1")
            .update(keyValue + uid)
            .digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(
              ws,
              "Incorrect hash received in Sec-WebSocket-Accept header."
            );
            return;
          }

          // 5. If the response includes a |Sec-WebSocket-Extensions| header
          //    field and this header field indicates the use of an extension
          //    that was not present in the client's handshake (the server has
          //    indicated an extension not requested by the client), the client
          //    MUST _Fail the WebSocket Connection_.  (The parsing of this
          //    header field to determine which extensions are requested is
          //    discussed in Section 9.1.)
          const secExtension = response.headersList.get(
            "Sec-WebSocket-Extensions"
          );

          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(
              ws,
              "Received different permessage-deflate than the one set."
            );
            return;
          }

          // 6. If the response includes a |Sec-WebSocket-Protocol| header field
          //    and this header field indicates the use of a subprotocol that was
          //    not present in the client's handshake (the server has indicated a
          //    subprotocol not requested by the client), the client MUST _Fail
          //    the WebSocket Connection_.
          const secProtocol = response.headersList.get(
            "Sec-WebSocket-Protocol"
          );

          if (
            secProtocol !== null &&
            secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")
          ) {
            failWebsocketConnection(
              ws,
              "Protocol was not set in the opening handshake."
            );
            return;
          }

          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);

          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension,
            });
          }

          onEstablish(response);
        },
      });

      return controller;
    }

    /**
     * @param {Buffer} chunk
     */
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }

    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
     */
    function onSocketClose() {
      const { ws } = this;

      // If the TCP connection was closed after the
      // WebSocket closing handshake was completed, the WebSocket connection
      // is said to have been closed _cleanly_.
      const wasClean = ws[kSentClose] && ws[kReceivedClose];

      let code = 1005;
      let reason = "";

      const result = ws[kByteParser].closingInfo;

      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        // If _The WebSocket
        // Connection is Closed_ and no Close control frame was received by the
        // endpoint (such as could occur if the underlying transport connection
        // is lost), _The WebSocket Connection Close Code_ is considered to be
        // 1006.
        code = 1006;
      }

      // 1. Change the ready state to CLOSED (3).
      ws[kReadyState] = states.CLOSED;

      // 2. If the user agent was required to fail the WebSocket
      //    connection, or if the WebSocket connection was closed
      //    after being flagged as full, fire an event named error
      //    at the WebSocket object.
      // TODO

      // 3. Fire an event named close at the WebSocket object,
      //    using CloseEvent, with the wasClean attribute
      //    initialized to true if the connection closed cleanly
      //    and false otherwise, the code attribute initialized to
      //    the WebSocket connection close code, and the reason
      //    attribute initialized to the result of applying UTF-8
      //    decode without BOM to the WebSocket connection close
      //    reason.
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason,
      });

      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason,
        });
      }
    }

    function onSocketError(error) {
      const { ws } = this;

      ws[kReadyState] = states.CLOSING;

      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }

      this.destroy();
    }

    module.exports = {
      establishWebSocketConnection,
    };

    /***/
  },

  /***/ 9188: /***/ (module) => {
    // This is a Globally Unique Identifier unique used
    // to validate that the endpoint accepts websocket
    // connections.
    // See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3
    const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

    /** @type {PropertyDescriptor} */
    const staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false,
    };

    const states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3,
    };

    const opcodes = {
      CONTINUATION: 0x0,
      TEXT: 0x1,
      BINARY: 0x2,
      CLOSE: 0x8,
      PING: 0x9,
      PONG: 0xa,
    };

    const maxUnsigned16Bit = 2 ** 16 - 1; // 65535

    const parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4,
    };

    const emptyBuffer = Buffer.allocUnsafe(0);

    module.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer,
    };

    /***/
  },

  /***/ 2611: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { webidl } = __nccwpck_require__(1744);
    const { kEnumerableProperty } = __nccwpck_require__(3983);
    const { MessagePort } = __nccwpck_require__(1267);

    /**
     * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
     */
    class MessageEvent extends Event {
      #eventInit;

      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, {
          header: "MessageEvent constructor",
        });

        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);

        super(type, eventInitDict);

        this.#eventInit = eventInitDict;
      }

      get data() {
        webidl.brandCheck(this, MessageEvent);

        return this.#eventInit.data;
      }

      get origin() {
        webidl.brandCheck(this, MessageEvent);

        return this.#eventInit.origin;
      }

      get lastEventId() {
        webidl.brandCheck(this, MessageEvent);

        return this.#eventInit.lastEventId;
      }

      get source() {
        webidl.brandCheck(this, MessageEvent);

        return this.#eventInit.source;
      }

      get ports() {
        webidl.brandCheck(this, MessageEvent);

        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }

        return this.#eventInit.ports;
      }

      initMessageEvent(
        type,
        bubbles = false,
        cancelable = false,
        data = null,
        origin = "",
        lastEventId = "",
        source = null,
        ports = []
      ) {
        webidl.brandCheck(this, MessageEvent);

        webidl.argumentLengthCheck(arguments, 1, {
          header: "MessageEvent.initMessageEvent",
        });

        return new MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports,
        });
      }
    }

    /**
     * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
     */
    class CloseEvent extends Event {
      #eventInit;

      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, {
          header: "CloseEvent constructor",
        });

        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);

        super(type, eventInitDict);

        this.#eventInit = eventInitDict;
      }

      get wasClean() {
        webidl.brandCheck(this, CloseEvent);

        return this.#eventInit.wasClean;
      }

      get code() {
        webidl.brandCheck(this, CloseEvent);

        return this.#eventInit.code;
      }

      get reason() {
        webidl.brandCheck(this, CloseEvent);

        return this.#eventInit.reason;
      }
    }

    // https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface
    class ErrorEvent extends Event {
      #eventInit;

      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, {
          header: "ErrorEvent constructor",
        });

        super(type, eventInitDict);

        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});

        this.#eventInit = eventInitDict;
      }

      get message() {
        webidl.brandCheck(this, ErrorEvent);

        return this.#eventInit.message;
      }

      get filename() {
        webidl.brandCheck(this, ErrorEvent);

        return this.#eventInit.filename;
      }

      get lineno() {
        webidl.brandCheck(this, ErrorEvent);

        return this.#eventInit.lineno;
      }

      get colno() {
        webidl.brandCheck(this, ErrorEvent);

        return this.#eventInit.colno;
      }

      get error() {
        webidl.brandCheck(this, ErrorEvent);

        return this.#eventInit.error;
      }
    }

    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true,
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty,
    });

    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true,
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty,
    });

    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true,
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty,
    });

    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);

    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );

    const eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
    ];

    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null,
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: "",
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: "",
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null,
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        },
      },
    ]);

    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0,
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: "",
      },
    ]);

    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: "",
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: "",
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0,
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0,
      },
      {
        key: "error",
        converter: webidl.converters.any,
      },
    ]);

    module.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent,
    };

    /***/
  },

  /***/ 5444: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { maxUnsigned16Bit } = __nccwpck_require__(9188);

    /** @type {import('crypto')} */
    let crypto;
    try {
      crypto = __nccwpck_require__(6113);
    } catch {}

    class WebsocketFrameSend {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto.randomBytes(4);
      }

      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;

        /** @type {number} */
        let payloadLength = bodyLength; // 0-125
        let offset = 6;

        if (bodyLength > maxUnsigned16Bit) {
          offset += 8; // payload length is next 8 bytes
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2; // payload length is next 2 bytes
          payloadLength = 126;
        }

        const buffer = Buffer.allocUnsafe(bodyLength + offset);

        // Clear first 2 bytes, everything else is overwritten
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 0x80; // FIN
        buffer[0] = (buffer[0] & 0xf0) + opcode; // opcode

        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];

        buffer[1] = payloadLength;

        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          // Clear extended payload length
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }

        buffer[1] |= 0x80; // MASK

        // mask body
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }

        return buffer;
      }
    }

    module.exports = {
      WebsocketFrameSend,
    };

    /***/
  },

  /***/ 1688: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { Writable } = __nccwpck_require__(2781);
    const diagnosticsChannel = __nccwpck_require__(7643);
    const { parserStates, opcodes, states, emptyBuffer } =
      __nccwpck_require__(9188);
    const { kReadyState, kSentClose, kResponse, kReceivedClose } =
      __nccwpck_require__(7578);
    const {
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived,
    } = __nccwpck_require__(5515);
    const { WebsocketFrameSend } = __nccwpck_require__(5444);

    // This code was influenced by ws released under the MIT license.
    // Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
    // Copyright (c) 2013 Arnout Kazemier and contributors
    // Copyright (c) 2016 Luigi Pinca and contributors

    const channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

    class ByteParser extends Writable {
      #buffers = [];
      #byteOffset = 0;

      #state = parserStates.INFO;

      #info = {};
      #fragments = [];

      constructor(ws) {
        super();

        this.ws = ws;
      }

      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;

        this.run(callback);
      }

      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            // If there aren't enough bytes to parse the payload length, etc.
            if (this.#byteOffset < 2) {
              return callback();
            }

            const buffer = this.consume(2);

            this.#info.fin = (buffer[0] & 0x80) !== 0;
            this.#info.opcode = buffer[0] & 0x0f;

            // If we receive a fragmented message, we use the type of the first
            // frame to parse the full message as binary/text, when it's terminated
            this.#info.originalOpcode ??= this.#info.opcode;

            this.#info.fragmented =
              !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;

            if (
              this.#info.fragmented &&
              this.#info.opcode !== opcodes.BINARY &&
              this.#info.opcode !== opcodes.TEXT
            ) {
              // Only text and binary frames can be fragmented
              failWebsocketConnection(
                this.ws,
                "Invalid frame type was fragmented."
              );
              return;
            }

            const payloadLength = buffer[1] & 0x7f;

            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }

            if (this.#info.fragmented && payloadLength > 125) {
              // A fragmented frame can't be fragmented itself
              failWebsocketConnection(
                this.ws,
                "Fragmented frame exceeded 125 bytes."
              );
              return;
            } else if (
              (this.#info.opcode === opcodes.PING ||
                this.#info.opcode === opcodes.PONG ||
                this.#info.opcode === opcodes.CLOSE) &&
              payloadLength > 125
            ) {
              // Control frames can have a payload length of 125 bytes MAX
              failWebsocketConnection(
                this.ws,
                "Payload length for control frame exceeded 125 bytes."
              );
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(
                  this.ws,
                  "Received close frame with a 1-byte body."
                );
                return;
              }

              const body = this.consume(payloadLength);

              this.#info.closeInfo = this.parseCloseBody(false, body);

              if (!this.ws[kSentClose]) {
                // If an endpoint receives a Close frame and did not previously send a
                // Close frame, the endpoint MUST send a Close frame in response.  (When
                // sending a Close frame in response, the endpoint typically echos the
                // status code it received.)
                const body = Buffer.allocUnsafe(2);
                body.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body);

                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }

              // Upon either sending or receiving a Close control frame, it is said
              // that _The WebSocket Closing Handshake is Started_ and that the
              // WebSocket connection is in the CLOSING state.
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;

              this.end();

              return;
            } else if (this.#info.opcode === opcodes.PING) {
              // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in
              // response, unless it already received a Close frame.
              // A Pong frame sent in response to a Ping frame must have identical
              // "Application data"

              const body = this.consume(payloadLength);

              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);

                this.ws[kResponse].socket.write(
                  frame.createFrame(opcodes.PONG)
                );

                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body,
                  });
                }
              }

              this.#state = parserStates.INFO;

              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              // A Pong frame MAY be sent unsolicited.  This serves as a
              // unidirectional heartbeat.  A response to an unsolicited Pong frame is
              // not expected.

              const body = this.consume(payloadLength);

              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body,
                });
              }

              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }

            const buffer = this.consume(2);

            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }

            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);

            // 2^31 is the maxinimum bytes an arraybuffer can contain
            // on 32-bit systems. Although, on 64-bit systems, this is
            // 2^53-1 bytes.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
            // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275
            // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(
                this.ws,
                "Received payload length > 2^31 bytes."
              );
              return;
            }

            const lower = buffer.readUInt32BE(4);

            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              // If there is still more data in this chunk that needs to be read
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              // If the server sent multiple frames in a single chunk

              const body = this.consume(this.#info.payloadLength);

              this.#fragments.push(body);

              // If the frame is unfragmented, or a fragmented frame was terminated,
              // a message was received
              if (
                !this.#info.fragmented ||
                (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)
              ) {
                const fullMessage = Buffer.concat(this.#fragments);

                websocketMessageReceived(
                  this.ws,
                  this.#info.originalOpcode,
                  fullMessage
                );

                this.#info = {};
                this.#fragments.length = 0;
              }

              this.#state = parserStates.INFO;
            }
          }

          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }

      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }

        if (this.#buffers[0].length === n) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }

        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;

        while (offset !== n) {
          const next = this.#buffers[0];
          const { length } = next;

          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            this.#buffers[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }

        this.#byteOffset -= n;

        return buffer;
      }

      parseCloseBody(onlyCode, data) {
        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5
        /** @type {number|undefined} */
        let code;

        if (data.length >= 2) {
          // _The WebSocket Connection Close Code_ is
          // defined as the status code (Section 7.4) contained in the first Close
          // control frame received by the application
          code = data.readUInt16BE(0);
        }

        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }

          return { code };
        }

        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6
        /** @type {Buffer} */
        let reason = data.subarray(2);

        // Remove BOM
        if (reason[0] === 0xef && reason[1] === 0xbb && reason[2] === 0xbf) {
          reason = reason.subarray(3);
        }

        if (code !== undefined && !isValidStatusCode(code)) {
          return null;
        }

        try {
          // TODO: optimize this
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }

        return { code, reason };
      }

      get closingInfo() {
        return this.#info.closeInfo;
      }
    }

    module.exports = {
      ByteParser,
    };

    /***/
  },

  /***/ 7578: /***/ (module) => {
    module.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser"),
    };

    /***/
  },

  /***/ 5515: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } =
      __nccwpck_require__(7578);
    const { states, opcodes } = __nccwpck_require__(9188);
    const { MessageEvent, ErrorEvent } = __nccwpck_require__(2611);

    /* globals Blob */

    /**
     * @param {import('./websocket').WebSocket} ws
     */
    function isEstablished(ws) {
      // If the server's response is validated as provided for above, it is
      // said that _The WebSocket Connection is Established_ and that the
      // WebSocket Connection is in the OPEN state.
      return ws[kReadyState] === states.OPEN;
    }

    /**
     * @param {import('./websocket').WebSocket} ws
     */
    function isClosing(ws) {
      // Upon either sending or receiving a Close control frame, it is said
      // that _The WebSocket Closing Handshake is Started_ and that the
      // WebSocket connection is in the CLOSING state.
      return ws[kReadyState] === states.CLOSING;
    }

    /**
     * @param {import('./websocket').WebSocket} ws
     */
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }

    /**
     * @see https://dom.spec.whatwg.org/#concept-event-fire
     * @param {string} e
     * @param {EventTarget} target
     * @param {EventInit | undefined} eventInitDict
     */
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      // 1. If eventConstructor is not given, then let eventConstructor be Event.

      // 2. Let event be the result of creating an event given eventConstructor,
      //    in the relevant realm of target.
      // 3. Initialize event’s type attribute to e.
      const event = new eventConstructor(e, eventInitDict); // eslint-disable-line new-cap

      // 4. Initialize any other IDL attributes of event as described in the
      //    invocation of this algorithm.

      // 5. Return the result of dispatching event at target, with legacy target
      //    override flag set if set.
      target.dispatchEvent(event);
    }

    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     * @param {import('./websocket').WebSocket} ws
     * @param {number} type Opcode
     * @param {Buffer} data application data
     */
    function websocketMessageReceived(ws, type, data) {
      // 1. If ready state is not OPEN (1), then return.
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }

      // 2. Let dataForEvent be determined by switching on type and binary type:
      let dataForEvent;

      if (type === opcodes.TEXT) {
        // -> type indicates that the data is Text
        //      a new DOMString containing data
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          // -> type indicates that the data is Binary and binary type is "blob"
          //      a new Blob object, created in the relevant Realm of the WebSocket
          //      object, that represents data as its raw data
          dataForEvent = new Blob([data]);
        } else {
          // -> type indicates that the data is Binary and binary type is "arraybuffer"
          //      a new ArrayBuffer object, created in the relevant Realm of the
          //      WebSocket object, whose contents are data
          dataForEvent = new Uint8Array(data).buffer;
        }
      }

      // 3. Fire an event named message at the WebSocket object, using MessageEvent,
      //    with the origin attribute initialized to the serialization of the WebSocket
      //    object’s url's origin, and the data attribute initialized to dataForEvent.
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent,
      });
    }

    /**
     * @see https://datatracker.ietf.org/doc/html/rfc6455
     * @see https://datatracker.ietf.org/doc/html/rfc2616
     * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
     * @param {string} protocol
     */
    function isValidSubprotocol(protocol) {
      // If present, this value indicates one
      // or more comma-separated subprotocol the client wishes to speak,
      // ordered by preference.  The elements that comprise this value
      // MUST be non-empty strings with characters in the range U+0021 to
      // U+007E not including separator characters as defined in
      // [RFC2616] and MUST all be unique strings.
      if (protocol.length === 0) {
        return false;
      }

      for (const char of protocol) {
        const code = char.charCodeAt(0);

        if (
          code < 0x21 ||
          code > 0x7e ||
          char === "(" ||
          char === ")" ||
          char === "<" ||
          char === ">" ||
          char === "@" ||
          char === "," ||
          char === ";" ||
          char === ":" ||
          char === "\\" ||
          char === '"' ||
          char === "/" ||
          char === "[" ||
          char === "]" ||
          char === "?" ||
          char === "=" ||
          char === "{" ||
          char === "}" ||
          code === 32 || // SP
          code === 9 // HT
        ) {
          return false;
        }
      }

      return true;
    }

    /**
     * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
     * @param {number} code
     */
    function isValidStatusCode(code) {
      if (code >= 1000 && code < 1015) {
        return (
          code !== 1004 && // reserved
          code !== 1005 && // "MUST NOT be set as a status code"
          code !== 1006 // "MUST NOT be set as a status code"
        );
      }

      return code >= 3000 && code <= 4999;
    }

    /**
     * @param {import('./websocket').WebSocket} ws
     * @param {string|undefined} reason
     */
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;

      controller.abort();

      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }

      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason),
        });
      }
    }

    module.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived,
    };

    /***/
  },

  /***/ 4284: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const { webidl } = __nccwpck_require__(1744);
    const { DOMException } = __nccwpck_require__(1037);
    const { URLSerializer } = __nccwpck_require__(685);
    const { getGlobalOrigin } = __nccwpck_require__(1246);
    const { staticPropertyDescriptors, states, opcodes, emptyBuffer } =
      __nccwpck_require__(9188);
    const {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser,
    } = __nccwpck_require__(7578);
    const {
      isEstablished,
      isClosing,
      isValidSubprotocol,
      failWebsocketConnection,
      fireEvent,
    } = __nccwpck_require__(5515);
    const { establishWebSocketConnection } = __nccwpck_require__(5354);
    const { WebsocketFrameSend } = __nccwpck_require__(5444);
    const { ByteParser } = __nccwpck_require__(1688);
    const { kEnumerableProperty, isBlobLike } = __nccwpck_require__(3983);
    const { getGlobalDispatcher } = __nccwpck_require__(1892);
    const { types } = __nccwpck_require__(3837);

    let experimentalWarned = false;

    // https://websockets.spec.whatwg.org/#interface-definition
    class WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null,
      };

      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";

      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();

        webidl.argumentLengthCheck(arguments, 1, {
          header: "WebSocket constructor",
        });

        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning(
            "WebSockets are experimental, expect them to change at any time.",
            {
              code: "UNDICI-WS",
            }
          );
        }

        const options =
          webidl.converters[
            "DOMString or sequence<DOMString> or WebSocketInit"
          ](protocols);

        url = webidl.converters.USVString(url);
        protocols = options.protocols;

        // 1. Let baseURL be this's relevant settings object's API base URL.
        const baseURL = getGlobalOrigin();

        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.
        let urlRecord;

        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          // 3. If urlRecord is failure, then throw a "SyntaxError" DOMException.
          throw new DOMException(e, "SyntaxError");
        }

        // 4. If urlRecord’s scheme is "http", then set urlRecord’s scheme to "ws".
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          // 5. Otherwise, if urlRecord’s scheme is "https", set urlRecord’s scheme to "wss".
          urlRecord.protocol = "wss:";
        }

        // 6. If urlRecord’s scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }

        // 7. If urlRecord’s fragment is non-null, then throw a "SyntaxError"
        //    DOMException.
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException("Got fragment", "SyntaxError");
        }

        // 8. If protocols is a string, set protocols to a sequence consisting
        //    of just that string.
        if (typeof protocols === "string") {
          protocols = [protocols];
        }

        // 9. If any of the values in protocols occur more than once or otherwise
        //    fail to match the requirements for elements that comprise the value
        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket
        //    protocol, then throw a "SyntaxError" DOMException.
        if (
          protocols.length !==
          new Set(protocols.map((p) => p.toLowerCase())).size
        ) {
          throw new DOMException(
            "Invalid Sec-WebSocket-Protocol value",
            "SyntaxError"
          );
        }

        if (
          protocols.length > 0 &&
          !protocols.every((p) => isValidSubprotocol(p))
        ) {
          throw new DOMException(
            "Invalid Sec-WebSocket-Protocol value",
            "SyntaxError"
          );
        }

        // 10. Set this's url to urlRecord.
        this[kWebSocketURL] = new URL(urlRecord.href);

        // 11. Let client be this's relevant settings object.

        // 12. Run this step in parallel:

        //    1. Establish a WebSocket connection given urlRecord, protocols,
        //       and client.
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        );

        // Each WebSocket object has an associated ready state, which is a
        // number representing the state of the connection. Initially it must
        // be CONNECTING (0).
        this[kReadyState] = WebSocket.CONNECTING;

        // The extensions attribute must initially return the empty string.

        // The protocol attribute must initially return the empty string.

        // Each WebSocket object has an associated binary type, which is a
        // BinaryType. Initially it must be "blob".
        this[kBinaryType] = "blob";
      }

      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = undefined, reason = undefined) {
        webidl.brandCheck(this, WebSocket);

        if (code !== undefined) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }

        if (reason !== undefined) {
          reason = webidl.converters.USVString(reason);
        }

        // 1. If code is present, but is neither an integer equal to 1000 nor an
        //    integer in the range 3000 to 4999, inclusive, throw an
        //    "InvalidAccessError" DOMException.
        if (code !== undefined) {
          if (code !== 1000 && (code < 3000 || code > 4999)) {
            throw new DOMException("invalid code", "InvalidAccessError");
          }
        }

        let reasonByteLength = 0;

        // 2. If reason is present, then run these substeps:
        if (reason !== undefined) {
          // 1. Let reasonBytes be the result of encoding reason.
          // 2. If reasonBytes is longer than 123 bytes, then throw a
          //    "SyntaxError" DOMException.
          reasonByteLength = Buffer.byteLength(reason);

          if (reasonByteLength > 123) {
            throw new DOMException(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }

        // 3. Run the first matching steps from the following list:
        if (
          this[kReadyState] === WebSocket.CLOSING ||
          this[kReadyState] === WebSocket.CLOSED
        ) {
          // If this's ready state is CLOSING (2) or CLOSED (3)
          // Do nothing.
        } else if (!isEstablished(this)) {
          // If the WebSocket connection is not yet established
          // Fail the WebSocket connection and set this's ready state
          // to CLOSING (2).
          failWebsocketConnection(
            this,
            "Connection was closed before it was established."
          );
          this[kReadyState] = WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          // If the WebSocket closing handshake has not yet been started
          // Start the WebSocket closing handshake and set this's ready
          // state to CLOSING (2).
          // - If neither code nor reason is present, the WebSocket Close
          //   message must not have a body.
          // - If code is present, then the status code to use in the
          //   WebSocket Close message must be the integer given by code.
          // - If reason is also present, then reasonBytes must be
          //   provided in the Close message after the status code.

          const frame = new WebsocketFrameSend();

          // If neither code nor reason is present, the WebSocket Close
          // message must not have a body.

          // If code is present, then the status code to use in the
          // WebSocket Close message must be the integer given by code.
          if (code !== undefined && reason === undefined) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== undefined && reason !== undefined) {
            // If reason is also present, then reasonBytes must be
            // provided in the Close message after the status code.
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            // the body MAY contain UTF-8-encoded data with value /reason/
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }

          /** @type {import('stream').Duplex} */
          const socket = this[kResponse].socket;

          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });

          // Upon either sending or receiving a Close control frame, it is said
          // that _The WebSocket Closing Handshake is Started_ and that the
          // WebSocket connection is in the CLOSING state.
          this[kReadyState] = states.CLOSING;
        } else {
          // Otherwise
          // Set this's ready state to CLOSING (2).
          this[kReadyState] = WebSocket.CLOSING;
        }
      }

      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, WebSocket);

        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });

        data = webidl.converters.WebSocketSendData(data);

        // 1. If this's ready state is CONNECTING, then throw an
        //    "InvalidStateError" DOMException.
        if (this[kReadyState] === WebSocket.CONNECTING) {
          throw new DOMException("Sent before connected.", "InvalidStateError");
        }

        // 2. Run the appropriate set of steps from the following list:
        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1
        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2

        if (!isEstablished(this) || isClosing(this)) {
          return;
        }

        /** @type {import('stream').Duplex} */
        const socket = this[kResponse].socket;

        // If data is a string
        if (typeof data === "string") {
          // If the WebSocket connection is established and the WebSocket
          // closing handshake has not yet started, then the user agent
          // must send a WebSocket Message comprised of the data argument
          // using a text frame opcode; if the data cannot be sent, e.g.
          // because it would need to be buffered but the buffer is full,
          // the user agent must flag the WebSocket as full and then close
          // the WebSocket connection. Any invocation of this method with a
          // string argument that does not throw an exception must increase
          // the bufferedAmount attribute by the number of bytes needed to
          // express the argument as UTF-8.

          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);

          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          // If the WebSocket connection is established, and the WebSocket
          // closing handshake has not yet started, then the user agent must
          // send a WebSocket Message comprised of data using a binary frame
          // opcode; if the data cannot be sent, e.g. because it would need
          // to be buffered but the buffer is full, the user agent must flag
          // the WebSocket as full and then close the WebSocket connection.
          // The data to be sent is the data stored in the buffer described
          // by the ArrayBuffer object. Any invocation of this method with an
          // ArrayBuffer argument that does not throw an exception must
          // increase the bufferedAmount attribute by the length of the
          // ArrayBuffer in bytes.

          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);

          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          // If the WebSocket connection is established, and the WebSocket
          // closing handshake has not yet started, then the user agent must
          // send a WebSocket Message comprised of data using a binary frame
          // opcode; if the data cannot be sent, e.g. because it would need to
          // be buffered but the buffer is full, the user agent must flag the
          // WebSocket as full and then close the WebSocket connection. The
          // data to be sent is the data stored in the section of the buffer
          // described by the ArrayBuffer object that data references. Any
          // invocation of this method with this kind of argument that does
          // not throw an exception must increase the bufferedAmount attribute
          // by the length of data’s buffer in bytes.

          const ab = Buffer.from(data, data.byteOffset, data.byteLength);

          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);

          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          // If the WebSocket connection is established, and the WebSocket
          // closing handshake has not yet started, then the user agent must
          // send a WebSocket Message comprised of data using a binary frame
          // opcode; if the data cannot be sent, e.g. because it would need to
          // be buffered but the buffer is full, the user agent must flag the
          // WebSocket as full and then close the WebSocket connection. The data
          // to be sent is the raw data represented by the Blob object. Any
          // invocation of this method with a Blob argument that does not throw
          // an exception must increase the bufferedAmount attribute by the size
          // of the Blob object’s raw data, in bytes.

          const frame = new WebsocketFrameSend();

          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);

            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }

      get readyState() {
        webidl.brandCheck(this, WebSocket);

        // The readyState getter steps are to return this's ready state.
        return this[kReadyState];
      }

      get bufferedAmount() {
        webidl.brandCheck(this, WebSocket);

        return this.#bufferedAmount;
      }

      get url() {
        webidl.brandCheck(this, WebSocket);

        // The url getter steps are to return this's url, serialized.
        return URLSerializer(this[kWebSocketURL]);
      }

      get extensions() {
        webidl.brandCheck(this, WebSocket);

        return this.#extensions;
      }

      get protocol() {
        webidl.brandCheck(this, WebSocket);

        return this.#protocol;
      }

      get onopen() {
        webidl.brandCheck(this, WebSocket);

        return this.#events.open;
      }

      set onopen(fn) {
        webidl.brandCheck(this, WebSocket);

        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }

        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }

      get onerror() {
        webidl.brandCheck(this, WebSocket);

        return this.#events.error;
      }

      set onerror(fn) {
        webidl.brandCheck(this, WebSocket);

        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }

        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }

      get onclose() {
        webidl.brandCheck(this, WebSocket);

        return this.#events.close;
      }

      set onclose(fn) {
        webidl.brandCheck(this, WebSocket);

        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }

        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }

      get onmessage() {
        webidl.brandCheck(this, WebSocket);

        return this.#events.message;
      }

      set onmessage(fn) {
        webidl.brandCheck(this, WebSocket);

        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }

        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }

      get binaryType() {
        webidl.brandCheck(this, WebSocket);

        return this[kBinaryType];
      }

      set binaryType(type) {
        webidl.brandCheck(this, WebSocket);

        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }

      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        // processResponse is called when the "response’s header list has been received and initialized."
        // once this happens, the connection is open
        this[kResponse] = response;

        const parser = new ByteParser(this);
        parser.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });

        response.socket.ws = this;
        this[kByteParser] = parser;

        // 1. Change the ready state to OPEN (1).
        this[kReadyState] = states.OPEN;

        // 2. Change the extensions attribute’s value to the extensions in use, if
        //    it is not the null value.
        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1
        const extensions = response.headersList.get("sec-websocket-extensions");

        if (extensions !== null) {
          this.#extensions = extensions;
        }

        // 3. Change the protocol attribute’s value to the subprotocol in use, if
        //    it is not the null value.
        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
        const protocol = response.headersList.get("sec-websocket-protocol");

        if (protocol !== null) {
          this.#protocol = protocol;
        }

        // 4. Fire an event named open at the WebSocket object.
        fireEvent("open", this);
      }
    }

    // https://websockets.spec.whatwg.org/#dom-websocket-connecting
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    // https://websockets.spec.whatwg.org/#dom-websocket-open
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    // https://websockets.spec.whatwg.org/#dom-websocket-closing
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    // https://websockets.spec.whatwg.org/#dom-websocket-closed
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;

    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true,
      },
    });

    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
    });

    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );

    webidl.converters["DOMString or sequence<DOMString>"] = function (V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }

      return webidl.converters.DOMString(V);
    };

    // This implements the propsal made in https://github.com/whatwg/websockets/issues/42
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        },
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        },
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit),
      },
    ]);

    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] =
      function (V) {
        if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
          return webidl.converters.WebSocketInit(V);
        }

        return {
          protocols: webidl.converters["DOMString or sequence<DOMString>"](V),
        };
      };

    webidl.converters.WebSocketSendData = function (V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }

        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }

      return webidl.converters.USVString(V);
    };

    module.exports = {
      WebSocket,
    };

    /***/
  },

  /***/ 9046: /***/ (__unused_webpack_module, exports) => {
    exports.fromCallback = function (fn) {
      return Object.defineProperty(
        function (...args) {
          if (typeof args[args.length - 1] === "function") fn.apply(this, args);
          else {
            return new Promise((resolve, reject) => {
              args.push((err, res) =>
                err != null ? reject(err) : resolve(res)
              );
              fn.apply(this, args);
            });
          }
        },
        "name",
        { value: fn.name }
      );
    };

    exports.fromPromise = function (fn) {
      return Object.defineProperty(
        function (...args) {
          const cb = args[args.length - 1];
          if (typeof cb !== "function") return fn.apply(this, args);
          else {
            args.pop();
            fn.apply(this, args).then((r) => cb(null, r), cb);
          }
        },
        "name",
        { value: fn.name }
      );
    };

    /***/
  },

  /***/ 5840: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function () {
        return _v.default;
      },
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function () {
        return _v2.default;
      },
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function () {
        return _v3.default;
      },
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function () {
        return _v4.default;
      },
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function () {
        return _nil.default;
      },
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function () {
        return _version.default;
      },
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function () {
        return _validate.default;
      },
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function () {
        return _stringify.default;
      },
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function () {
        return _parse.default;
      },
    });

    var _v = _interopRequireDefault(__nccwpck_require__(8628));

    var _v2 = _interopRequireDefault(__nccwpck_require__(6409));

    var _v3 = _interopRequireDefault(__nccwpck_require__(5122));

    var _v4 = _interopRequireDefault(__nccwpck_require__(9120));

    var _nil = _interopRequireDefault(__nccwpck_require__(5332));

    var _version = _interopRequireDefault(__nccwpck_require__(1595));

    var _validate = _interopRequireDefault(__nccwpck_require__(6900));

    var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

    var _parse = _interopRequireDefault(__nccwpck_require__(2746));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    /***/
  },

  /***/ 4569: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }

      return _crypto.default.createHash("md5").update(bytes).digest();
    }

    var _default = md5;
    exports["default"] = _default;

    /***/
  },

  /***/ 5332: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports["default"] = _default;

    /***/
  },

  /***/ 2746: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _validate = _interopRequireDefault(__nccwpck_require__(6900));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }

      let v;
      const arr = new Uint8Array(16); // Parse ########-....-....-....-............

      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = (v >>> 16) & 0xff;
      arr[2] = (v >>> 8) & 0xff;
      arr[3] = v & 0xff; // Parse ........-####-....-....-............

      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 0xff; // Parse ........-....-####-....-............

      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 0xff; // Parse ........-....-....-####-............

      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 0xff; // Parse ........-....-....-....-############
      // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

      arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;
      arr[11] = (v / 0x100000000) & 0xff;
      arr[12] = (v >>> 24) & 0xff;
      arr[13] = (v >>> 16) & 0xff;
      arr[14] = (v >>> 8) & 0xff;
      arr[15] = v & 0xff;
      return arr;
    }

    var _default = parse;
    exports["default"] = _default;

    /***/
  },

  /***/ 814: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;
    var _default =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports["default"] = _default;

    /***/
  },

  /***/ 807: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = rng;

    var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

    let poolPtr = rnds8Pool.length;

    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);

        poolPtr = 0;
      }

      return rnds8Pool.slice(poolPtr, (poolPtr += 16));
    }

    /***/
  },

  /***/ 5274: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }

      return _crypto.default.createHash("sha1").update(bytes).digest();
    }

    var _default = sha1;
    exports["default"] = _default;

    /***/
  },

  /***/ 8950: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _validate = _interopRequireDefault(__nccwpck_require__(6900));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      const uuid = (
        byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        "-" +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        "-" +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        "-" +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        "-" +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]
      ).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }

      return uuid;
    }

    var _default = stringify;
    exports["default"] = _default;

    /***/
  },

  /***/ 8628: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _rng = _interopRequireDefault(__nccwpck_require__(807));

    var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html
    let _nodeId;

    let _clockseq; // Previous uuid creation time

    let _lastMSecs = 0;
    let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

    function v1(options, buf, offset) {
      let i = (buf && offset) || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq =
        options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189

      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();

        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [
            seedBytes[0] | 0x01,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5],
          ];
        }

        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

      let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock

      let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

      if (dt < 0 && options.clockseq === undefined) {
        clockseq = (clockseq + 1) & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval

      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested

      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

      msecs += 12219292800000; // `time_low`

      const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = (tl >>> 24) & 0xff;
      b[i++] = (tl >>> 16) & 0xff;
      b[i++] = (tl >>> 8) & 0xff;
      b[i++] = tl & 0xff; // `time_mid`

      const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
      b[i++] = (tmh >>> 8) & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`

      b[i++] = ((tmh >>> 24) & 0xf) | 0x10; // include version

      b[i++] = (tmh >>> 16) & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

      b[i++] = (clockseq >>> 8) | 0x80; // `clock_seq_low`

      b[i++] = clockseq & 0xff; // `node`

      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf || (0, _stringify.default)(b);
    }

    var _default = v1;
    exports["default"] = _default;

    /***/
  },

  /***/ 6409: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _v = _interopRequireDefault(__nccwpck_require__(5998));

    var _md = _interopRequireDefault(__nccwpck_require__(4569));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    const v3 = (0, _v.default)("v3", 0x30, _md.default);
    var _default = v3;
    exports["default"] = _default;

    /***/
  },

  /***/ 5998: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = _default;
    exports.URL = exports.DNS = void 0;

    var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

    var _parse = _interopRequireDefault(__nccwpck_require__(2746));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str)); // UTF8 escape

      const bytes = [];

      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }

      return bytes;
    }

    const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL;

    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }

        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }

        if (namespace.length !== 16) {
          throw TypeError(
            "Namespace must be array-like (16 iterable integer values, 0-255)"
          );
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`

        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = (bytes[6] & 0x0f) | version;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;

        if (buf) {
          offset = offset || 0;

          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }

          return buf;
        }

        return (0, _stringify.default)(bytes);
      } // Function#name is not settable on some platforms (#270)

      try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
      } catch (err) {} // For CommonJS default export support

      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }

    /***/
  },

  /***/ 5122: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _rng = _interopRequireDefault(__nccwpck_require__(807));

    var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function v4(options, buf, offset) {
      options = options || {};

      const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return (0, _stringify.default)(rnds);
    }

    var _default = v4;
    exports["default"] = _default;

    /***/
  },

  /***/ 9120: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _v = _interopRequireDefault(__nccwpck_require__(5998));

    var _sha = _interopRequireDefault(__nccwpck_require__(5274));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    const v5 = (0, _v.default)("v5", 0x50, _sha.default);
    var _default = v5;
    exports["default"] = _default;

    /***/
  },

  /***/ 6900: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _regex = _interopRequireDefault(__nccwpck_require__(814));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }

    var _default = validate;
    exports["default"] = _default;

    /***/
  },

  /***/ 1595: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    exports["default"] = void 0;

    var _validate = _interopRequireDefault(__nccwpck_require__(6900));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }

      return parseInt(uuid.substr(14, 1), 16);
    }

    var _default = version;
    exports["default"] = _default;

    /***/
  },

  /***/ 1452: /***/ function (__unused_webpack_module, exports) {
    /**
     * @license
     * web-streams-polyfill v3.3.3
     * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
     * This code is released under the MIT license.
     * SPDX-License-Identifier: MIT
     */
    (function (global, factory) {
      true ? factory(exports) : 0;
    })(this, function (exports) {
      "use strict";

      function noop() {
        return undefined;
      }

      function typeIsObject(x) {
        return (typeof x === "object" && x !== null) || typeof x === "function";
      }
      const rethrowAssertionErrorRejection = noop;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true,
          });
        } catch (_a) {
          // This property is non-configurable in older browsers, so ignore if this throws.
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
        }
      }

      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      // https://webidl.spec.whatwg.org/#a-new-promise
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      // https://webidl.spec.whatwg.org/#a-promise-resolved-with
      function promiseResolvedWith(value) {
        return newPromise((resolve) => resolve(value));
      }
      // https://webidl.spec.whatwg.org/#a-promise-rejected-with
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
        // approximation.
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      // Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned
      // from that handler. To prevent this, return null instead of void from all handlers.
      // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(
          PerformPromiseThen(promise, onFulfilled, onRejected),
          undefined,
          rethrowAssertionErrorRejection
        );
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, undefined, onRejected);
      }
      function transformPromiseWith(
        promise,
        fulfillmentHandler,
        rejectionHandler
      ) {
        return PerformPromiseThen(
          promise,
          fulfillmentHandler,
          rejectionHandler
        );
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
      }
      let _queueMicrotask = (callback) => {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          const resolvedPromise = promiseResolvedWith(undefined);
          _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }

      // Original from Chromium
      // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      /**
       * Simple queue structure.
       *
       * Avoids scalability issues with using a packed array directly by using
       * multiple arrays in a linked list and keeping the array size bounded.
       */
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          // _front and _back are always defined.
          this._front = {
            _elements: [],
            _next: undefined,
          };
          this._back = this._front;
          // The cursor is used to avoid calling Array.shift().
          // It contains the index of the front element of the array inside the
          // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
          this._cursor = 0;
          // When there is only one node, size === elements.length - cursor.
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: undefined,
            };
          }
          // push() is the mutation most likely to throw an exception, so it
          // goes first.
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          // must not be called on an empty queue
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          // No mutations before this point.
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          // Permit shifted element to be garbage collected.
          elements[oldCursor] = undefined;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i !== elements.length || node._next !== undefined) {
            if (i === elements.length) {
              node = node._next;
              elements = node._elements;
              i = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i]);
            ++i;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          // must not be called on an empty queue
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }

      const AbortSteps = Symbol("[[AbortSteps]]");
      const ErrorSteps = Symbol("[[ErrorSteps]]");
      const CancelSteps = Symbol("[[CancelSteps]]");
      const PullSteps = Symbol("[[PullSteps]]");
      const ReleaseSteps = Symbol("[[ReleaseSteps]]");

      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(
            reader,
            stream._storedError
          );
        }
      }
      // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
      // check.
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(
            reader,
            new TypeError(
              `Reader was released and can no longer be used to monitor the stream's closedness`
            )
          );
        } else {
          defaultReaderClosedPromiseResetToRejected(
            reader,
            new TypeError(
              `Reader was released and can no longer be used to monitor the stream's closedness`
            )
          );
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = undefined;
        reader._ownerReadableStream = undefined;
      }
      // Helper functions for the readers.
      function readerLockException(name) {
        return new TypeError(
          "Cannot " + name + " a stream using a released reader"
        );
      }
      // Helper functions for the ReadableStreamDefaultReader.
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === undefined) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === undefined) {
          return;
        }
        reader._closedPromise_resolve(undefined);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
      }

      /// <reference lib="es2015.core" />
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
      const NumberIsFinite =
        Number.isFinite ||
        function (x) {
          return typeof x === "number" && isFinite(x);
        };

      /// <reference lib="es2015.core" />
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
      const MathTrunc =
        Math.trunc ||
        function (v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };

      // https://heycam.github.io/webidl/#idl-dictionaries
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== undefined && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      // https://heycam.github.io/webidl/#idl-callback-functions
      function assertFunction(x, context) {
        if (typeof x !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      // https://heycam.github.io/webidl/#idl-object
      function isObject(x) {
        return (typeof x === "object" && x !== null) || typeof x === "function";
      }
      function assertObject(x, context) {
        if (!isObject(x)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x, position, context) {
        if (x === undefined) {
          throw new TypeError(
            `Parameter ${position} is required in '${context}'.`
          );
        }
      }
      function assertRequiredField(x, field, context) {
        if (x === undefined) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      // https://heycam.github.io/webidl/#idl-unrestricted-double
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      // https://heycam.github.io/webidl/#idl-unsigned-long-long
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError(
            `${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`
          );
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        // TODO Use BigInt if supported?
        // let xBigInt = BigInt(integerPart(x));
        // xBigInt = BigInt.asUintN(64, xBigInt);
        // return Number(xBigInt);
        return x;
      }

      function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }

      // Abstract operations for the ReadableStream.
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      // ReadableStream API exposed for controllers.
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      /**
       * A default reader vended by a {@link ReadableStream}.
       *
       * @public
       */
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError(
              "This stream has already been locked for exclusive reading by another reader"
            );
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(
              defaultReaderBrandCheckException("closed")
            );
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(
              defaultReaderBrandCheckException("cancel")
            );
          }
          if (this._ownerReadableStream === undefined) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(
              defaultReaderBrandCheckException("read")
            );
          }
          if (this._ownerReadableStream === undefined) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) =>
              resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: undefined, done: true }),
            _errorSteps: (e) => rejectPromise(e),
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === undefined) {
            return;
          }
          ReadableStreamDefaultReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true },
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(
        ReadableStreamDefaultReader.prototype.releaseLock,
        "releaseLock"
      );
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          ReadableStreamDefaultReader.prototype,
          Symbol.toStringTag,
          {
            value: "ReadableStreamDefaultReader",
            configurable: true,
          }
        );
      }
      // Abstract operations for the readers.
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e);
        });
      }
      // Helper functions for the ReadableStreamDefaultReader.
      function defaultReaderBrandCheckException(name) {
        return new TypeError(
          `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`
        );
      }

      /// <reference lib="es2018.asynciterable" />
      /* eslint-disable @typescript-eslint/no-empty-function */
      const AsyncIteratorPrototype = Object.getPrototypeOf(
        Object.getPrototypeOf(async function* () {}).prototype
      );

      /// <reference lib="es2018.asynciterable" />
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = undefined;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise
            ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps)
            : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise
            ? transformPromiseWith(
                this._ongoingPromise,
                returnSteps,
                returnSteps
              )
            : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: undefined, done: true });
          }
          const reader = this._reader;
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = undefined;
              // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
              // FIXME Is this a bug in the specification, or in the test?
              _queueMicrotask(() =>
                resolvePromise({ value: chunk, done: false })
              );
            },
            _closeSteps: () => {
              this._ongoingPromise = undefined;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: undefined, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = undefined;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            },
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(
              streamAsyncIteratorBrandCheckException("next")
            );
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(
              streamAsyncIteratorBrandCheckException("return")
            );
          }
          return this._asyncIteratorImpl.return(value);
        },
      };
      Object.setPrototypeOf(
        ReadableStreamAsyncIteratorPrototype,
        AsyncIteratorPrototype
      );
      // Abstract operations for the ReadableStream.
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          // noinspection SuspiciousTypeOfGuard
          return (
            x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl
          );
        } catch (_a) {
          return false;
        }
      }
      // Helper functions for the ReadableStream.
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(
          `ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`
        );
      }

      /// <reference lib="es2015.core" />
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
      const NumberIsNaN =
        Number.isNaN ||
        function (x) {
          // eslint-disable-next-line no-self-compare
          return x !== x;
        };

      var _a, _b, _c;
      function CreateArrayFromList(elements) {
        // We use arrays to represent lists, so this is basically a no-op.
        // Do a slice though just in case we happen to depend on the unique-ness.
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = (buffer) => buffer.transfer();
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = (buffer) =>
            structuredClone(buffer, { transfer: [buffer] });
        } else {
          // Not implemented correctly
          TransferArrayBuffer = (buffer) => buffer;
        }
        return TransferArrayBuffer(O);
      };
      let IsDetachedBuffer = (O) => {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = (buffer) => buffer.detached;
        } else {
          // Not implemented correctly
          IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer, begin, end) {
        // ArrayBuffer.prototype.slice is not available on IE10
        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === undefined || func === null) {
          return undefined;
        }
        if (typeof func !== "function") {
          throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,
        // we use yield* inside an async generator function to achieve the same result.
        // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.
        const syncIterable = {
          [Symbol.iterator]: () => syncIteratorRecord.iterator,
        };
        // Create an async generator function and immediately invoke it.
        const asyncIterator = (async function* () {
          return yield* syncIterable;
        })();
        // Return as an async iterator record.
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      // Aligns with core-js/modules/es.symbol.async-iterator.js
      const SymbolAsyncIterator =
        (_c =
          (_a = Symbol.asyncIterator) !== null && _a !== void 0
            ? _a
            : (_b = Symbol.for) === null || _b === void 0
              ? void 0
              : _b.call(Symbol, "Symbol.asyncIterator")) !== null &&
        _c !== void 0
          ? _c
          : "@@asyncIterator";
      function GetIterator(obj, hint = "sync", method) {
        if (method === undefined) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === undefined) {
              const syncMethod = GetMethod(obj, Symbol.iterator);
              const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, Symbol.iterator);
          }
        }
        if (method === undefined) {
          throw new TypeError("The object is not iterable");
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        const result = reflectCall(
          iteratorRecord.nextMethod,
          iteratorRecord.iterator,
          []
        );
        if (!typeIsObject(result)) {
          throw new TypeError(
            "The iterator.next() method must return an object"
          );
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }

      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(
          O.buffer,
          O.byteOffset,
          O.byteOffset + O.byteLength
        );
        return new Uint8Array(buffer);
      }

      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError(
            "Size must be a finite, non-NaN, non-negative number."
          );
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }

      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }

      /**
       * A pull-into request in a {@link ReadableByteStreamController}.
       *
       * @public
       */
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(
            bytesWritten,
            "First parameter"
          );
          if (this._associatedReadableByteStreamController === undefined) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer)) {
            throw new TypeError(
              `The BYOB request's buffer has been detached and so cannot be used as a response`
            );
          }
          ReadableByteStreamControllerRespond(
            this._associatedReadableByteStreamController,
            bytesWritten
          );
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === undefined) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer)) {
            throw new TypeError(
              "The given view's buffer has been detached and so cannot be used as a response"
            );
          }
          ReadableByteStreamControllerRespondWithNewView(
            this._associatedReadableByteStreamController,
            view
          );
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true },
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(
        ReadableStreamBYOBRequest.prototype.respondWithNewView,
        "respondWithNewView"
      );
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          ReadableStreamBYOBRequest.prototype,
          Symbol.toStringTag,
          {
            value: "ReadableStreamBYOBRequest",
            configurable: true,
          }
        );
      }
      /**
       * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
       *
       * @public
       */
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError(
              "The stream has already been closed; do not close it again!"
            );
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(
              `The stream (in ${state} state) is not in the readable state and cannot be closed`
            );
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(
              `The stream (in ${state} state) is not in the readable state and cannot be enqueued to`
            );
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            ReadableByteStreamControllerFillReadRequestFromQueue(
              this,
              readRequest
            );
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== undefined) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              minimumFill: 1,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default",
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
          if (this._pendingPullIntos.length > 0) {
            const firstPullInto = this._pendingPullIntos.peek();
            firstPullInto.readerType = "none";
            this._pendingPullIntos = new SimpleQueue();
            this._pendingPullIntos.push(firstPullInto);
          }
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true },
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(
        ReadableByteStreamController.prototype.enqueue,
        "enqueue"
      );
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          ReadableByteStreamController.prototype,
          Symbol.toStringTag,
          {
            value: "ReadableByteStreamController",
            configurable: true,
          }
        );
      }
      // Abstract operations for the ReadableByteStreamController.
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(
            x,
            "_controlledReadableByteStream"
          )
        ) {
          return false;
        }
        return x instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(
            x,
            "_associatedReadableByteStreamController"
          )
        ) {
          return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull =
          ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        // TODO: Test controller argument
        const pullPromise = controller._pullAlgorithm();
        uponPromise(
          pullPromise,
          () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
            return null;
          },
          (e) => {
            ReadableByteStreamControllerError(controller, e);
            return null;
          }
        );
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(
        stream,
        pullIntoDescriptor
      ) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView =
          ReadableByteStreamControllerConvertPullIntoDescriptor(
            pullIntoDescriptor
          );
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(
        pullIntoDescriptor
      ) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(
          pullIntoDescriptor.buffer,
          pullIntoDescriptor.byteOffset,
          bytesFilled / elementSize
        );
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(
        controller,
        buffer,
        byteOffset,
        byteLength
      ) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(
        controller,
        buffer,
        byteOffset,
        byteLength
      ) {
        let clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(
            buffer,
            byteOffset,
            byteOffset + byteLength
          );
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(
          controller,
          clonedChunk,
          0,
          byteLength
        );
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(
        controller,
        firstDescriptor
      ) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(
            controller,
            firstDescriptor.buffer,
            firstDescriptor.byteOffset,
            firstDescriptor.bytesFilled
          );
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
        controller,
        pullIntoDescriptor
      ) {
        const maxBytesToCopy = Math.min(
          controller._queueTotalSize,
          pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled
        );
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head
        // of the queue, so the underlying source can keep filling it.
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining =
            maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(
            totalBytesToCopyRemaining,
            headOfQueue.byteLength
          );
          const destStart =
            pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(
            pullIntoDescriptor.buffer,
            destStart,
            headOfQueue.buffer,
            headOfQueue.byteOffset,
            bytesToCopy
          );
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(
            controller,
            bytesToCopy,
            pullIntoDescriptor
          );
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(
        controller,
        size,
        pullIntoDescriptor
      ) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController =
          undefined;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
        controller
      ) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (
            ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
              controller,
              pullIntoDescriptor
            )
          ) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(
              controller._controlledReadableByteStream,
              pullIntoDescriptor
            );
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(
        controller
      ) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(
            controller,
            readRequest
          );
        }
      }
      function ReadableByteStreamControllerPullInto(
        controller,
        view,
        min,
        readIntoRequest
      ) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
          buffer = TransferArrayBuffer(view.buffer);
        } catch (e) {
          readIntoRequest._errorSteps(e);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob",
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          // No ReadableByteStreamControllerCallPullIfNeeded() call since:
          // - No change happens on desiredSize
          // - The source has already been notified of that there's at least 1 pending read(view)
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(
            pullIntoDescriptor.buffer,
            pullIntoDescriptor.byteOffset,
            0
          );
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (
            ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
              controller,
              pullIntoDescriptor
            )
          ) {
            const filledView =
              ReadableByteStreamControllerConvertPullIntoDescriptor(
                pullIntoDescriptor
              );
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e = new TypeError(
              "Insufficient bytes to fill elements in the given buffer"
            );
            ReadableByteStreamControllerError(controller, e);
            readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(
        controller,
        firstDescriptor
      ) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor =
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(
              stream,
              pullIntoDescriptor
            );
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(
        controller,
        bytesWritten,
        pullIntoDescriptor
      ) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(
          controller,
          bytesWritten,
          pullIntoDescriptor
        );
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(
            controller,
            pullIntoDescriptor
          );
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
            controller
          );
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head
          // of the queue, so the underlying source can keep filling it.
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize =
          pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end =
            pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(
            controller,
            pullIntoDescriptor.buffer,
            end - remainderSize,
            remainderSize
          );
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(
          controller._controlledReadableByteStream,
          pullIntoDescriptor
        );
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
          controller
        );
      }
      function ReadableByteStreamControllerRespondInternal(
        controller,
        bytesWritten
      ) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(
            controller,
            firstDescriptor
          );
        } else {
          ReadableByteStreamControllerRespondInReadableState(
            controller,
            bytesWritten,
            firstDescriptor
          );
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (
          ReadableStreamHasDefaultReader(stream) &&
          ReadableStreamGetNumReadRequests(stream) > 0
        ) {
          return true;
        }
        if (
          ReadableStreamHasBYOBReader(stream) &&
          ReadableStreamGetNumReadIntoRequests(stream) > 0
        ) {
          return true;
        }
        const desiredSize =
          ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
      }
      // A client of ReadableByteStreamController may use these functions directly to bypass state check.
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (
            firstPendingPullInto.bytesFilled %
              firstPendingPullInto.elementSize !==
            0
          ) {
            const e = new TypeError(
              "Insufficient bytes to fill elements in the given buffer"
            );
            ReadableByteStreamControllerError(controller, e);
            throw e;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
          throw new TypeError(
            "chunk's buffer is detached and so cannot be enqueued"
          );
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError(
              "The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk"
            );
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(
            firstPendingPullInto.buffer
          );
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(
              controller,
              firstPendingPullInto
            );
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(
              controller,
              transferredBuffer,
              byteOffset,
              byteLength
            );
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(
              transferredBuffer,
              byteOffset,
              byteLength
            );
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
          ReadableByteStreamControllerEnqueueChunkToQueue(
            controller,
            transferredBuffer,
            byteOffset,
            byteLength
          );
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
            controller
          );
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(
            controller,
            transferredBuffer,
            byteOffset,
            byteLength
          );
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(
        controller,
        readRequest
      ) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(
          entry.buffer,
          entry.byteOffset,
          entry.byteLength
        );
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (
          controller._byobRequest === null &&
          controller._pendingPullIntos.length > 0
        ) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(
            firstDescriptor.buffer,
            firstDescriptor.byteOffset + firstDescriptor.bytesFilled,
            firstDescriptor.byteLength - firstDescriptor.bytesFilled
          );
          const byobRequest = Object.create(
            ReadableStreamBYOBRequest.prototype
          );
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError(
              "bytesWritten must be 0 when calling respond() on a closed stream"
            );
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError(
              "bytesWritten must be greater than 0 when calling respond() on a readable stream"
            );
          }
          if (
            firstDescriptor.bytesFilled + bytesWritten >
            firstDescriptor.byteLength
          ) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(
        controller,
        view
      ) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError(
              "The view's length must be 0 when calling respondWithNewView() on a closed stream"
            );
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError(
              "The view's length must be greater than 0 when calling respondWithNewView() on a readable stream"
            );
          }
        }
        if (
          firstDescriptor.byteOffset + firstDescriptor.bytesFilled !==
          view.byteOffset
        ) {
          throw new RangeError(
            "The region specified by view does not match byobRequest"
          );
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError(
            "The buffer of view has different capacity than byobRequest"
          );
        }
        if (
          firstDescriptor.bytesFilled + view.byteLength >
          firstDescriptor.byteLength
        ) {
          throw new RangeError(
            "The region specified by view is larger than byobRequest"
          );
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(
        stream,
        controller,
        startAlgorithm,
        pullAlgorithm,
        cancelAlgorithm,
        highWaterMark,
        autoAllocateChunkSize
      ) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(
          promiseResolvedWith(startResult),
          () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
            return null;
          },
          (r) => {
            ReadableByteStreamControllerError(controller, r);
            return null;
          }
        );
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(
        stream,
        underlyingByteSource,
        highWaterMark
      ) {
        const controller = Object.create(
          ReadableByteStreamController.prototype
        );
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== undefined) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        } else {
          startAlgorithm = () => undefined;
        }
        if (underlyingByteSource.pull !== undefined) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingByteSource.cancel !== undefined) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        const autoAllocateChunkSize =
          underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(
          stream,
          controller,
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          highWaterMark,
          autoAllocateChunkSize
        );
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      // Helper functions for the ReadableStreamBYOBRequest.
      function byobRequestBrandCheckException(name) {
        return new TypeError(
          `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`
        );
      }
      // Helper functions for the ReadableByteStreamController.
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(
          `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`
        );
      }

      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode =
          options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode:
            mode === undefined
              ? undefined
              : convertReadableStreamReaderMode(
                  mode,
                  `${context} has member 'mode' that`
                ),
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(
            `${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`
          );
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a;
        assertDictionary(options, context);
        const min =
          (_a =
            options === null || options === void 0 ? void 0 : options.min) !==
            null && _a !== void 0
            ? _a
            : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(
            min,
            `${context} has member 'min' that`
          ),
        };
      }

      // Abstract operations for the ReadableStream.
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      // ReadableStream API exposed for controllers.
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      /**
       * A BYOB reader vended by a {@link ReadableStream}.
       *
       * @public
       */
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError(
              "This stream has already been locked for exclusive reading by another reader"
            );
          }
          if (
            !IsReadableByteStreamController(stream._readableStreamController)
          ) {
            throw new TypeError(
              "Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte " +
                "source"
            );
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === undefined) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(
              new TypeError("view must be an array buffer view")
            );
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(
              new TypeError("view must have non-zero byteLength")
            );
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(
              new TypeError(`view's buffer must have non-zero byteLength`)
            );
          }
          if (IsDetachedBuffer(view.buffer)) {
            return promiseRejectedWith(
              new TypeError("view's buffer has been detached")
            );
          }
          let options;
          try {
            options = convertByobReadOptions(rawOptions, "options");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          const min = options.min;
          if (min === 0) {
            return promiseRejectedWith(
              new TypeError("options.min must be greater than 0")
            );
          }
          if (!isDataView(view)) {
            if (min > view.length) {
              return promiseRejectedWith(
                new RangeError(
                  "options.min must be less than or equal to view's length"
                )
              );
            }
          } else if (min > view.byteLength) {
            return promiseRejectedWith(
              new RangeError(
                "options.min must be less than or equal to view's byteLength"
              )
            );
          }
          if (this._ownerReadableStream === undefined) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) =>
              resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) =>
              resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e) => rejectPromise(e),
          };
          ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === undefined) {
            return;
          }
          ReadableStreamBYOBReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true },
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(
        ReadableStreamBYOBReader.prototype.releaseLock,
        "releaseLock"
      );
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          ReadableStreamBYOBReader.prototype,
          Symbol.toStringTag,
          {
            value: "ReadableStreamBYOBReader",
            configurable: true,
          }
        );
      }
      // Abstract operations for the readers.
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(
        reader,
        view,
        min,
        readIntoRequest
      ) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(
            stream._readableStreamController,
            view,
            min,
            readIntoRequest
          );
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e);
        });
      }
      // Helper functions for the ReadableStreamBYOBReader.
      function byobReaderBrandCheckException(name) {
        return new TypeError(
          `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`
        );
      }

      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === undefined) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }

      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark =
          init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark:
            highWaterMark === undefined
              ? undefined
              : convertUnrestrictedDouble(highWaterMark),
          size:
            size === undefined
              ? undefined
              : convertQueuingStrategySize(
                  size,
                  `${context} has member 'size' that`
                ),
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }

      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort =
          original === null || original === void 0 ? void 0 : original.abort;
        const close =
          original === null || original === void 0 ? void 0 : original.close;
        const start =
          original === null || original === void 0 ? void 0 : original.start;
        const type =
          original === null || original === void 0 ? void 0 : original.type;
        const write =
          original === null || original === void 0 ? void 0 : original.write;
        return {
          abort:
            abort === undefined
              ? undefined
              : convertUnderlyingSinkAbortCallback(
                  abort,
                  original,
                  `${context} has member 'abort' that`
                ),
          close:
            close === undefined
              ? undefined
              : convertUnderlyingSinkCloseCallback(
                  close,
                  original,
                  `${context} has member 'close' that`
                ),
          start:
            start === undefined
              ? undefined
              : convertUnderlyingSinkStartCallback(
                  start,
                  original,
                  `${context} has member 'start' that`
                ),
          write:
            write === undefined
              ? undefined
              : convertUnderlyingSinkWriteCallback(
                  write,
                  original,
                  `${context} has member 'write' that`
                ),
          type,
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) =>
          promiseCall(fn, original, [chunk, controller]);
      }

      function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }

      function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a) {
          // AbortSignal.prototype.aborted throws if its brand check fails
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      /**
       * Construct a new AbortController, if supported by the platform.
       *
       * @internal
       */
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return undefined;
      }

      /**
       * A writable stream represents a destination for data, into which you can write.
       *
       * @public
       */
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === undefined) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(
            rawStrategy,
            "Second parameter"
          );
          const underlyingSink = convertUnderlyingSink(
            rawUnderlyingSink,
            "First parameter"
          );
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== undefined) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(
            this,
            underlyingSink,
            highWaterMark,
            sizeAlgorithm
          );
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = undefined) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(
              new TypeError("Cannot abort a stream that already has a writer")
            );
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(
              new TypeError("Cannot close a stream that already has a writer")
            );
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(
              new TypeError("Cannot close an already-closing stream")
            );
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true },
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
          value: "WritableStream",
          configurable: true,
        });
      }
      // Abstract operations for the WritableStream.
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      // Throws if and only if startAlgorithm throws.
      function CreateWritableStream(
        startAlgorithm,
        writeAlgorithm,
        closeAlgorithm,
        abortAlgorithm,
        highWaterMark = 1,
        sizeAlgorithm = () => 1
      ) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(
          WritableStreamDefaultController.prototype
        );
        SetUpWritableStreamDefaultController(
          stream,
          controller,
          startAlgorithm,
          writeAlgorithm,
          closeAlgorithm,
          abortAlgorithm,
          highWaterMark,
          sizeAlgorithm
        );
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
        // 'erroring' or 'errored'. May be set to an undefined value.
        stream._storedError = undefined;
        stream._writer = undefined;
        // Initialize to undefined first because the constructor of the controller checks this
        // variable to validate the caller.
        stream._writableStreamController = undefined;
        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
        // producer without waiting for the queued writes to finish.
        stream._writeRequests = new SimpleQueue();
        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
        stream._inFlightWriteRequest = undefined;
        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
        // has been detached.
        stream._closeRequest = undefined;
        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
        stream._inFlightCloseRequest = undefined;
        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
        stream._pendingAbortRequest = undefined;
        // The backpressure signal set by the controller.
        stream._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(x, "_writableStreamController")
        ) {
          return false;
        }
        return x instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === undefined) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(undefined);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null ||
        _a === void 0
          ? void 0
          : _a.abort(reason);
        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
        // but it doesn't know that signaling abort runs author code that might have changed the state.
        // Widen the type again by casting to WritableStreamState.
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(undefined);
        }
        if (stream._pendingAbortRequest !== undefined) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          // reason will not be used, so don't keep a reference to it.
          reason = undefined;
        }
        const promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: undefined,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring,
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(
            new TypeError(
              `The stream (in ${state} state) is not in the writable state and cannot be closed`
            )
          );
        }
        const promise = newPromise((resolve, reject) => {
          const closeRequest = {
            _resolve: resolve,
            _reject: reject,
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (
          writer !== undefined &&
          stream._backpressure &&
          state === "writable"
        ) {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      // WritableStream API exposed for controllers.
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
          const writeRequest = {
            _resolve: resolve,
            _reject: reject,
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== undefined) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (
          !WritableStreamHasOperationMarkedInFlight(stream) &&
          controller._started
        ) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === undefined) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = undefined;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](
          abortRequest._reason
        );
        uponPromise(
          promise,
          () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return null;
          },
          (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return null;
          }
        );
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(undefined);
        stream._inFlightWriteRequest = undefined;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = undefined;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(undefined);
        stream._inFlightCloseRequest = undefined;
        const state = stream._state;
        if (state === "erroring") {
          // The error was too late to do anything, so it is ignored.
          stream._storedError = undefined;
          if (stream._pendingAbortRequest !== undefined) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = undefined;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== undefined) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = undefined;
        // Never execute sink abort() after sink close().
        if (stream._pendingAbortRequest !== undefined) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = undefined;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      // TODO(ricea): Fix alphabetical order.
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (
          stream._closeRequest === undefined &&
          stream._inFlightCloseRequest === undefined
        ) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (
          stream._inFlightWriteRequest === undefined &&
          stream._inFlightCloseRequest === undefined
        ) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = undefined;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== undefined) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = undefined;
        }
        const writer = stream._writer;
        if (writer !== undefined) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== undefined && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      /**
       * A default writer vended by a {@link WritableStream}.
       *
       * @public
       */
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError(
              "This stream has already been locked for exclusive writing by another writer"
            );
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (
              !WritableStreamCloseQueuedOrInFlight(stream) &&
              stream._backpressure
            ) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(
              this,
              stream._storedError
            );
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(
              defaultWriterBrandCheckException("closed")
            );
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === undefined) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(
              defaultWriterBrandCheckException("ready")
            );
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = undefined) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(
              defaultWriterBrandCheckException("abort")
            );
          }
          if (this._ownerWritableStream === undefined) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(
              defaultWriterBrandCheckException("close")
            );
          }
          const stream = this._ownerWritableStream;
          if (stream === undefined) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(
              new TypeError("Cannot close an already-closing stream")
            );
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === undefined) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = undefined) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(
              defaultWriterBrandCheckException("write")
            );
          }
          if (this._ownerWritableStream === undefined) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true },
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(
        WritableStreamDefaultWriter.prototype.releaseLock,
        "releaseLock"
      );
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          WritableStreamDefaultWriter.prototype,
          Symbol.toStringTag,
          {
            value: "WritableStreamDefaultWriter",
            configurable: true,
          }
        );
      }
      // Abstract operations for the WritableStreamDefaultWriter.
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultWriter;
      }
      // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(undefined);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(
        writer,
        error
      ) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(
        writer,
        error
      ) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(
          stream._writableStreamController
        );
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(
          `Writer was released and can no longer be used to monitor the stream's closedness`
        );
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(
          writer,
          releasedError
        );
        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
        // rejected until afterwards. This means that simply testing state will not work.
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(
          writer,
          releasedError
        );
        stream._writer = undefined;
        writer._ownerWritableStream = undefined;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(
          controller,
          chunk
        );
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(
            new TypeError(
              "The stream is closing or closed and cannot be written to"
            )
          );
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      /**
       * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
       *
       * @public
       */
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === undefined) {
            // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
            // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
            // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
            throw new TypeError(
              "WritableStreamDefaultController.prototype.signal is not supported"
            );
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e = undefined) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
            // just treat it as a no-op.
            return;
          }
          WritableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true },
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          WritableStreamDefaultController.prototype,
          Symbol.toStringTag,
          {
            value: "WritableStreamDefaultController",
            configurable: true,
          }
        );
      }
      // Abstract operations implementing interface required by the WritableStream.
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")
        ) {
          return false;
        }
        return x instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(
        stream,
        controller,
        startAlgorithm,
        writeAlgorithm,
        closeAlgorithm,
        abortAlgorithm,
        highWaterMark,
        sizeAlgorithm
      ) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._abortReason = undefined;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure =
          WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(
          startPromise,
          () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            return null;
          },
          (r) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
            return null;
          }
        );
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(
        stream,
        underlyingSink,
        highWaterMark,
        sizeAlgorithm
      ) {
        const controller = Object.create(
          WritableStreamDefaultController.prototype
        );
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== undefined) {
          startAlgorithm = () => underlyingSink.start(controller);
        } else {
          startAlgorithm = () => undefined;
        }
        if (underlyingSink.write !== undefined) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        } else {
          writeAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSink.close !== undefined) {
          closeAlgorithm = () => underlyingSink.close();
        } else {
          closeAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSink.abort !== undefined) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        } else {
          abortAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpWritableStreamDefaultController(
          stream,
          controller,
          startAlgorithm,
          writeAlgorithm,
          closeAlgorithm,
          abortAlgorithm,
          highWaterMark,
          sizeAlgorithm
        );
      }
      // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = undefined;
        controller._closeAlgorithm = undefined;
        controller._abortAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(
        controller,
        chunk,
        chunkSize
      ) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (
          !WritableStreamCloseQueuedOrInFlight(stream) &&
          stream._state === "writable"
        ) {
          const backpressure =
            WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      // Abstract operations for the WritableStreamDefaultController.
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== undefined) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(
          sinkClosePromise,
          () => {
            WritableStreamFinishInFlightClose(stream);
            return null;
          },
          (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
            return null;
          }
        );
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(
          sinkWritePromise,
          () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (
              !WritableStreamCloseQueuedOrInFlight(stream) &&
              state === "writable"
            ) {
              const backpressure =
                WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            return null;
          },
          (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
            return null;
          }
        );
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize =
          WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      // Helper functions for the WritableStream.
      function streamBrandCheckException$2(name) {
        return new TypeError(
          `WritableStream.prototype.${name} can only be used on a WritableStream`
        );
      }
      // Helper functions for the WritableStreamDefaultController.
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(
          `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`
        );
      }
      // Helper functions for the WritableStreamDefaultWriter.
      function defaultWriterBrandCheckException(name) {
        return new TypeError(
          `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`
        );
      }
      function defaultWriterLockException(name) {
        return new TypeError(
          "Cannot " + name + " a stream using a released writer"
        );
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === undefined) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === undefined) {
          return;
        }
        writer._closedPromise_resolve(undefined);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === undefined) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === undefined) {
          return;
        }
        writer._readyPromise_resolve(undefined);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = "fulfilled";
      }

      /// <reference lib="dom" />
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return undefined;
      }
      const globals = getGlobals();

      /// <reference types="node" />
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a) {
          return false;
        }
      }
      /**
       * Support:
       * - Web browsers
       * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)
       */
      function getFromGlobal() {
        const ctor =
          globals === null || globals === void 0
            ? void 0
            : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : undefined;
      }
      /**
       * Support:
       * - All platforms
       */
      function createPolyfill() {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const ctor = function DOMException(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", {
          value: ctor,
          writable: true,
          configurable: true,
        });
        return ctor;
      }
      // eslint-disable-next-line @typescript-eslint/no-redeclare
      const DOMException = getFromGlobal() || createPolyfill();

      function ReadableStreamPipeTo(
        source,
        dest,
        preventClose,
        preventAbort,
        preventCancel,
        signal
      ) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
        let currentWrite = promiseResolvedWith(undefined);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== undefined) {
            abortAlgorithm = () => {
              const error =
                signal.reason !== undefined
                  ? signal.reason
                  : new DOMException("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(undefined);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(undefined);
                });
              }
              shutdownWithAction(
                () => Promise.all(actions.map((action) => action())),
                true,
                error
              );
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          // Using reader and writer, read all chunks from this and write them to dest
          // - Backpressure must be enforced
          // - Shutdown must stop all activity
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  // Use `PerformPromiseThen` instead of `uponPromise` to avoid
                  // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(
                      WritableStreamDefaultWriterWrite(writer, chunk),
                      undefined,
                      noop
                    );
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead,
                });
              });
            });
          }
          // Errors must be propagated forward
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(
                () => WritableStreamAbort(dest, storedError),
                true,
                storedError
              );
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          // Errors must be propagated backward
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(
                () => ReadableStreamCancel(source, storedError),
                true,
                storedError
              );
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          // Closing must be propagated forward
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() =>
                WritableStreamDefaultWriterCloseWithErrorPropagation(writer)
              );
            } else {
              shutdown();
            }
            return null;
          });
          // Closing must be propagated backward
          if (
            WritableStreamCloseQueuedOrInFlight(dest) ||
            dest._state === "closed"
          ) {
            const destClosed = new TypeError(
              "the destination writable stream closed before all data could be piped to it"
            );
            if (!preventCancel) {
              shutdownWithAction(
                () => ReadableStreamCancel(source, destClosed),
                true,
                destClosed
              );
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
            // for that too.
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () =>
              oldCurrentWrite !== currentWrite
                ? waitForWritesToFinish()
                : undefined
            );
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (
              dest._state === "writable" &&
              !WritableStreamCloseQueuedOrInFlight(dest)
            ) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(
                action(),
                () => finalize(originalIsError, originalError),
                (newError) => finalize(true, newError)
              );
              return null;
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (
              dest._state === "writable" &&
              !WritableStreamCloseQueuedOrInFlight(dest)
            ) {
              uponFulfillment(waitForWritesToFinish(), () =>
                finalize(isError, error)
              );
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== undefined) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(undefined);
            }
            return null;
          }
        });
      }

      /**
       * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
       *
       * @public
       */
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError(
              "The stream is not in a state that permits close"
            );
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = undefined) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError(
              "The stream is not in a state that permits enqueue"
            );
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
        /** @internal */
        [ReleaseSteps]() {
          // Do nothing.
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true },
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(
        ReadableStreamDefaultController.prototype.enqueue,
        "enqueue"
      );
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          ReadableStreamDefaultController.prototype,
          Symbol.toStringTag,
          {
            value: "ReadableStreamDefaultController",
            configurable: true,
          }
        );
      }
      // Abstract operations for the ReadableStreamDefaultController.
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")
        ) {
          return false;
        }
        return x instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull =
          ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(
          pullPromise,
          () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
            return null;
          },
          (e) => {
            ReadableStreamDefaultControllerError(controller, e);
            return null;
          }
        );
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (
          IsReadableStreamLocked(stream) &&
          ReadableStreamGetNumReadRequests(stream) > 0
        ) {
          return true;
        }
        const desiredSize =
          ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
      }
      // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (
          IsReadableStreamLocked(stream) &&
          ReadableStreamGetNumReadRequests(stream) > 0
        ) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      // This is used in the implementation of TransformStream.
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(
        stream,
        controller,
        startAlgorithm,
        pullAlgorithm,
        cancelAlgorithm,
        highWaterMark,
        sizeAlgorithm
      ) {
        controller._controlledReadableStream = stream;
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(
          promiseResolvedWith(startResult),
          () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            return null;
          },
          (r) => {
            ReadableStreamDefaultControllerError(controller, r);
            return null;
          }
        );
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(
        stream,
        underlyingSource,
        highWaterMark,
        sizeAlgorithm
      ) {
        const controller = Object.create(
          ReadableStreamDefaultController.prototype
        );
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== undefined) {
          startAlgorithm = () => underlyingSource.start(controller);
        } else {
          startAlgorithm = () => undefined;
        }
        if (underlyingSource.pull !== undefined) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSource.cancel !== undefined) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpReadableStreamDefaultController(
          stream,
          controller,
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          highWaterMark,
          sizeAlgorithm
        );
      }
      // Helper functions for the ReadableStreamDefaultController.
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(
          `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`
        );
      }

      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(undefined);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
              // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
              // successful synchronously-available reads get ahead of asynchronously-available errors.
              _queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                // There is no way to access the cloning code right now in the reference implementation.
                // If we add one then we'll need an implementation for serializable objects.
                // if (!canceled2 && cloneForBranch2) {
                //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
                // }
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(
                    branch1._readableStreamController,
                    chunk1
                  );
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(
                    branch2._readableStreamController,
                    chunk2
                  );
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(
                  branch1._readableStreamController
                );
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(
                  branch2._readableStreamController
                );
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
              }
            },
            _errorSteps: () => {
              reading = false;
            },
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          // do nothing
        }
        branch1 = CreateReadableStream(
          startAlgorithm,
          pullAlgorithm,
          cancel1Algorithm
        );
        branch2 = CreateReadableStream(
          startAlgorithm,
          pullAlgorithm,
          cancel2Algorithm
        );
        uponRejection(reader._closedPromise, (r) => {
          ReadableStreamDefaultControllerError(
            branch1._readableStreamController,
            r
          );
          ReadableStreamDefaultControllerError(
            branch2._readableStreamController,
            r
          );
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r) => {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(
              branch1._readableStreamController,
              r
            );
            ReadableByteStreamControllerError(
              branch2._readableStreamController,
              r
            );
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
              // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
              // successful synchronously-available reads get ahead of asynchronously-available errors.
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(
                      branch1._readableStreamController,
                      cloneE
                    );
                    ReadableByteStreamControllerError(
                      branch2._readableStreamController,
                      cloneE
                    );
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(
                    branch1._readableStreamController,
                    chunk1
                  );
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(
                    branch2._readableStreamController,
                    chunk2
                  );
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(
                  branch1._readableStreamController
                );
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(
                  branch2._readableStreamController
                );
              }
              if (
                branch1._readableStreamController._pendingPullIntos.length > 0
              ) {
                ReadableByteStreamControllerRespond(
                  branch1._readableStreamController,
                  0
                );
              }
              if (
                branch2._readableStreamController._pendingPullIntos.length > 0
              ) {
                ReadableByteStreamControllerRespond(
                  branch2._readableStreamController,
                  0
                );
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
              }
            },
            _errorSteps: () => {
              reading = false;
            },
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
              // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
              // successful synchronously-available reads get ahead of asynchronously-available errors.
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(
                      byobBranch._readableStreamController,
                      cloneE
                    );
                    ReadableByteStreamControllerError(
                      otherBranch._readableStreamController,
                      cloneE
                    );
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(
                      byobBranch._readableStreamController,
                      chunk
                    );
                  }
                  ReadableByteStreamControllerEnqueue(
                    otherBranch._readableStreamController,
                    clonedChunk
                  );
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(
                    byobBranch._readableStreamController,
                    chunk
                  );
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(
                  byobBranch._readableStreamController
                );
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(
                  otherBranch._readableStreamController
                );
              }
              if (chunk !== undefined) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(
                    byobBranch._readableStreamController,
                    chunk
                  );
                }
                if (
                  !otherCanceled &&
                  otherBranch._readableStreamController._pendingPullIntos
                    .length > 0
                ) {
                  ReadableByteStreamControllerRespond(
                    otherBranch._readableStreamController,
                    0
                  );
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(undefined);
              }
            },
            _errorSteps: () => {
              reading = false;
            },
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(undefined);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(
            branch1._readableStreamController
          );
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(undefined);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(undefined);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(
            branch2._readableStreamController
          );
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(
          startAlgorithm,
          pull1Algorithm,
          cancel1Algorithm
        );
        branch2 = CreateReadableByteStream(
          startAlgorithm,
          pull2Algorithm,
          cancel2Algorithm
        );
        forwardReaderError(reader);
        return [branch1, branch2];
      }

      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }

      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, "async");
        const startAlgorithm = noop;
        function pullAlgorithm() {
          let nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e) {
            return promiseRejectedWith(e);
          }
          const nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError(
                "The promise returned by the iterator.next() method must fulfill with an object"
              );
            }
            const done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(
                stream._readableStreamController
              );
            } else {
              const value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(
                stream._readableStreamController,
                value
              );
            }
          });
        }
        function cancelAlgorithm(reason) {
          const iterator = iteratorRecord.iterator;
          let returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (returnMethod === undefined) {
            return promiseResolvedWith(undefined);
          }
          let returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e) {
            return promiseRejectedWith(e);
          }
          const returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError(
                "The promise returned by the iterator.return() method must fulfill with an object"
              );
            }
            return undefined;
          });
        }
        stream = CreateReadableStream(
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          0
        );
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop;
        function pullAlgorithm() {
          let readPromise;
          try {
            readPromise = reader.read();
          } catch (e) {
            return promiseRejectedWith(e);
          }
          return transformPromiseWith(readPromise, (readResult) => {
            if (!typeIsObject(readResult)) {
              throw new TypeError(
                "The promise returned by the reader.read() method must fulfill with an object"
              );
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(
                stream._readableStreamController
              );
            } else {
              const value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(
                stream._readableStreamController,
                value
              );
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e) {
            return promiseRejectedWith(e);
          }
        }
        stream = CreateReadableStream(
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          0
        );
        return stream;
      }

      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize =
          original === null || original === void 0
            ? void 0
            : original.autoAllocateChunkSize;
        const cancel =
          original === null || original === void 0 ? void 0 : original.cancel;
        const pull =
          original === null || original === void 0 ? void 0 : original.pull;
        const start =
          original === null || original === void 0 ? void 0 : original.start;
        const type =
          original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize:
            autoAllocateChunkSize === undefined
              ? undefined
              : convertUnsignedLongLongWithEnforceRange(
                  autoAllocateChunkSize,
                  `${context} has member 'autoAllocateChunkSize' that`
                ),
          cancel:
            cancel === undefined
              ? undefined
              : convertUnderlyingSourceCancelCallback(
                  cancel,
                  original,
                  `${context} has member 'cancel' that`
                ),
          pull:
            pull === undefined
              ? undefined
              : convertUnderlyingSourcePullCallback(
                  pull,
                  original,
                  `${context} has member 'pull' that`
                ),
          start:
            start === undefined
              ? undefined
              : convertUnderlyingSourceStartCallback(
                  start,
                  original,
                  `${context} has member 'start' that`
                ),
          type:
            type === undefined
              ? undefined
              : convertReadableStreamType(
                  type,
                  `${context} has member 'type' that`
                ),
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(
            `${context} '${type}' is not a valid enumeration value for ReadableStreamType`
          );
        }
        return type;
      }

      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel =
          options === null || options === void 0
            ? void 0
            : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }

      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort =
          options === null || options === void 0
            ? void 0
            : options.preventAbort;
        const preventCancel =
          options === null || options === void 0
            ? void 0
            : options.preventCancel;
        const preventClose =
          options === null || options === void 0
            ? void 0
            : options.preventClose;
        const signal =
          options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== undefined) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal,
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }

      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable =
          pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable =
          pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }

      /**
       * A readable stream represents a source of data, from which you can read.
       *
       * @public
       */
      class ReadableStream {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === undefined) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(
            rawStrategy,
            "Second parameter"
          );
          const underlyingSource = convertUnderlyingDefaultOrByteSource(
            rawUnderlyingSource,
            "First parameter"
          );
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== undefined) {
              throw new RangeError(
                "The strategy for a byte stream cannot have a size function"
              );
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(
              this,
              underlyingSource,
              highWaterMark
            );
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(
              this,
              underlyingSource,
              highWaterMark,
              sizeAlgorithm
            );
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = undefined) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(
              new TypeError("Cannot cancel a stream that already has a reader")
            );
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = undefined) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === undefined) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(
            rawTransform,
            "First parameter"
          );
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError(
              "ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream"
            );
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError(
              "ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream"
            );
          }
          const promise = ReadableStreamPipeTo(
            this,
            transform.writable,
            options.preventClose,
            options.preventAbort,
            options.preventCancel,
            options.signal
          );
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === undefined) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(
              new TypeError(
                `ReadableStream.prototype.pipeTo's first argument must be a WritableStream`
              )
            );
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(
              new TypeError(
                "ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"
              )
            );
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(
              new TypeError(
                "ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"
              )
            );
          }
          return ReadableStreamPipeTo(
            this,
            destination,
            options.preventClose,
            options.preventAbort,
            options.preventCancel,
            options.signal
          );
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = undefined) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(
            this,
            options.preventCancel
          );
        }
        [SymbolAsyncIterator](options) {
          // Stub implementation, overridden below
          return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
          return ReadableStreamFrom(asyncIterable);
        }
      }
      Object.defineProperties(ReadableStream, {
        from: { enumerable: true },
      });
      Object.defineProperties(ReadableStream.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true },
      });
      setFunctionName(ReadableStream.from, "from");
      setFunctionName(ReadableStream.prototype.cancel, "cancel");
      setFunctionName(ReadableStream.prototype.getReader, "getReader");
      setFunctionName(ReadableStream.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream.prototype.tee, "tee");
      setFunctionName(ReadableStream.prototype.values, "values");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {
          value: "ReadableStream",
          configurable: true,
        });
      }
      Object.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {
        value: ReadableStream.prototype.values,
        writable: true,
        configurable: true,
      });
      // Abstract operations for the ReadableStream.
      // Throws if and only if startAlgorithm throws.
      function CreateReadableStream(
        startAlgorithm,
        pullAlgorithm,
        cancelAlgorithm,
        highWaterMark = 1,
        sizeAlgorithm = () => 1
      ) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(
          ReadableStreamDefaultController.prototype
        );
        SetUpReadableStreamDefaultController(
          stream,
          controller,
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          highWaterMark,
          sizeAlgorithm
        );
        return stream;
      }
      // Throws if and only if startAlgorithm throws.
      function CreateReadableByteStream(
        startAlgorithm,
        pullAlgorithm,
        cancelAlgorithm
      ) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(
          ReadableByteStreamController.prototype
        );
        SetUpReadableByteStreamController(
          stream,
          controller,
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          0,
          undefined
        );
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = undefined;
        stream._storedError = undefined;
        stream._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(x, "_readableStreamController")
        ) {
          return false;
        }
        return x instanceof ReadableStream;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === undefined) {
          return false;
        }
        return true;
      }
      // ReadableStream API exposed for controllers.
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(undefined);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
          const readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(undefined);
          });
        }
        const sourceCancelPromise =
          stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === undefined) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          const readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e) {
        stream._state = "errored";
        stream._storedError = e;
        const reader = stream._reader;
        if (reader === undefined) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
        }
      }
      // Helper functions for the ReadableStream.
      function streamBrandCheckException$1(name) {
        return new TypeError(
          `ReadableStream.prototype.${name} can only be used on a ReadableStream`
        );
      }

      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark =
          init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(
          highWaterMark,
          "highWaterMark",
          "QueuingStrategyInit"
        );
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark),
        };
      }

      // The size function must not have a prototype property nor be a constructor
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      /**
       * A queuing strategy that counts the number of bytes in each chunk.
       *
       * @public
       */
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true },
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          ByteLengthQueuingStrategy.prototype,
          Symbol.toStringTag,
          {
            value: "ByteLengthQueuingStrategy",
            configurable: true,
          }
        );
      }
      // Helper functions for the ByteLengthQueuingStrategy.
      function byteLengthBrandCheckException(name) {
        return new TypeError(
          `ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`
        );
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(
            x,
            "_byteLengthQueuingStrategyHighWaterMark"
          )
        ) {
          return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
      }

      // The size function must not have a prototype property nor be a constructor
      const countSizeFunction = () => {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      /**
       * A queuing strategy that counts the number of chunks.
       *
       * @public
       */
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true },
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          CountQueuingStrategy.prototype,
          Symbol.toStringTag,
          {
            value: "CountQueuingStrategy",
            configurable: true,
          }
        );
      }
      // Helper functions for the CountQueuingStrategy.
      function countBrandCheckException(name) {
        return new TypeError(
          `CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`
        );
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(
            x,
            "_countQueuingStrategyHighWaterMark"
          )
        ) {
          return false;
        }
        return x instanceof CountQueuingStrategy;
      }

      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel =
          original === null || original === void 0 ? void 0 : original.cancel;
        const flush =
          original === null || original === void 0 ? void 0 : original.flush;
        const readableType =
          original === null || original === void 0
            ? void 0
            : original.readableType;
        const start =
          original === null || original === void 0 ? void 0 : original.start;
        const transform =
          original === null || original === void 0
            ? void 0
            : original.transform;
        const writableType =
          original === null || original === void 0
            ? void 0
            : original.writableType;
        return {
          cancel:
            cancel === undefined
              ? undefined
              : convertTransformerCancelCallback(
                  cancel,
                  original,
                  `${context} has member 'cancel' that`
                ),
          flush:
            flush === undefined
              ? undefined
              : convertTransformerFlushCallback(
                  flush,
                  original,
                  `${context} has member 'flush' that`
                ),
          readableType,
          start:
            start === undefined
              ? undefined
              : convertTransformerStartCallback(
                  start,
                  original,
                  `${context} has member 'start' that`
                ),
          transform:
            transform === undefined
              ? undefined
              : convertTransformerTransformCallback(
                  transform,
                  original,
                  `${context} has member 'transform' that`
                ),
          writableType,
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) =>
          promiseCall(fn, original, [chunk, controller]);
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }

      // Class TransformStream
      /**
       * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
       * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
       * In a manner specific to the transform stream in question, writes to the writable side result in new data being
       * made available for reading from the readable side.
       *
       * @public
       */
      class TransformStream {
        constructor(
          rawTransformer = {},
          rawWritableStrategy = {},
          rawReadableStrategy = {}
        ) {
          if (rawTransformer === undefined) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(
            rawWritableStrategy,
            "Second parameter"
          );
          const readableStrategy = convertQueuingStrategy(
            rawReadableStrategy,
            "Third parameter"
          );
          const transformer = convertTransformer(
            rawTransformer,
            "First parameter"
          );
          if (transformer.readableType !== undefined) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== undefined) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(
            readableStrategy,
            0
          );
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(
            writableStrategy,
            1
          );
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(
            this,
            startPromise,
            writableHighWaterMark,
            writableSizeAlgorithm,
            readableHighWaterMark,
            readableSizeAlgorithm
          );
          SetUpTransformStreamDefaultControllerFromTransformer(
            this,
            transformer
          );
          if (transformer.start !== undefined) {
            startPromise_resolve(
              transformer.start(this._transformStreamController)
            );
          } else {
            startPromise_resolve(undefined);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true },
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
          value: "TransformStream",
          configurable: true,
        });
      }
      function InitializeTransformStream(
        stream,
        startPromise,
        writableHighWaterMark,
        writableSizeAlgorithm,
        readableHighWaterMark,
        readableSizeAlgorithm
      ) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(
          startAlgorithm,
          writeAlgorithm,
          closeAlgorithm,
          abortAlgorithm,
          writableHighWaterMark,
          writableSizeAlgorithm
        );
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(
          startAlgorithm,
          pullAlgorithm,
          cancelAlgorithm,
          readableHighWaterMark,
          readableSizeAlgorithm
        );
        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
        stream._backpressure = undefined;
        stream._backpressureChangePromise = undefined;
        stream._backpressureChangePromise_resolve = undefined;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = undefined;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(x, "_transformStreamController")
        ) {
          return false;
        }
        return x instanceof TransformStream;
      }
      // This is a no-op if both sides are already errored.
      function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(
          stream._readable._readableStreamController,
          e
        );
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(
          stream._transformStreamController
        );
        WritableStreamDefaultControllerErrorIfNeeded(
          stream._writable._writableStreamController,
          e
        );
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
          // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
          // _backpressure is set.
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        // Passes also when called during construction.
        if (stream._backpressureChangePromise !== undefined) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      // Class TransformStreamDefaultController
      /**
       * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
       *
       * @public
       */
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController =
            this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(
            readableController
          );
        }
        enqueue(chunk = undefined) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = undefined) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true },
      });
      setFunctionName(
        TransformStreamDefaultController.prototype.enqueue,
        "enqueue"
      );
      setFunctionName(
        TransformStreamDefaultController.prototype.error,
        "error"
      );
      setFunctionName(
        TransformStreamDefaultController.prototype.terminate,
        "terminate"
      );
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(
          TransformStreamDefaultController.prototype,
          Symbol.toStringTag,
          {
            value: "TransformStreamDefaultController",
            configurable: true,
          }
        );
      }
      // Transform Stream Default Controller Abstract Operations
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (
          !Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")
        ) {
          return false;
        }
        return x instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(
        stream,
        controller,
        transformAlgorithm,
        flushAlgorithm,
        cancelAlgorithm
      ) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = undefined;
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(
        stream,
        transformer
      ) {
        const controller = Object.create(
          TransformStreamDefaultController.prototype
        );
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== undefined) {
          transformAlgorithm = (chunk) =>
            transformer.transform(chunk, controller);
        } else {
          transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(undefined);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== undefined) {
          flushAlgorithm = () => transformer.flush(controller);
        } else {
          flushAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (transformer.cancel !== undefined) {
          cancelAlgorithm = (reason) => transformer.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpTransformStreamDefaultController(
          stream,
          controller,
          transformAlgorithm,
          flushAlgorithm,
          cancelAlgorithm
        );
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = undefined;
        controller._flushAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (
          !ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)
        ) {
          throw new TypeError(
            "Readable side is not in a state that permits enqueue"
          );
        }
        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
        // accept TransformStreamDefaultControllerEnqueue() calls.
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          // This happens when readableStrategy.size() throws.
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
          throw stream._readable._storedError;
        }
        const backpressure =
          ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(
        controller,
        chunk
      ) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, undefined, (r) => {
          TransformStreamError(controller._controlledTransformStream, r);
          throw r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      // TransformStreamDefaultSink Algorithms
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(
              controller,
              chunk
            );
          });
        }
        return TransformStreamDefaultControllerPerformTransform(
          controller,
          chunk
        );
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
          return controller._finishPromise;
        }
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,
        // we don't run the _cancelAlgorithm again.
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(
          cancelPromise,
          () => {
            if (readable._state === "errored") {
              defaultControllerFinishPromiseReject(
                controller,
                readable._storedError
              );
            } else {
              ReadableStreamDefaultControllerError(
                readable._readableStreamController,
                reason
              );
              defaultControllerFinishPromiseResolve(controller);
            }
            return null;
          },
          (r) => {
            ReadableStreamDefaultControllerError(
              readable._readableStreamController,
              r
            );
            defaultControllerFinishPromiseReject(controller, r);
            return null;
          }
        );
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
          return controller._finishPromise;
        }
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,
        // we don't also run the _cancelAlgorithm.
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(
          flushPromise,
          () => {
            if (readable._state === "errored") {
              defaultControllerFinishPromiseReject(
                controller,
                readable._storedError
              );
            } else {
              ReadableStreamDefaultControllerClose(
                readable._readableStreamController
              );
              defaultControllerFinishPromiseResolve(controller);
            }
            return null;
          },
          (r) => {
            ReadableStreamDefaultControllerError(
              readable._readableStreamController,
              r
            );
            defaultControllerFinishPromiseReject(controller, r);
            return null;
          }
        );
        return controller._finishPromise;
      }
      // TransformStreamDefaultSource Algorithms
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        // Invariant. Enforced by the promises returned by start() and pull().
        TransformStreamSetBackpressure(stream, false);
        // Prevent the next pull() call until there is backpressure.
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
          return controller._finishPromise;
        }
        // stream._writable cannot change after construction, so caching it across a call to user code is safe.
        const writable = stream._writable;
        // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or
        // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the
        // _flushAlgorithm.
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(
          cancelPromise,
          () => {
            if (writable._state === "errored") {
              defaultControllerFinishPromiseReject(
                controller,
                writable._storedError
              );
            } else {
              WritableStreamDefaultControllerErrorIfNeeded(
                writable._writableStreamController,
                reason
              );
              TransformStreamUnblockWrite(stream);
              defaultControllerFinishPromiseResolve(controller);
            }
            return null;
          },
          (r) => {
            WritableStreamDefaultControllerErrorIfNeeded(
              writable._writableStreamController,
              r
            );
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
          }
        );
        return controller._finishPromise;
      }
      // Helper functions for the TransformStreamDefaultController.
      function defaultControllerBrandCheckException(name) {
        return new TypeError(
          `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`
        );
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === undefined) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === undefined) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
      }
      // Helper functions for the TransformStream.
      function streamBrandCheckException(name) {
        return new TypeError(
          `TransformStream.prototype.${name} can only be used on a TransformStream`
        );
      }

      exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports.CountQueuingStrategy = CountQueuingStrategy;
      exports.ReadableByteStreamController = ReadableByteStreamController;
      exports.ReadableStream = ReadableStream;
      exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports.TransformStream = TransformStream;
      exports.TransformStreamDefaultController =
        TransformStreamDefaultController;
      exports.WritableStream = WritableStream;
      exports.WritableStreamDefaultController = WritableStreamDefaultController;
      exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    });
    //# sourceMappingURL=ponyfill.es2018.js.map

    /***/
  },

  /***/ 2839: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32,
      };
    }).call(this);

    /***/
  },

  /***/ 9267: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        // Numeric codes up to 200 are reserved to W3C for possible future use.
        // Following are types internal to this library:
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205,
      };
    }).call(this);

    /***/
  },

  /***/ 8229: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Copies all enumerable own properties from `sources` to `target`
      var assign,
        getValue,
        isArray,
        isEmpty,
        isFunction,
        isObject,
        isPlainObject,
        hasProp = {}.hasOwnProperty;

      assign = function (target, ...sources) {
        var i, key, len, source;
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };

      // Determines if `val` is a Function object
      isFunction = function (val) {
        return (
          !!val && Object.prototype.toString.call(val) === "[object Function]"
        );
      };

      // Determines if `val` is an Object
      isObject = function (val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };

      // Determines if `val` is an Array
      isArray = function (val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };

      // Determines if `val` is an empty Array or an Object with no own properties
      isEmpty = function (val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key)) continue;
            return false;
          }
          return true;
        }
      };

      // Determines if `val` is a plain Object
      isPlainObject = function (val) {
        var ctor, proto;
        return (
          isObject(val) &&
          (proto = Object.getPrototypeOf(val)) &&
          (ctor = proto.constructor) &&
          typeof ctor === "function" &&
          ctor instanceof ctor &&
          Function.prototype.toString.call(ctor) ===
            Function.prototype.toString.call(Object)
        );
      };

      // Gets the primitive value of an object
      getValue = function (obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };

      module.exports.assign = assign;

      module.exports.isFunction = isFunction;

      module.exports.isObject = isObject;

      module.exports.isArray = isArray;

      module.exports.isEmpty = isEmpty;

      module.exports.isPlainObject = isPlainObject;

      module.exports.getValue = getValue;
    }).call(this);

    /***/
  },

  /***/ 9766: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3,
      };
    }).call(this);

    /***/
  },

  /***/ 8376: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLAttribute, XMLNode;

      NodeType = __nccwpck_require__(9267);

      XMLNode = __nccwpck_require__(7608);

      // Represents an attribute
      module.exports = XMLAttribute = function () {
        class XMLAttribute {
          // Initializes a new instance of `XMLAttribute`

          // `parent` the parent node
          // `name` attribute target
          // `value` attribute value
          constructor(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            if (name == null) {
              throw new Error(
                "Missing attribute name. " + this.debugInfo(name)
              );
            }
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            // DOM level 3
            this.isId = false;
            this.schemaTypeInfo = null;
          }

          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }

          // Converts the XML fragment to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.attribute(
              this,
              this.options.writer.filterOptions(options)
            );
          }

          // Returns debug string for this node
          debugInfo(name) {
            name = name || this.name;
            if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else {
              return (
                "attribute: {" + name + "}, parent: <" + this.parent.name + ">"
              );
            }
          }

          isEqualNode(node) {
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.value !== this.value) {
              return false;
            }
            return true;
          }
        }

        // DOM level 1
        Object.defineProperty(XMLAttribute.prototype, "nodeType", {
          get: function () {
            return this.type;
          },
        });

        Object.defineProperty(XMLAttribute.prototype, "ownerElement", {
          get: function () {
            return this.parent;
          },
        });

        // DOM level 3
        Object.defineProperty(XMLAttribute.prototype, "textContent", {
          get: function () {
            return this.value;
          },
          set: function (value) {
            return (this.value = value || "");
          },
        });

        // DOM level 4
        Object.defineProperty(XMLAttribute.prototype, "namespaceURI", {
          get: function () {
            return "";
          },
        });

        Object.defineProperty(XMLAttribute.prototype, "prefix", {
          get: function () {
            return "";
          },
        });

        Object.defineProperty(XMLAttribute.prototype, "localName", {
          get: function () {
            return this.name;
          },
        });

        Object.defineProperty(XMLAttribute.prototype, "specified", {
          get: function () {
            return true;
          },
        });

        return XMLAttribute;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 333: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLCData, XMLCharacterData;

      NodeType = __nccwpck_require__(9267);

      XMLCharacterData = __nccwpck_require__(7709);

      // Represents a  CDATA node
      module.exports = XMLCData = class XMLCData extends XMLCharacterData {
        // Initializes a new instance of `XMLCData`

        // `text` CDATA text
        constructor(parent, text) {
          super(parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }

        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }

        // Converts the XML fragment to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.cdata(
            this,
            this.options.writer.filterOptions(options)
          );
        }
      };
    }).call(this);

    /***/
  },

  /***/ 7709: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var XMLCharacterData, XMLNode;

      XMLNode = __nccwpck_require__(7608);

      // Represents a character data node
      module.exports = XMLCharacterData = function () {
        class XMLCharacterData extends XMLNode {
          // Initializes a new instance of `XMLCharacterData`

          constructor(parent) {
            super(parent);
            this.value = "";
          }

          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }

          // DOM level 1 functions to be implemented later
          substringData(offset, count) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          appendData(arg) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          insertData(offset, arg) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          deleteData(offset, count) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          replaceData(offset, count, arg) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          isEqualNode(node) {
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.data !== this.data) {
              return false;
            }
            return true;
          }
        }

        // DOM level 1
        Object.defineProperty(XMLCharacterData.prototype, "data", {
          get: function () {
            return this.value;
          },
          set: function (value) {
            return (this.value = value || "");
          },
        });

        Object.defineProperty(XMLCharacterData.prototype, "length", {
          get: function () {
            return this.value.length;
          },
        });

        // DOM level 3
        Object.defineProperty(XMLCharacterData.prototype, "textContent", {
          get: function () {
            return this.value;
          },
          set: function (value) {
            return (this.value = value || "");
          },
        });

        return XMLCharacterData;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 4407: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLCharacterData, XMLComment;

      NodeType = __nccwpck_require__(9267);

      XMLCharacterData = __nccwpck_require__(7709);

      // Represents a comment node
      module.exports = XMLComment = class XMLComment extends XMLCharacterData {
        // Initializes a new instance of `XMLComment`

        // `text` comment text
        constructor(parent, text) {
          super(parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }

        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }

        // Converts the XML fragment to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.comment(
            this,
            this.options.writer.filterOptions(options)
          );
        }
      };
    }).call(this);

    /***/
  },

  /***/ 7465: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;

      XMLDOMErrorHandler = __nccwpck_require__(6744);

      XMLDOMStringList = __nccwpck_require__(7028);

      // Implements the DOMConfiguration interface
      module.exports = XMLDOMConfiguration = function () {
        class XMLDOMConfiguration {
          constructor() {
            var clonedSelf;
            this.defaultParams = {
              "canonical-form": false,
              "cdata-sections": false,
              comments: false,
              "datatype-normalization": false,
              "element-content-whitespace": true,
              entities: true,
              "error-handler": new XMLDOMErrorHandler(),
              infoset: true,
              "validate-if-schema": false,
              namespaces: true,
              "namespace-declarations": true,
              "normalize-characters": false,
              "schema-location": "",
              "schema-type": "",
              "split-cdata-sections": true,
              validate: false,
              "well-formed": true,
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
          }

          // Gets the value of a parameter.

          // `name` name of the parameter
          getParameter(name) {
            if (this.params.hasOwnProperty(name)) {
              return this.params[name];
            } else {
              return null;
            }
          }

          // Checks if setting a parameter to a specific value is supported.

          // `name` name of the parameter
          // `value` parameter value
          canSetParameter(name, value) {
            return true;
          }

          // Sets the value of a parameter.

          // `name` name of the parameter
          // `value` new value or null if the user wishes to unset the parameter
          setParameter(name, value) {
            if (value != null) {
              return (this.params[name] = value);
            } else {
              return delete this.params[name];
            }
          }
        }

        // Returns the list of parameter names
        Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", {
          get: function () {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          },
        });

        return XMLDOMConfiguration;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 6744: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Represents the error handler for DOM operations
      var XMLDOMErrorHandler;

      module.exports = XMLDOMErrorHandler = class XMLDOMErrorHandler {
        // Initializes a new instance of `XMLDOMErrorHandler`

        constructor() {}

        // Called on the error handler when an error occurs.

        // `error` the error message as a string
        handleError(error) {
          throw new Error(error);
        }
      };
    }).call(this);

    /***/
  },

  /***/ 8310: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Implements the DOMImplementation interface
      var XMLDOMImplementation;

      module.exports = XMLDOMImplementation = class XMLDOMImplementation {
        // Tests if the DOM implementation implements a specific feature.

        // `feature` package name of the feature to test. In Level 1, the
        //           legal values are "HTML" and "XML" (case-insensitive).
        // `version` version number of the package name to test.
        //           In Level 1, this is the string "1.0". If the version is
        //           not specified, supporting any version of the feature will
        //           cause the method to return true.
        hasFeature(feature, version) {
          return true;
        }

        // Creates a new document type declaration.

        // `qualifiedName` qualified name of the document type to be created
        // `publicId` public identifier of the external subset
        // `systemId` system identifier of the external subset
        createDocumentType(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        }

        // Creates a new document.

        // `namespaceURI` namespace URI of the document element to create
        // `qualifiedName` the qualified name of the document to be created
        // `doctype` the type of document to be created or null
        createDocument(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        }

        // Creates a new HTML document.

        // `title` document title
        createHTMLDocument(title) {
          throw new Error("This DOM method is not implemented.");
        }

        // Returns a specialized object which implements the specialized APIs
        // of the specified feature and version.

        // `feature` name of the feature requested.
        // `version` version number of the feature to test
        getFeature(feature, version) {
          throw new Error("This DOM method is not implemented.");
        }
      };
    }).call(this);

    /***/
  },

  /***/ 7028: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Represents a list of string entries
      var XMLDOMStringList;

      module.exports = XMLDOMStringList = function () {
        class XMLDOMStringList {
          // Initializes a new instance of `XMLDOMStringList`
          // This is just a wrapper around an ordinary
          // JS array.

          // `arr` the array of string values
          constructor(arr) {
            this.arr = arr || [];
          }

          // Returns the indexth item in the collection.

          // `index` index into the collection
          item(index) {
            return this.arr[index] || null;
          }

          // Test if a string is part of this DOMStringList.

          // `str` the string to look for
          contains(str) {
            return this.arr.indexOf(str) !== -1;
          }
        }

        // Returns the number of strings in the list.
        Object.defineProperty(XMLDOMStringList.prototype, "length", {
          get: function () {
            return this.arr.length;
          },
        });

        return XMLDOMStringList;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 1015: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLDTDAttList, XMLNode;

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      // Represents an attribute list
      module.exports = XMLDTDAttList = class XMLDTDAttList extends XMLNode {
        // Initializes a new instance of `XMLDTDAttList`

        // `parent` the parent `XMLDocType` element
        // `elementName` the name of the element containing this attribute
        // `attributeName` attribute name
        // `attributeType` type of the attribute
        // `defaultValueType` default value type (either #REQUIRED, #IMPLIED,
        //                    #FIXED or #DEFAULT)
        // `defaultValue` default value of the attribute
        //                (only used for #FIXED or #DEFAULT)
        constructor(
          parent,
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue
        ) {
          super(parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error(
              "Missing DTD attribute name. " + this.debugInfo(elementName)
            );
          }
          if (!attributeType) {
            throw new Error(
              "Missing DTD attribute type. " + this.debugInfo(elementName)
            );
          }
          if (!defaultValueType) {
            throw new Error(
              "Missing DTD attribute default. " + this.debugInfo(elementName)
            );
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (
            !defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)
          ) {
            throw new Error(
              "Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " +
                this.debugInfo(elementName)
            );
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error(
              "Default value only applies to #FIXED or #DEFAULT. " +
                this.debugInfo(elementName)
            );
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }

        // Converts the XML fragment to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.dtdAttList(
            this,
            this.options.writer.filterOptions(options)
          );
        }
      };
    }).call(this);

    /***/
  },

  /***/ 2421: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLDTDElement, XMLNode;

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      // Represents an attribute
      module.exports = XMLDTDElement = class XMLDTDElement extends XMLNode {
        // Initializes a new instance of `XMLDTDElement`

        // `parent` the parent `XMLDocType` element
        // `name` element name
        // `value` element content (defaults to #PCDATA)
        constructor(parent, name, value) {
          super(parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }

        // Converts the XML fragment to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.dtdElement(
            this,
            this.options.writer.filterOptions(options)
          );
        }
      };
    }).call(this);

    /***/
  },

  /***/ 53: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLDTDEntity, XMLNode, isObject;

      ({ isObject } = __nccwpck_require__(8229));

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      // Represents an entity declaration in the DTD
      module.exports = XMLDTDEntity = function () {
        class XMLDTDEntity extends XMLNode {
          // Initializes a new instance of `XMLDTDEntity`

          // `parent` the parent `XMLDocType` element
          // `pe` whether this is a parameter entity or a general entity
          //      defaults to `false` (general entity)
          // `name` the name of the entity
          // `value` internal entity value or an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          // `value.nData` notation declaration
          constructor(parent, pe, name, value) {
            super(parent);
            if (name == null) {
              throw new Error(
                "Missing DTD entity name. " + this.debugInfo(name)
              );
            }
            if (value == null) {
              throw new Error(
                "Missing DTD entity value. " + this.debugInfo(name)
              );
            }
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
              this.value = this.stringify.dtdEntityValue(value);
              this.internal = true;
            } else {
              if (!value.pubID && !value.sysID) {
                throw new Error(
                  "Public and/or system identifiers are required for an external entity. " +
                    this.debugInfo(name)
                );
              }
              if (value.pubID && !value.sysID) {
                throw new Error(
                  "System identifier is required for a public external entity. " +
                    this.debugInfo(name)
                );
              }
              this.internal = false;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
              if (value.nData != null) {
                this.nData = this.stringify.dtdNData(value.nData);
              }
              if (this.pe && this.nData) {
                throw new Error(
                  "Notation declaration is not allowed in a parameter entity. " +
                    this.debugInfo(name)
                );
              }
            }
          }

          // Converts the XML fragment to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.dtdEntity(
              this,
              this.options.writer.filterOptions(options)
            );
          }
        }

        // DOM level 1
        Object.defineProperty(XMLDTDEntity.prototype, "publicId", {
          get: function () {
            return this.pubID;
          },
        });

        Object.defineProperty(XMLDTDEntity.prototype, "systemId", {
          get: function () {
            return this.sysID;
          },
        });

        Object.defineProperty(XMLDTDEntity.prototype, "notationName", {
          get: function () {
            return this.nData || null;
          },
        });

        // DOM level 3
        Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", {
          get: function () {
            return null;
          },
        });

        Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", {
          get: function () {
            return null;
          },
        });

        Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", {
          get: function () {
            return null;
          },
        });

        return XMLDTDEntity;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 2837: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLDTDNotation, XMLNode;

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      // Represents a NOTATION entry in the DTD
      module.exports = XMLDTDNotation = function () {
        class XMLDTDNotation extends XMLNode {
          // Initializes a new instance of `XMLDTDNotation`

          // `parent` the parent `XMLDocType` element
          // `name` the name of the notation
          // `value` an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          constructor(parent, name, value) {
            super(parent);
            if (name == null) {
              throw new Error(
                "Missing DTD notation name. " + this.debugInfo(name)
              );
            }
            if (!value.pubID && !value.sysID) {
              throw new Error(
                "Public or system identifiers are required for an external entity. " +
                  this.debugInfo(name)
              );
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
          }

          // Converts the XML fragment to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.dtdNotation(
              this,
              this.options.writer.filterOptions(options)
            );
          }
        }

        // DOM level 1
        Object.defineProperty(XMLDTDNotation.prototype, "publicId", {
          get: function () {
            return this.pubID;
          },
        });

        Object.defineProperty(XMLDTDNotation.prototype, "systemId", {
          get: function () {
            return this.sysID;
          },
        });

        return XMLDTDNotation;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 6364: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLDeclaration, XMLNode, isObject;

      ({ isObject } = __nccwpck_require__(8229));

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      // Represents the XML declaration
      module.exports = XMLDeclaration = class XMLDeclaration extends XMLNode {
        // Initializes a new instance of `XMLDeclaration`

        // `parent` the document object

        // `version` A version number string, e.g. 1.0
        // `encoding` Encoding declaration, e.g. UTF-8
        // `standalone` standalone document declaration: true or false
        constructor(parent, version, encoding, standalone) {
          super(parent);
          // arguments may also be passed as an object
          if (isObject(version)) {
            ({ version, encoding, standalone } = version);
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }

        // Converts to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.declaration(
            this,
            this.options.writer.filterOptions(options)
          );
        }
      };
    }).call(this);

    /***/
  },

  /***/ 1801: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDocType,
        XMLNamedNodeMap,
        XMLNode,
        isObject;

      ({ isObject } = __nccwpck_require__(8229));

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      XMLDTDAttList = __nccwpck_require__(1015);

      XMLDTDEntity = __nccwpck_require__(53);

      XMLDTDElement = __nccwpck_require__(2421);

      XMLDTDNotation = __nccwpck_require__(2837);

      XMLNamedNodeMap = __nccwpck_require__(4361);

      // Represents doctype declaration
      module.exports = XMLDocType = function () {
        class XMLDocType extends XMLNode {
          // Initializes a new instance of `XMLDocType`

          // `parent` the document object

          // `pubID` public identifier of the external subset
          // `sysID` system identifier of the external subset
          constructor(parent, pubID, sysID) {
            var child, i, len, ref;
            super(parent);
            this.type = NodeType.DocType;
            // set DTD name to the name of the root node
            if (parent.children) {
              ref = parent.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.Element) {
                  this.name = child.name;
                  break;
                }
              }
            }
            this.documentObject = parent;
            // arguments may also be passed as an object
            if (isObject(pubID)) {
              ({ pubID, sysID } = pubID);
            }
            if (sysID == null) {
              [sysID, pubID] = [pubID, sysID];
            }
            if (pubID != null) {
              this.pubID = this.stringify.dtdPubID(pubID);
            }
            if (sysID != null) {
              this.sysID = this.stringify.dtdSysID(sysID);
            }
          }

          // Creates an element type declaration

          // `name` element name
          // `value` element content (defaults to #PCDATA)
          element(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
          }

          // Creates an attribute declaration

          // `elementName` the name of the element containing this attribute
          // `attributeName` attribute name
          // `attributeType` type of the attribute (defaults to CDATA)
          // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
          //                    #DEFAULT) (defaults to #IMPLIED)
          // `defaultValue` default value of the attribute
          //                (only used for #FIXED or #DEFAULT)
          attList(
            elementName,
            attributeName,
            attributeType,
            defaultValueType,
            defaultValue
          ) {
            var child;
            child = new XMLDTDAttList(
              this,
              elementName,
              attributeName,
              attributeType,
              defaultValueType,
              defaultValue
            );
            this.children.push(child);
            return this;
          }

          // Creates a general entity declaration

          // `name` the name of the entity
          // `value` internal entity value or an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          // `value.nData` notation declaration
          entity(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
          }

          // Creates a parameter entity declaration

          // `name` the name of the entity
          // `value` internal entity value or an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          pEntity(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
          }

          // Creates a NOTATION declaration

          // `name` the name of the notation
          // `value` an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          notation(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
          }

          // Converts to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.docType(
              this,
              this.options.writer.filterOptions(options)
            );
          }

          // Aliases
          ele(name, value) {
            return this.element(name, value);
          }

          att(
            elementName,
            attributeName,
            attributeType,
            defaultValueType,
            defaultValue
          ) {
            return this.attList(
              elementName,
              attributeName,
              attributeType,
              defaultValueType,
              defaultValue
            );
          }

          ent(name, value) {
            return this.entity(name, value);
          }

          pent(name, value) {
            return this.pEntity(name, value);
          }

          not(name, value) {
            return this.notation(name, value);
          }

          up() {
            return this.root() || this.documentObject;
          }

          isEqualNode(node) {
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.name !== this.name) {
              return false;
            }
            if (node.publicId !== this.publicId) {
              return false;
            }
            if (node.systemId !== this.systemId) {
              return false;
            }
            return true;
          }
        }

        // DOM level 1
        Object.defineProperty(XMLDocType.prototype, "entities", {
          get: function () {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          },
        });

        Object.defineProperty(XMLDocType.prototype, "notations", {
          get: function () {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          },
        });

        // DOM level 2
        Object.defineProperty(XMLDocType.prototype, "publicId", {
          get: function () {
            return this.pubID;
          },
        });

        Object.defineProperty(XMLDocType.prototype, "systemId", {
          get: function () {
            return this.sysID;
          },
        });

        Object.defineProperty(XMLDocType.prototype, "internalSubset", {
          get: function () {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          },
        });

        return XMLDocType;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 3730: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        XMLDOMConfiguration,
        XMLDOMImplementation,
        XMLDocument,
        XMLNode,
        XMLStringWriter,
        XMLStringifier,
        isPlainObject;

      ({ isPlainObject } = __nccwpck_require__(8229));

      XMLDOMImplementation = __nccwpck_require__(8310);

      XMLDOMConfiguration = __nccwpck_require__(7465);

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      XMLStringifier = __nccwpck_require__(8594);

      XMLStringWriter = __nccwpck_require__(5913);

      // Represents an XML builder
      module.exports = XMLDocument = function () {
        class XMLDocument extends XMLNode {
          // Initializes a new instance of `XMLDocument`

          // `options.keepNullNodes` whether nodes with null values will be kept
          //     or ignored: true or false
          // `options.keepNullAttributes` whether attributes with null values will be
          //     kept or ignored: true or false
          // `options.ignoreDecorators` whether decorator strings will be ignored when
          //     converting JS objects: true or false
          // `options.separateArrayItems` whether array items are created as separate
          //     nodes when passed as an object value: true or false
          // `options.noDoubleEncoding` whether existing html entities are encoded:
          //     true or false
          // `options.stringify` a set of functions to use for converting values to
          //     strings
          // `options.writer` the default XML writer to use for converting nodes to
          //     string. If the default writer is not set, the built-in XMLStringWriter
          //     will be used instead.
          constructor(options) {
            super(null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {});
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.stringify = new XMLStringifier(options);
          }

          // Ends the document and passes it to the given XML writer

          // `writer` is either an XML writer or a plain object to pass to the
          // constructor of the default XML writer. The default writer is assigned when
          // creating the XML document. Following flags are recognized by the
          // built-in XMLStringWriter:
          //   `writer.pretty` pretty prints the result
          //   `writer.indent` indentation for pretty print
          //   `writer.offset` how many indentations to add to every line for pretty print
          //   `writer.newline` newline sequence for pretty print
          end(writer) {
            var writerOptions;
            writerOptions = {};
            if (!writer) {
              writer = this.options.writer;
            } else if (isPlainObject(writer)) {
              writerOptions = writer;
              writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
          }

          // Converts the XML document to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.document(
              this,
              this.options.writer.filterOptions(options)
            );
          }

          // DOM level 1 functions to be implemented later
          createElement(tagName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createDocumentFragment() {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createTextNode(data) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createComment(data) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createCDATASection(data) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createProcessingInstruction(target, data) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createAttribute(name) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createEntityReference(name) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementsByTagName(tagname) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM level 2 functions to be implemented later
          importNode(importedNode, deep) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createElementNS(namespaceURI, qualifiedName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createAttributeNS(namespaceURI, qualifiedName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementsByTagNameNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementById(elementId) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM level 3 functions to be implemented later
          adoptNode(source) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          normalizeDocument() {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          renameNode(node, namespaceURI, qualifiedName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM level 4 functions to be implemented later
          getElementsByClassName(classNames) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createEvent(eventInterface) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createRange() {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createNodeIterator(root, whatToShow, filter) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          createTreeWalker(root, whatToShow, filter) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }
        }

        // DOM level 1
        Object.defineProperty(XMLDocument.prototype, "implementation", {
          value: new XMLDOMImplementation(),
        });

        Object.defineProperty(XMLDocument.prototype, "doctype", {
          get: function () {
            var child, i, len, ref;
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "documentElement", {
          get: function () {
            return this.rootObject || null;
          },
        });

        // DOM level 3
        Object.defineProperty(XMLDocument.prototype, "inputEncoding", {
          get: function () {
            return null;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", {
          get: function () {
            return false;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "xmlEncoding", {
          get: function () {
            if (
              this.children.length !== 0 &&
              this.children[0].type === NodeType.Declaration
            ) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          },
        });

        Object.defineProperty(XMLDocument.prototype, "xmlStandalone", {
          get: function () {
            if (
              this.children.length !== 0 &&
              this.children[0].type === NodeType.Declaration
            ) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          },
        });

        Object.defineProperty(XMLDocument.prototype, "xmlVersion", {
          get: function () {
            if (
              this.children.length !== 0 &&
              this.children[0].type === NodeType.Declaration
            ) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          },
        });

        // DOM level 4
        Object.defineProperty(XMLDocument.prototype, "URL", {
          get: function () {
            return this.documentURI;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "origin", {
          get: function () {
            return null;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "compatMode", {
          get: function () {
            return null;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "characterSet", {
          get: function () {
            return null;
          },
        });

        Object.defineProperty(XMLDocument.prototype, "contentType", {
          get: function () {
            return null;
          },
        });

        return XMLDocument;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 7356: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        WriterState,
        XMLAttribute,
        XMLCData,
        XMLComment,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDeclaration,
        XMLDocType,
        XMLDocument,
        XMLDocumentCB,
        XMLElement,
        XMLProcessingInstruction,
        XMLRaw,
        XMLStringWriter,
        XMLStringifier,
        XMLText,
        getValue,
        isFunction,
        isObject,
        isPlainObject,
        hasProp = {}.hasOwnProperty;

      ({ isObject, isFunction, isPlainObject, getValue } =
        __nccwpck_require__(8229));

      NodeType = __nccwpck_require__(9267);

      XMLDocument = __nccwpck_require__(3730);

      XMLElement = __nccwpck_require__(9437);

      XMLCData = __nccwpck_require__(333);

      XMLComment = __nccwpck_require__(4407);

      XMLRaw = __nccwpck_require__(6329);

      XMLText = __nccwpck_require__(1318);

      XMLProcessingInstruction = __nccwpck_require__(6939);

      XMLDeclaration = __nccwpck_require__(6364);

      XMLDocType = __nccwpck_require__(1801);

      XMLDTDAttList = __nccwpck_require__(1015);

      XMLDTDEntity = __nccwpck_require__(53);

      XMLDTDElement = __nccwpck_require__(2421);

      XMLDTDNotation = __nccwpck_require__(2837);

      XMLAttribute = __nccwpck_require__(8376);

      XMLStringifier = __nccwpck_require__(8594);

      XMLStringWriter = __nccwpck_require__(5913);

      WriterState = __nccwpck_require__(9766);

      // Represents an XML builder
      module.exports = XMLDocumentCB = class XMLDocumentCB {
        // Initializes a new instance of `XMLDocumentCB`

        // `options.keepNullNodes` whether nodes with null values will be kept
        //     or ignored: true or false
        // `options.keepNullAttributes` whether attributes with null values will be
        //     kept or ignored: true or false
        // `options.ignoreDecorators` whether decorator strings will be ignored when
        //     converting JS objects: true or false
        // `options.separateArrayItems` whether array items are created as separate
        //     nodes when passed as an object value: true or false
        // `options.noDoubleEncoding` whether existing html entities are encoded:
        //     true or false
        // `options.stringify` a set of functions to use for converting values to
        //     strings
        // `options.writer` the default XML writer to use for converting nodes to
        //     string. If the default writer is not set, the built-in XMLStringWriter
        //     will be used instead.

        // `onData` the function to be called when a new chunk of XML is output. The
        //          string containing the XML chunk is passed to `onData` as its first
        //          argument, and the current indentation level as its second argument.
        // `onEnd`  the function to be called when the XML document is completed with
        //          `end`. `onEnd` does not receive any arguments.
        constructor(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function () {};
          this.onEndCallback = onEnd || function () {};
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }

        // Creates a child element node from the given XMLNode

        // `node` the child node
        createChildNode(node) {
          var att, attName, attributes, child, i, len, ref, ref1;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref = node.attribs;
              for (attName in ref) {
                if (!hasProp.call(ref, attName)) continue;
                att = ref[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error(
                "This XML node type is not supported in a JS object: " +
                  node.constructor.name
              );
          }
          ref1 = node.children;
          // write child nodes recursively
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        }

        // Creates a dummy node

        dummy() {
          // no-op, just return this
          return this;
        }

        // Creates a node

        // `name` name of the node
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        node(name, attributes, text) {
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error(
              "Document can only have one root node. " + this.debugInfo(name)
            );
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          // swap argument order: text <-> attributes
          if (!isObject(attributes)) {
            [text, attributes] = [attributes, text];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        }

        // Creates a child element node or an element type declaration when called
        // inside the DTD

        // `name` name of the node
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        element(name, attributes, text) {
          var child, i, len, oldValidationFlag, ref, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement(...arguments);
          } else {
            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element("TEMP_ROOT");
              root.element(name);
              this.options.noValidation = oldValidationFlag;
              ref = root.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes, text);
            }
          }
          return this;
        }

        // Adds or modifies an attribute

        // `name` attribute name
        // `value` attribute value
        attribute(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error(
              "att() can only be used immediately after an ele() call in callback mode. " +
                this.debugInfo(name)
            );
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            // expand if object
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.currentNode.attribs[name] = new XMLAttribute(
                this,
                name,
                value
              );
            }
          }
          return this;
        }

        // Creates a text node

        // `value` element text
        text(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(
            this.writer.text(node, this.writerOptions, this.currentLevel + 1),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates a CDATA node

        // `value` element text without CDATA delimiters
        cdata(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(
            this.writer.cdata(node, this.writerOptions, this.currentLevel + 1),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates a comment node

        // `value` comment text
        comment(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(
            this.writer.comment(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Adds unescaped raw text

        // `value` text
        raw(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(
            this.writer.raw(node, this.writerOptions, this.currentLevel + 1),
            this.currentLevel + 1
          );
          return this;
        }

        // Adds a processing instruction

        // `target` instruction target
        // `value` instruction value
        instruction(target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            // expand if array
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            // expand if object
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(
              this.writer.processingInstruction(
                node,
                this.writerOptions,
                this.currentLevel + 1
              ),
              this.currentLevel + 1
            );
          }
          return this;
        }

        // Creates the xml declaration

        // `version` A version number string, e.g. 1.0
        // `encoding` Encoding declaration, e.g. UTF-8
        // `standalone` standalone document declaration: true or false
        declaration(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(
            this.writer.declaration(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates the document type declaration

        // `root`  the name of the root node
        // `pubID` the public identifier of the external subset
        // `sysID` the system identifier of the external subset
        doctype(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        }

        // Creates an element type declaration

        // `name` element name
        // `value` element content (defaults to #PCDATA)
        dtdElement(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(
            this.writer.dtdElement(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates an attribute declaration

        // `elementName` the name of the element containing this attribute
        // `attributeName` attribute name
        // `attributeType` type of the attribute (defaults to CDATA)
        // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
        //                    #DEFAULT) (defaults to #IMPLIED)
        // `defaultValue` default value of the attribute
        //                (only used for #FIXED or #DEFAULT)
        attList(
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue
        ) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(
            this,
            elementName,
            attributeName,
            attributeType,
            defaultValueType,
            defaultValue
          );
          this.onData(
            this.writer.dtdAttList(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates a general entity declaration

        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        // `value.nData` notation declaration
        entity(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(
            this.writer.dtdEntity(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates a parameter entity declaration

        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        pEntity(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(
            this.writer.dtdEntity(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Creates a NOTATION declaration

        // `name` the name of the notation
        // `value` an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        notation(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(
            this.writer.dtdNotation(
              node,
              this.writerOptions,
              this.currentLevel + 1
            ),
            this.currentLevel + 1
          );
          return this;
        }

        // Gets the parent node
        up() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        }

        // Ends the document
        end() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        }

        // Opens the current parent node
        openCurrent() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        }

        // Writes the opening tag of the current node or the entire node if it has
        // no child nodes
        openNode(node) {
          var att, chunk, name, ref;
          if (!node.isOpen) {
            if (
              !this.root &&
              this.currentLevel === 0 &&
              node.type === NodeType.Element
            ) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk =
                this.writer.indent(
                  node,
                  this.writerOptions,
                  this.currentLevel
                ) +
                "<" +
                node.name;
              ref = node.attribs;
              for (name in ref) {
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                chunk += this.writer.attribute(
                  att,
                  this.writerOptions,
                  this.currentLevel
                );
              }
              chunk +=
                (node.children ? ">" : "/>") +
                this.writer.endline(
                  node,
                  this.writerOptions,
                  this.currentLevel
                );
              this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk =
                this.writer.indent(
                  node,
                  this.writerOptions,
                  this.currentLevel
                ) +
                "<!DOCTYPE " +
                node.rootNodeName;

              // external identifier
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }

              // internal subset
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(
                node,
                this.writerOptions,
                this.currentLevel
              );
            }
            this.onData(chunk, this.currentLevel);
            return (node.isOpen = true);
          }
        }

        // Writes the closing tag of the current node
        closeNode(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk =
                this.writer.indent(
                  node,
                  this.writerOptions,
                  this.currentLevel
                ) +
                "</" +
                node.name +
                ">" +
                this.writer.endline(
                  node,
                  this.writerOptions,
                  this.currentLevel
                ); // if node.type is NodeType.DocType
            } else {
              chunk =
                this.writer.indent(
                  node,
                  this.writerOptions,
                  this.currentLevel
                ) +
                "]>" +
                this.writer.endline(
                  node,
                  this.writerOptions,
                  this.currentLevel
                );
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return (node.isClosed = true);
          }
        }

        // Called when a new chunk of XML is output

        // `chunk` a string containing the XML chunk
        // `level` current indentation level
        onData(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        }

        // Called when the XML document is completed
        onEnd() {
          this.documentCompleted = true;
          return this.onEndCallback();
        }

        // Returns debug string
        debugInfo(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        }

        // Node aliases
        ele() {
          return this.element(...arguments);
        }

        nod(name, attributes, text) {
          return this.node(name, attributes, text);
        }

        txt(value) {
          return this.text(value);
        }

        dat(value) {
          return this.cdata(value);
        }

        com(value) {
          return this.comment(value);
        }

        ins(target, value) {
          return this.instruction(target, value);
        }

        dec(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        }

        dtd(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        }

        e(name, attributes, text) {
          return this.element(name, attributes, text);
        }

        n(name, attributes, text) {
          return this.node(name, attributes, text);
        }

        t(value) {
          return this.text(value);
        }

        d(value) {
          return this.cdata(value);
        }

        c(value) {
          return this.comment(value);
        }

        r(value) {
          return this.raw(value);
        }

        i(target, value) {
          return this.instruction(target, value);
        }

        // Attribute aliases
        att() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList(...arguments);
          } else {
            return this.attribute(...arguments);
          }
        }

        a() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList(...arguments);
          } else {
            return this.attribute(...arguments);
          }
        }

        // DTD aliases
        // att() and ele() are defined above
        ent(name, value) {
          return this.entity(name, value);
        }

        pent(name, value) {
          return this.pEntity(name, value);
        }

        not(name, value) {
          return this.notation(name, value);
        }
      };
    }).call(this);

    /***/
  },

  /***/ 3590: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLDummy, XMLNode;

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      // Represents a  raw node
      module.exports = XMLDummy = class XMLDummy extends XMLNode {
        // Initializes a new instance of `XMLDummy`

        // `XMLDummy` is a special node representing a node with
        // a null value. Dummy nodes are created while recursively
        // building the XML tree. Simply skipping null values doesn't
        // work because that would break the recursive chain.
        constructor(parent) {
          super(parent);
          this.type = NodeType.Dummy;
        }

        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }

        // Converts the XML fragment to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return "";
        }
      };
    }).call(this);

    /***/
  },

  /***/ 9437: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        XMLAttribute,
        XMLElement,
        XMLNamedNodeMap,
        XMLNode,
        getValue,
        isFunction,
        isObject,
        hasProp = {}.hasOwnProperty;

      ({ isObject, isFunction, getValue } = __nccwpck_require__(8229));

      XMLNode = __nccwpck_require__(7608);

      NodeType = __nccwpck_require__(9267);

      XMLAttribute = __nccwpck_require__(8376);

      XMLNamedNodeMap = __nccwpck_require__(4361);

      // Represents an element of the XML document
      module.exports = XMLElement = function () {
        class XMLElement extends XMLNode {
          // Initializes a new instance of `XMLElement`

          // `parent` the parent node
          // `name` element name
          // `attributes` an object containing name/value pairs of attributes
          constructor(parent, name, attributes) {
            var child, j, len, ref;
            super(parent);
            if (name == null) {
              throw new Error("Missing element name. " + this.debugInfo());
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {};
            this.schemaTypeInfo = null;
            if (attributes != null) {
              this.attribute(attributes);
            }
            // set properties if this is the root node
            if (parent.type === NodeType.Document) {
              this.isRoot = true;
              this.documentObject = parent;
              parent.rootObject = this;
              // set dtd name
              if (parent.children) {
                ref = parent.children;
                for (j = 0, len = ref.length; j < len; j++) {
                  child = ref[j];
                  if (child.type === NodeType.DocType) {
                    child.name = this.name;
                    break;
                  }
                }
              }
            }
          }

          // Creates and returns a deep clone of `this`

          clone() {
            var att, attName, clonedSelf, ref;
            clonedSelf = Object.create(this);
            // remove document element
            if (clonedSelf.isRoot) {
              clonedSelf.documentObject = null;
            }
            // clone attributes
            clonedSelf.attribs = {};
            ref = this.attribs;
            for (attName in ref) {
              if (!hasProp.call(ref, attName)) continue;
              att = ref[attName];
              clonedSelf.attribs[attName] = att.clone();
            }
            // clone child nodes
            clonedSelf.children = [];
            this.children.forEach(function (child) {
              var clonedChild;
              clonedChild = child.clone();
              clonedChild.parent = clonedSelf;
              return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
          }

          // Adds or modifies an attribute

          // `name` attribute name
          // `value` attribute value
          attribute(name, value) {
            var attName, attValue;
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              // expand if object
              for (attName in name) {
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          }

          // Removes an attribute

          // `name` attribute name
          removeAttribute(name) {
            var attName, j, len;
            // Also defined in DOM level 1
            // removeAttribute(name) removes an attribute by name.
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo());
            }
            name = getValue(name);
            if (Array.isArray(name)) {
              // expand if array
              for (j = 0, len = name.length; j < len; j++) {
                attName = name[j];
                delete this.attribs[attName];
              }
            } else {
              delete this.attribs[name];
            }
            return this;
          }

          // Converts the XML fragment to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          // `options.allowEmpty` do not self close empty element tags
          toString(options) {
            return this.options.writer.element(
              this,
              this.options.writer.filterOptions(options)
            );
          }

          // Aliases
          att(name, value) {
            return this.attribute(name, value);
          }

          a(name, value) {
            return this.attribute(name, value);
          }

          // DOM Level 1
          getAttribute(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].value;
            } else {
              return null;
            }
          }

          setAttribute(name, value) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getAttributeNode(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name];
            } else {
              return null;
            }
          }

          setAttributeNode(newAttr) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          removeAttributeNode(oldAttr) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementsByTagName(name) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM Level 2
          getAttributeNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          setAttributeNS(namespaceURI, qualifiedName, value) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          removeAttributeNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getAttributeNodeNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          setAttributeNodeNS(newAttr) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementsByTagNameNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          hasAttribute(name) {
            return this.attribs.hasOwnProperty(name);
          }

          hasAttributeNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM Level 3
          setIdAttribute(name, isId) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].isId;
            } else {
              return isId;
            }
          }

          setIdAttributeNS(namespaceURI, localName, isId) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          setIdAttributeNode(idAttr, isId) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM Level 4
          getElementsByTagName(tagname) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementsByTagNameNS(namespaceURI, localName) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getElementsByClassName(classNames) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          isEqualNode(node) {
            var i, j, ref;
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.attribs.length !== this.attribs.length) {
              return false;
            }
            for (
              i = j = 0, ref = this.attribs.length - 1;
              0 <= ref ? j <= ref : j >= ref;
              i = 0 <= ref ? ++j : --j
            ) {
              if (!this.attribs[i].isEqualNode(node.attribs[i])) {
                return false;
              }
            }
            return true;
          }
        }

        // DOM level 1
        Object.defineProperty(XMLElement.prototype, "tagName", {
          get: function () {
            return this.name;
          },
        });

        // DOM level 4
        Object.defineProperty(XMLElement.prototype, "namespaceURI", {
          get: function () {
            return "";
          },
        });

        Object.defineProperty(XMLElement.prototype, "prefix", {
          get: function () {
            return "";
          },
        });

        Object.defineProperty(XMLElement.prototype, "localName", {
          get: function () {
            return this.name;
          },
        });

        Object.defineProperty(XMLElement.prototype, "id", {
          get: function () {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          },
        });

        Object.defineProperty(XMLElement.prototype, "className", {
          get: function () {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          },
        });

        Object.defineProperty(XMLElement.prototype, "classList", {
          get: function () {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          },
        });

        Object.defineProperty(XMLElement.prototype, "attributes", {
          get: function () {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          },
        });

        return XMLElement;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 4361: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Represents a map of nodes accessed by a string key
      var XMLNamedNodeMap;

      module.exports = XMLNamedNodeMap = function () {
        class XMLNamedNodeMap {
          // Initializes a new instance of `XMLNamedNodeMap`
          // This is just a wrapper around an ordinary
          // JS object.

          // `nodes` the object containing nodes.
          constructor(nodes) {
            this.nodes = nodes;
          }

          // Creates and returns a deep clone of `this`

          clone() {
            // this class should not be cloned since it wraps
            // around a given object. The calling function should check
            // whether the wrapped object is null and supply a new object
            // (from the clone).
            return (this.nodes = null);
          }

          // DOM Level 1
          getNamedItem(name) {
            return this.nodes[name];
          }

          setNamedItem(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
          }

          removeNamedItem(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
          }

          item(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
          }

          // DOM level 2 functions to be implemented later
          getNamedItemNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          }

          setNamedItemNS(node) {
            throw new Error("This DOM method is not implemented.");
          }

          removeNamedItemNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          }
        }

        // DOM level 1
        Object.defineProperty(XMLNamedNodeMap.prototype, "length", {
          get: function () {
            return Object.keys(this.nodes).length || 0;
          },
        });

        return XMLNamedNodeMap;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 7608: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var DocumentPosition,
        NodeType,
        XMLCData,
        XMLComment,
        XMLDeclaration,
        XMLDocType,
        XMLDummy,
        XMLElement,
        XMLNamedNodeMap,
        XMLNode,
        XMLNodeList,
        XMLProcessingInstruction,
        XMLRaw,
        XMLText,
        getValue,
        isEmpty,
        isFunction,
        isObject,
        hasProp = {}.hasOwnProperty,
        splice = [].splice;

      ({ isObject, isFunction, isEmpty, getValue } = __nccwpck_require__(8229));

      XMLElement = null;

      XMLCData = null;

      XMLComment = null;

      XMLDeclaration = null;

      XMLDocType = null;

      XMLRaw = null;

      XMLText = null;

      XMLProcessingInstruction = null;

      XMLDummy = null;

      NodeType = null;

      XMLNodeList = null;

      XMLNamedNodeMap = null;

      DocumentPosition = null;

      // Represents a generic XMl element
      module.exports = XMLNode = function () {
        class XMLNode {
          // Initializes a new instance of `XMLNode`

          // `parent` the parent node
          constructor(parent1) {
            this.parent = parent1;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            // first execution, load dependencies that are otherwise
            // circular (so we can't load them at the top)
            if (!XMLElement) {
              XMLElement = __nccwpck_require__(9437);
              XMLCData = __nccwpck_require__(333);
              XMLComment = __nccwpck_require__(4407);
              XMLDeclaration = __nccwpck_require__(6364);
              XMLDocType = __nccwpck_require__(1801);
              XMLRaw = __nccwpck_require__(6329);
              XMLText = __nccwpck_require__(1318);
              XMLProcessingInstruction = __nccwpck_require__(6939);
              XMLDummy = __nccwpck_require__(3590);
              NodeType = __nccwpck_require__(9267);
              XMLNodeList = __nccwpck_require__(6768);
              XMLNamedNodeMap = __nccwpck_require__(4361);
              DocumentPosition = __nccwpck_require__(2839);
            }
          }

          // Sets the parent node of this node and its children recursively

          // `parent` the parent node
          setParent(parent) {
            var child, j, len, ref1, results;
            this.parent = parent;
            if (parent) {
              this.options = parent.options;
              this.stringify = parent.stringify;
            }
            ref1 = this.children;
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              results.push(child.setParent(this));
            }
            return results;
          }

          // Creates a child element node

          // `name` node name or an object describing the XML tree
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          element(name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, val;
            lastChild = null;
            if (attributes === null && text == null) {
              [attributes, text] = [{}, null];
            }
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            // swap argument order: text <-> attributes
            if (!isObject(attributes)) {
              [text, attributes] = [attributes, text];
            }
            if (name != null) {
              name = getValue(name);
            }
            // expand if array
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                item = name[j];
                lastChild = this.element(item);
              }
              // evaluate if function
            } else if (isFunction(name)) {
              lastChild = this.element(name.apply());
              // expand if object
            } else if (isObject(name)) {
              for (key in name) {
                if (!hasProp.call(name, key)) continue;
                val = name[key];
                if (isFunction(val)) {
                  // evaluate if function
                  val = val.apply();
                }
                // assign attributes
                if (
                  !this.options.ignoreDecorators &&
                  this.stringify.convertAttKey &&
                  key.indexOf(this.stringify.convertAttKey) === 0
                ) {
                  lastChild = this.attribute(
                    key.substr(this.stringify.convertAttKey.length),
                    val
                  );
                  // skip empty arrays
                } else if (
                  !this.options.separateArrayItems &&
                  Array.isArray(val) &&
                  isEmpty(val)
                ) {
                  lastChild = this.dummy();
                  // empty objects produce one node
                } else if (isObject(val) && isEmpty(val)) {
                  lastChild = this.element(key);
                  // skip null and undefined nodes
                } else if (!this.options.keepNullNodes && val == null) {
                  lastChild = this.dummy();

                  // expand list by creating child nodes
                } else if (
                  !this.options.separateArrayItems &&
                  Array.isArray(val)
                ) {
                  for (k = 0, len1 = val.length; k < len1; k++) {
                    item = val[k];
                    childNode = {};
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                  }

                  // expand child nodes under parent
                } else if (isObject(val)) {
                  // if the key is #text expand child nodes under this node to support mixed content
                  if (
                    !this.options.ignoreDecorators &&
                    this.stringify.convertTextKey &&
                    key.indexOf(this.stringify.convertTextKey) === 0
                  ) {
                    lastChild = this.element(val);
                  } else {
                    lastChild = this.element(key);
                    lastChild.element(val);
                  }
                } else {
                  // text node
                  lastChild = this.element(key, val);
                }
              }
              // skip null nodes
            } else if (!this.options.keepNullNodes && text === null) {
              lastChild = this.dummy();
            } else {
              // text node
              if (
                !this.options.ignoreDecorators &&
                this.stringify.convertTextKey &&
                name.indexOf(this.stringify.convertTextKey) === 0
              ) {
                lastChild = this.text(text);
                // cdata node
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertCDataKey &&
                name.indexOf(this.stringify.convertCDataKey) === 0
              ) {
                lastChild = this.cdata(text);
                // comment node
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertCommentKey &&
                name.indexOf(this.stringify.convertCommentKey) === 0
              ) {
                lastChild = this.comment(text);
                // raw text node
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertRawKey &&
                name.indexOf(this.stringify.convertRawKey) === 0
              ) {
                lastChild = this.raw(text);
                // processing instruction
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertPIKey &&
                name.indexOf(this.stringify.convertPIKey) === 0
              ) {
                lastChild = this.instruction(
                  name.substr(this.stringify.convertPIKey.length),
                  text
                );
              } else {
                // element node
                lastChild = this.node(name, attributes, text);
              }
            }
            if (lastChild == null) {
              throw new Error(
                "Could not create any elements with: " +
                  name +
                  ". " +
                  this.debugInfo()
              );
            }
            return lastChild;
          }

          // Creates a child element node before the current node

          // `name` node name or an object describing the XML tree
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          insertBefore(name, attributes, text) {
            var child, i, newChild, refChild, removed;
            // DOM level 1
            // insertBefore(newChild, refChild) inserts the child node newChild before refChild
            if (name != null ? name.type : void 0) {
              newChild = name;
              refChild = attributes;
              newChild.setParent(this);
              if (refChild) {
                // temporarily remove children starting *with* refChild
                i = children.indexOf(refChild);
                removed = children.splice(i);

                // add the new child
                children.push(newChild);

                // add back removed children after new child
                Array.prototype.push.apply(children, removed);
              } else {
                children.push(newChild);
              }
              return newChild;
            } else {
              if (this.isRoot) {
                throw new Error(
                  "Cannot insert elements at root level. " +
                    this.debugInfo(name)
                );
              }

              // temporarily remove children starting *with* this
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);

              // add the new child
              child = this.parent.element(name, attributes, text);

              // add back removed children after new child
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            }
          }

          // Creates a child element node after the current node

          // `name` node name or an object describing the XML tree
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          insertAfter(name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) {
              throw new Error(
                "Cannot insert elements at root level. " + this.debugInfo(name)
              );
            }

            // temporarily remove children starting *after* this
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);

            // add the new child
            child = this.parent.element(name, attributes, text);

            // add back removed children after new child
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }

          // Deletes a child element node

          remove() {
            var i, ref1;
            if (this.isRoot) {
              throw new Error(
                "Cannot remove the root element. " + this.debugInfo()
              );
            }
            i = this.parent.children.indexOf(this);
            splice.apply(
              this.parent.children,
              [i, i - i + 1].concat((ref1 = []))
            ),
              ref1;
            return this.parent;
          }

          // Creates a node

          // `name` name of the node
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          node(name, attributes, text) {
            var child;
            if (name != null) {
              name = getValue(name);
            }
            attributes || (attributes = {});
            attributes = getValue(attributes);
            // swap argument order: text <-> attributes
            if (!isObject(attributes)) {
              [text, attributes] = [attributes, text];
            }
            child = new XMLElement(this, name, attributes);
            if (text != null) {
              child.text(text);
            }
            this.children.push(child);
            return child;
          }

          // Creates a text node

          // `value` element text
          text(value) {
            var child;
            if (isObject(value)) {
              this.element(value);
            }
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
          }

          // Creates a CDATA node

          // `value` element text without CDATA delimiters
          cdata(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
          }

          // Creates a comment node

          // `value` comment text
          comment(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
          }

          // Creates a comment node before the current node

          // `value` comment text
          commentBefore(value) {
            var child, i, removed;
            // temporarily remove children starting *with* this
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            // add the new child
            child = this.parent.comment(value);
            // add back removed children after new child
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }

          // Creates a comment node after the current node

          // `value` comment text
          commentAfter(value) {
            var child, i, removed;
            // temporarily remove children starting *after* this
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            // add the new child
            child = this.parent.comment(value);
            // add back removed children after new child
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }

          // Adds unescaped raw text

          // `value` text
          raw(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
          }

          // Adds a dummy node
          dummy() {
            var child;
            child = new XMLDummy(this);
            // Normally when a new node is created it is added to the child node collection.
            // However, dummy nodes are never added to the XML tree. They are created while
            // converting JS objects to XML nodes in order not to break the recursive function
            // chain. They can be thought of as invisible nodes. They can be traversed through
            // by using prev(), next(), up(), etc. functions but they do not exists in the tree.

            // @children.push child
            return child;
          }

          // Adds a processing instruction

          // `target` instruction target
          // `value` instruction value
          instruction(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              // expand if array
              for (j = 0, len = target.length; j < len; j++) {
                insTarget = target[j];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              // expand if object
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              instruction = new XMLProcessingInstruction(this, target, value);
              this.children.push(instruction);
            }
            return this;
          }

          // Creates a processing instruction node before the current node

          // `target` instruction target
          // `value` instruction value
          instructionBefore(target, value) {
            var child, i, removed;
            // temporarily remove children starting *with* this
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            // add the new child
            child = this.parent.instruction(target, value);
            // add back removed children after new child
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }

          // Creates a processing instruction node after the current node

          // `target` instruction target
          // `value` instruction value
          instructionAfter(target, value) {
            var child, i, removed;
            // temporarily remove children starting *after* this
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            // add the new child
            child = this.parent.instruction(target, value);
            // add back removed children after new child
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }

          // Creates the xml declaration

          // `version` A version number string, e.g. 1.0
          // `encoding` Encoding declaration, e.g. UTF-8
          // `standalone` standalone document declaration: true or false
          declaration(version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            // Replace XML declaration if exists, otherwise insert at top
            if (doc.children.length === 0) {
              doc.children.unshift(xmldec);
            } else if (doc.children[0].type === NodeType.Declaration) {
              doc.children[0] = xmldec;
            } else {
              doc.children.unshift(xmldec);
            }
            return doc.root() || doc;
          }

          // Creates the document type declaration

          // `pubID` the public identifier of the external subset
          // `sysID` the system identifier of the external subset
          dtd(pubID, sysID) {
            var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref1 = doc.children;
            // Replace DTD if exists
            for (i = j = 0, len = ref1.length; j < len; i = ++j) {
              child = ref1[i];
              if (child.type === NodeType.DocType) {
                doc.children[i] = doctype;
                return doctype;
              }
            }
            ref2 = doc.children;
            // insert before root node if the root node exists
            for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
              child = ref2[i];
              if (child.isRoot) {
                doc.children.splice(i, 0, doctype);
                return doctype;
              }
            }
            // otherwise append to end
            doc.children.push(doctype);
            return doctype;
          }

          // Gets the parent node
          up() {
            if (this.isRoot) {
              throw new Error(
                "The root node has no parent. Use doc() if you need to get the document object."
              );
            }
            return this.parent;
          }

          // Gets the root node
          root() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node.rootObject;
              } else if (node.isRoot) {
                return node;
              } else {
                node = node.parent;
              }
            }
          }

          // Gets the node representing the XML document
          document() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node;
              } else {
                node = node.parent;
              }
            }
          }

          // Ends the document and converts string
          end(options) {
            return this.document().end(options);
          }

          // Gets the previous node
          prev() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i < 1) {
              throw new Error("Already at the first node. " + this.debugInfo());
            }
            return this.parent.children[i - 1];
          }

          // Gets the next node
          next() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i === -1 || i === this.parent.children.length - 1) {
              throw new Error("Already at the last node. " + this.debugInfo());
            }
            return this.parent.children[i + 1];
          }

          // Imports cloned root from another XML document

          // `doc` the XML document to insert nodes from
          importDocument(doc) {
            var child, clonedRoot, j, len, ref1;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            // set properties if imported element becomes the root node
            if (this.type === NodeType.Document) {
              clonedRoot.isRoot = true;
              clonedRoot.documentObject = this;
              this.rootObject = clonedRoot;
              // set dtd name
              if (this.children) {
                ref1 = this.children;
                for (j = 0, len = ref1.length; j < len; j++) {
                  child = ref1[j];
                  if (child.type === NodeType.DocType) {
                    child.name = clonedRoot.name;
                    break;
                  }
                }
              }
            }
            return this;
          }

          // Returns debug string for this node
          debugInfo(name) {
            var ref1, ref2;
            name = name || this.name;
            if (
              name == null &&
              !((ref1 = this.parent) != null ? ref1.name : void 0)
            ) {
              return "";
            } else if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {
              return "node: <" + name + ">";
            } else {
              return "node: <" + name + ">, parent: <" + this.parent.name + ">";
            }
          }

          // Aliases
          ele(name, attributes, text) {
            return this.element(name, attributes, text);
          }

          nod(name, attributes, text) {
            return this.node(name, attributes, text);
          }

          txt(value) {
            return this.text(value);
          }

          dat(value) {
            return this.cdata(value);
          }

          com(value) {
            return this.comment(value);
          }

          ins(target, value) {
            return this.instruction(target, value);
          }

          doc() {
            return this.document();
          }

          dec(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          }

          e(name, attributes, text) {
            return this.element(name, attributes, text);
          }

          n(name, attributes, text) {
            return this.node(name, attributes, text);
          }

          t(value) {
            return this.text(value);
          }

          d(value) {
            return this.cdata(value);
          }

          c(value) {
            return this.comment(value);
          }

          r(value) {
            return this.raw(value);
          }

          i(target, value) {
            return this.instruction(target, value);
          }

          u() {
            return this.up();
          }

          // can be deprecated in a future release
          importXMLBuilder(doc) {
            return this.importDocument(doc);
          }

          // Adds or modifies an attribute.

          // `name` attribute name
          // `value` attribute value
          attribute(name, value) {
            throw new Error("attribute() applies to element nodes only.");
          }

          att(name, value) {
            return this.attribute(name, value);
          }

          a(name, value) {
            return this.attribute(name, value);
          }

          // Removes an attribute

          // `name` attribute name
          removeAttribute(name) {
            throw new Error("attribute() applies to element nodes only.");
          }

          // DOM level 1 functions to be implemented later
          replaceChild(newChild, oldChild) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          removeChild(oldChild) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          appendChild(newChild) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          hasChildNodes() {
            return this.children.length !== 0;
          }

          cloneNode(deep) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          normalize() {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM level 2
          isSupported(feature, version) {
            return true;
          }

          hasAttributes() {
            return this.attribs.length !== 0;
          }

          // DOM level 3 functions to be implemented later
          compareDocumentPosition(other) {
            var ref, res;
            ref = this;
            if (ref === other) {
              return 0;
            } else if (this.document() !== other.document()) {
              res =
                DocumentPosition.Disconnected |
                DocumentPosition.ImplementationSpecific;
              if (Math.random() < 0.5) {
                res |= DocumentPosition.Preceding;
              } else {
                res |= DocumentPosition.Following;
              }
              return res;
            } else if (ref.isAncestor(other)) {
              return DocumentPosition.Contains | DocumentPosition.Preceding;
            } else if (ref.isDescendant(other)) {
              return DocumentPosition.Contains | DocumentPosition.Following;
            } else if (ref.isPreceding(other)) {
              return DocumentPosition.Preceding;
            } else {
              return DocumentPosition.Following;
            }
          }

          isSameNode(other) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          lookupPrefix(namespaceURI) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          isDefaultNamespace(namespaceURI) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          lookupNamespaceURI(prefix) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          isEqualNode(node) {
            var i, j, ref1;
            if (node.nodeType !== this.nodeType) {
              return false;
            }
            if (node.children.length !== this.children.length) {
              return false;
            }
            for (
              i = j = 0, ref1 = this.children.length - 1;
              0 <= ref1 ? j <= ref1 : j >= ref1;
              i = 0 <= ref1 ? ++j : --j
            ) {
              if (!this.children[i].isEqualNode(node.children[i])) {
                return false;
              }
            }
            return true;
          }

          getFeature(feature, version) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          setUserData(key, data, handler) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          getUserData(key) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // Returns true if other is an inclusive descendant of node,
          // and false otherwise.
          contains(other) {
            if (!other) {
              return false;
            }
            return other === this || this.isDescendant(other);
          }

          // An object A is called a descendant of an object B, if either A is
          // a child of B or A is a child of an object C that is a descendant of B.
          isDescendant(node) {
            var child, isDescendantChild, j, len, ref1;
            ref1 = this.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if (node === child) {
                return true;
              }
              isDescendantChild = child.isDescendant(node);
              if (isDescendantChild) {
                return true;
              }
            }
            return false;
          }

          // An object A is called an ancestor of an object B if and only if
          // B is a descendant of A.
          isAncestor(node) {
            return node.isDescendant(this);
          }

          // An object A is preceding an object B if A and B are in the
          // same tree and A comes before B in tree order.
          isPreceding(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos < thisPos;
            }
          }

          // An object A is folllowing an object B if A and B are in the
          // same tree and A comes after B in tree order.
          isFollowing(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos > thisPos;
            }
          }

          // Returns the preorder position of the given node in the tree, or -1
          // if the node is not in the tree.
          treePosition(node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function (childNode) {
              pos++;
              if (!found && childNode === node) {
                return (found = true);
              }
            });
            if (found) {
              return pos;
            } else {
              return -1;
            }
          }

          // Depth-first preorder traversal through the XML tree
          foreachTreeNode(node, func) {
            var child, j, len, ref1, res;
            node || (node = this.document());
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if ((res = func(child))) {
                return res;
              } else {
                res = this.foreachTreeNode(child, func);
                if (res) {
                  return res;
                }
              }
            }
          }
        }

        // DOM level 1
        Object.defineProperty(XMLNode.prototype, "nodeName", {
          get: function () {
            return this.name;
          },
        });

        Object.defineProperty(XMLNode.prototype, "nodeType", {
          get: function () {
            return this.type;
          },
        });

        Object.defineProperty(XMLNode.prototype, "nodeValue", {
          get: function () {
            return this.value;
          },
        });

        Object.defineProperty(XMLNode.prototype, "parentNode", {
          get: function () {
            return this.parent;
          },
        });

        Object.defineProperty(XMLNode.prototype, "childNodes", {
          get: function () {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          },
        });

        Object.defineProperty(XMLNode.prototype, "firstChild", {
          get: function () {
            return this.children[0] || null;
          },
        });

        Object.defineProperty(XMLNode.prototype, "lastChild", {
          get: function () {
            return this.children[this.children.length - 1] || null;
          },
        });

        Object.defineProperty(XMLNode.prototype, "previousSibling", {
          get: function () {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i - 1] || null;
          },
        });

        Object.defineProperty(XMLNode.prototype, "nextSibling", {
          get: function () {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i + 1] || null;
          },
        });

        Object.defineProperty(XMLNode.prototype, "ownerDocument", {
          get: function () {
            return this.document() || null;
          },
        });

        // DOM level 3
        Object.defineProperty(XMLNode.prototype, "textContent", {
          get: function () {
            var child, j, len, ref1, str;
            if (
              this.nodeType === NodeType.Element ||
              this.nodeType === NodeType.DocumentFragment
            ) {
              str = "";
              ref1 = this.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function (value) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          },
        });

        return XMLNode;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 6768: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Represents a list of nodes
      var XMLNodeList;

      module.exports = XMLNodeList = function () {
        class XMLNodeList {
          // Initializes a new instance of `XMLNodeList`
          // This is just a wrapper around an ordinary
          // JS array.

          // `nodes` the array containing nodes.
          constructor(nodes) {
            this.nodes = nodes;
          }

          // Creates and returns a deep clone of `this`

          clone() {
            // this class should not be cloned since it wraps
            // around a given array. The calling function should check
            // whether the wrapped array is null and supply a new array
            // (from the clone).
            return (this.nodes = null);
          }

          // DOM Level 1
          item(index) {
            return this.nodes[index] || null;
          }
        }

        // DOM level 1
        Object.defineProperty(XMLNodeList.prototype, "length", {
          get: function () {
            return this.nodes.length || 0;
          },
        });

        return XMLNodeList;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 6939: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLCharacterData, XMLProcessingInstruction;

      NodeType = __nccwpck_require__(9267);

      XMLCharacterData = __nccwpck_require__(7709);

      // Represents a processing instruction
      module.exports =
        XMLProcessingInstruction = class XMLProcessingInstruction extends (
          XMLCharacterData
        ) {
          // Initializes a new instance of `XMLProcessingInstruction`

          // `parent` the parent node
          // `target` instruction target
          // `value` instruction value
          constructor(parent, target, value) {
            super(parent);
            if (target == null) {
              throw new Error(
                "Missing instruction target. " + this.debugInfo()
              );
            }
            this.type = NodeType.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) {
              this.value = this.stringify.insValue(value);
            }
          }

          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }

          // Converts the XML fragment to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.processingInstruction(
              this,
              this.options.writer.filterOptions(options)
            );
          }

          isEqualNode(node) {
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.target !== this.target) {
              return false;
            }
            return true;
          }
        };
    }).call(this);

    /***/
  },

  /***/ 6329: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLNode, XMLRaw;

      NodeType = __nccwpck_require__(9267);

      XMLNode = __nccwpck_require__(7608);

      // Represents a  raw node
      module.exports = XMLRaw = class XMLRaw extends XMLNode {
        // Initializes a new instance of `XMLRaw`

        // `text` raw text
        constructor(parent, text) {
          super(parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }

        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }

        // Converts the XML fragment to string

        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.raw(
            this,
            this.options.writer.filterOptions(options)
          );
        }
      };
    }).call(this);

    /***/
  },

  /***/ 8601: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        WriterState,
        XMLStreamWriter,
        XMLWriterBase,
        hasProp = {}.hasOwnProperty;

      NodeType = __nccwpck_require__(9267);

      XMLWriterBase = __nccwpck_require__(6752);

      WriterState = __nccwpck_require__(9766);

      // Prints XML nodes to a stream
      module.exports = XMLStreamWriter = class XMLStreamWriter extends (
        XMLWriterBase
      ) {
        // Initializes a new instance of `XMLStreamWriter`

        // `stream` output stream
        // `options.pretty` pretty prints the result
        // `options.indent` indentation string
        // `options.newline` newline sequence
        // `options.offset` a fixed number of indentations to add to every line
        // `options.allowEmpty` do not self close empty element tags
        // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
        // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
        constructor(stream, options) {
          super(options);
          this.stream = stream;
        }

        endline(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return super.endline(node, options, level);
          }
        }

        document(doc, options) {
          var child, i, j, k, len1, len2, ref, ref1, results;
          ref = doc.children;
          // set a flag so that we don't insert a newline after the last root level node
          for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
            child = ref[i];
            child.isLastRootNode = i === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        }

        cdata(node, options, level) {
          return this.stream.write(super.cdata(node, options, level));
        }

        comment(node, options, level) {
          return this.stream.write(super.comment(node, options, level));
        }

        declaration(node, options, level) {
          return this.stream.write(super.declaration(node, options, level));
        }

        docType(node, options, level) {
          var child, j, len1, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          // external identifier
          if (node.pubID && node.sysID) {
            this.stream.write(
              ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"'
            );
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          // internal subset
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len1 = ref.length; j < len1; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          // close tag
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        }

        element(node, options, level) {
          var att,
            attLen,
            child,
            childNodeCount,
            firstChildNode,
            j,
            len,
            len1,
            name,
            prettySuppressed,
            r,
            ratt,
            ref,
            ref1,
            ref2,
            rline;
          level || (level = 0);
          // open tag
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<" + node.name;
          // attributes
          if (options.pretty && options.width > 0) {
            len = r.length;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              ratt = this.attribute(att, options, level);
              attLen = ratt.length;
              if (len + attLen > options.width) {
                rline = this.indent(node, options, level + 1) + ratt;
                r += this.endline(node, options, level) + rline;
                len = rline.length;
              } else {
                rline = " " + ratt;
                r += rline;
                len += rline.length;
              }
            }
          } else {
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name)) continue;
              att = ref1[name];
              r += this.attribute(att, options, level);
            }
          }
          this.stream.write(r);
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (
            childNodeCount === 0 ||
            node.children.every(function (e) {
              return (
                (e.type === NodeType.Text ||
                  e.type === NodeType.Raw ||
                  e.type === NodeType.CData) &&
                e.value === ""
              );
            })
          ) {
            // empty element
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (
            options.pretty &&
            childNodeCount === 1 &&
            (firstChildNode.type === NodeType.Text ||
              firstChildNode.type === NodeType.Raw ||
              firstChildNode.type === NodeType.CData) &&
            firstChildNode.value != null
          ) {
            // do not indent text-only nodes
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            // inner tags
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              this.writeChildNode(child, options, level + 1);
            }
            // close tag
            options.state = WriterState.CloseTag;
            this.stream.write(
              this.indent(node, options, level) + "</" + node.name + ">"
            );
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        }

        processingInstruction(node, options, level) {
          return this.stream.write(
            super.processingInstruction(node, options, level)
          );
        }

        raw(node, options, level) {
          return this.stream.write(super.raw(node, options, level));
        }

        text(node, options, level) {
          return this.stream.write(super.text(node, options, level));
        }

        dtdAttList(node, options, level) {
          return this.stream.write(super.dtdAttList(node, options, level));
        }

        dtdElement(node, options, level) {
          return this.stream.write(super.dtdElement(node, options, level));
        }

        dtdEntity(node, options, level) {
          return this.stream.write(super.dtdEntity(node, options, level));
        }

        dtdNotation(node, options, level) {
          return this.stream.write(super.dtdNotation(node, options, level));
        }
      };
    }).call(this);

    /***/
  },

  /***/ 5913: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var XMLStringWriter, XMLWriterBase;

      XMLWriterBase = __nccwpck_require__(6752);

      // Prints XML nodes as plain text
      module.exports = XMLStringWriter = class XMLStringWriter extends (
        XMLWriterBase
      ) {
        // Initializes a new instance of `XMLStringWriter`

        // `options.pretty` pretty prints the result
        // `options.indent` indentation string
        // `options.newline` newline sequence
        // `options.offset` a fixed number of indentations to add to every line
        // `options.allowEmpty` do not self close empty element tags
        // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
        // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
        constructor(options) {
          super(options);
        }

        document(doc, options) {
          var child, i, len, r, ref;
          options = this.filterOptions(options);
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, 0);
          }
          // remove trailing newline
          if (
            options.pretty &&
            r.slice(-options.newline.length) === options.newline
          ) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        }
      };
    }).call(this);

    /***/
  },

  /***/ 8594: /***/ function (module) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      // Converts values to strings
      var XMLStringifier,
        hasProp = {}.hasOwnProperty;

      module.exports = XMLStringifier = function () {
        class XMLStringifier {
          // Initializes a new instance of `XMLStringifier`

          // `options.version` The version number string of the XML spec to validate against, e.g. 1.0
          // `options.noDoubleEncoding` whether existing html entities are encoded: true or false
          // `options.stringify` a set of functions to use for converting values to strings
          // `options.noValidation` whether values will be validated and escaped or returned as is
          // `options.invalidCharReplacement` a character to replace invalid characters and disable character validation
          constructor(options) {
            var key, ref, value;
            // Checks whether the given string contains legal characters
            // Fails with an exception on error

            // `str` the string to check
            this.assertLegalChar = this.assertLegalChar.bind(this);
            // Checks whether the given string contains legal characters for a name
            // Fails with an exception on error

            // `str` the string to check
            this.assertLegalName = this.assertLegalName.bind(this);
            options || (options = {});
            this.options = options;
            if (!this.options.version) {
              this.options.version = "1.0";
            }
            ref = options.stringify || {};
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this[key] = value;
            }
          }

          // Defaults
          name(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalName("" + val || "");
          }

          text(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.textEscape("" + val || ""));
          }

          cdata(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            val = val.replace("]]>", "]]]]><![CDATA[>");
            return this.assertLegalChar(val);
          }

          comment(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/--/)) {
              throw new Error(
                "Comment text cannot contain double-hypen: " + val
              );
            }
            return this.assertLegalChar(val);
          }

          raw(val) {
            if (this.options.noValidation) {
              return val;
            }
            return "" + val || "";
          }

          attValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.attEscape((val = "" + val || "")));
          }

          insTarget(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          insValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/\?>/)) {
              throw new Error("Invalid processing instruction value: " + val);
            }
            return this.assertLegalChar(val);
          }

          xmlVersion(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/1\.[0-9]+/)) {
              throw new Error("Invalid version number: " + val);
            }
            return val;
          }

          xmlEncoding(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
              throw new Error("Invalid encoding: " + val);
            }
            return this.assertLegalChar(val);
          }

          xmlStandalone(val) {
            if (this.options.noValidation) {
              return val;
            }
            if (val) {
              return "yes";
            } else {
              return "no";
            }
          }

          dtdPubID(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          dtdSysID(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          dtdElementValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          dtdAttType(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          dtdAttDefault(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          dtdEntityValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          dtdNData(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }

          assertLegalChar(str) {
            var regex, res;
            if (this.options.noValidation) {
              return str;
            }
            if (this.options.version === "1.0") {
              // Valid characters from https://www.w3.org/TR/xml/#charsets
              // any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
              // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
              // This ES5 compatible Regexp has been generated using the "regenerate" NPM module:
              //   let xml_10_InvalidChars = regenerate()
              //     .addRange(0x0000, 0x0008)
              //     .add(0x000B, 0x000C)
              //     .addRange(0x000E, 0x001F)
              //     .addRange(0xD800, 0xDFFF)
              //     .addRange(0xFFFE, 0xFFFF)
              regex =
                /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;
              if (this.options.invalidCharReplacement !== void 0) {
                str = str.replace(regex, this.options.invalidCharReplacement);
              } else if ((res = str.match(regex))) {
                throw new Error(
                  `Invalid character in string: ${str} at index ${res.index}`
                );
              }
            } else if (this.options.version === "1.1") {
              // Valid characters from https://www.w3.org/TR/xml11/#charsets
              // any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
              // [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
              // This ES5 compatible Regexp has been generated using the "regenerate" NPM module:
              //   let xml_11_InvalidChars = regenerate()
              //     .add(0x0000)
              //     .addRange(0xD800, 0xDFFF)
              //     .addRange(0xFFFE, 0xFFFF)
              regex =
                /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;
              if (this.options.invalidCharReplacement !== void 0) {
                str = str.replace(regex, this.options.invalidCharReplacement);
              } else if ((res = str.match(regex))) {
                throw new Error(
                  `Invalid character in string: ${str} at index ${res.index}`
                );
              }
            }
            return str;
          }

          assertLegalName(str) {
            var regex;
            if (this.options.noValidation) {
              return str;
            }
            str = this.assertLegalChar(str);
            regex =
              /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) {
              throw new Error(`Invalid character in name: ${str}`);
            }
            return str;
          }

          // Escapes special characters in text

          // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping

          // `str` the string to escape
          textEscape(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding
              ? /(?!&(lt|gt|amp|apos|quot);)&/g
              : /&/g;
            return str
              .replace(ampregex, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/\r/g, "&#xD;");
          }

          // Escapes special characters in attribute values

          // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping

          // `str` the string to escape
          attEscape(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding
              ? /(?!&(lt|gt|amp|apos|quot);)&/g
              : /&/g;
            return str
              .replace(ampregex, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/"/g, "&quot;")
              .replace(/\t/g, "&#x9;")
              .replace(/\n/g, "&#xA;")
              .replace(/\r/g, "&#xD;");
          }
        }

        // strings to match while converting from JS objects
        XMLStringifier.prototype.convertAttKey = "@";

        XMLStringifier.prototype.convertPIKey = "?";

        XMLStringifier.prototype.convertTextKey = "#text";

        XMLStringifier.prototype.convertCDataKey = "#cdata";

        XMLStringifier.prototype.convertCommentKey = "#comment";

        XMLStringifier.prototype.convertRawKey = "#raw";

        return XMLStringifier;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 1318: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType, XMLCharacterData, XMLText;

      NodeType = __nccwpck_require__(9267);

      XMLCharacterData = __nccwpck_require__(7709);

      // Represents a text node
      module.exports = XMLText = function () {
        class XMLText extends XMLCharacterData {
          // Initializes a new instance of `XMLText`

          // `text` element text
          constructor(parent, text) {
            super(parent);
            if (text == null) {
              throw new Error("Missing element text. " + this.debugInfo());
            }
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
          }

          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }

          // Converts the XML fragment to string

          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.text(
              this,
              this.options.writer.filterOptions(options)
            );
          }

          // DOM level 1 functions to be implemented later
          splitText(offset) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }

          // DOM level 3 functions to be implemented later
          replaceWholeText(content) {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          }
        }

        // DOM level 3
        Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", {
          get: function () {
            throw new Error(
              "This DOM method is not implemented." + this.debugInfo()
            );
          },
        });

        Object.defineProperty(XMLText.prototype, "wholeText", {
          get: function () {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          },
        });

        return XMLText;
      }.call(this);
    }).call(this);

    /***/
  },

  /***/ 6752: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        WriterState,
        XMLCData,
        XMLComment,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDeclaration,
        XMLDocType,
        XMLDummy,
        XMLElement,
        XMLProcessingInstruction,
        XMLRaw,
        XMLText,
        XMLWriterBase,
        assign,
        hasProp = {}.hasOwnProperty;

      ({ assign } = __nccwpck_require__(8229));

      NodeType = __nccwpck_require__(9267);

      XMLDeclaration = __nccwpck_require__(6364);

      XMLDocType = __nccwpck_require__(1801);

      XMLCData = __nccwpck_require__(333);

      XMLComment = __nccwpck_require__(4407);

      XMLElement = __nccwpck_require__(9437);

      XMLRaw = __nccwpck_require__(6329);

      XMLText = __nccwpck_require__(1318);

      XMLProcessingInstruction = __nccwpck_require__(6939);

      XMLDummy = __nccwpck_require__(3590);

      XMLDTDAttList = __nccwpck_require__(1015);

      XMLDTDElement = __nccwpck_require__(2421);

      XMLDTDEntity = __nccwpck_require__(53);

      XMLDTDNotation = __nccwpck_require__(2837);

      WriterState = __nccwpck_require__(9766);

      // Base class for XML writers
      module.exports = XMLWriterBase = class XMLWriterBase {
        // Initializes a new instance of `XMLWriterBase`

        // `options.pretty` pretty prints the result
        // `options.indent` indentation string
        // `options.newline` newline sequence
        // `options.offset` a fixed number of indentations to add to every line
        // `options.width` maximum column width
        // `options.allowEmpty` do not self close empty element tags
        // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
        // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
        constructor(options) {
          var key, ref, value;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this["_" + key] = this[key];
            this[key] = value;
          }
        }

        // Filters writer options and provides defaults

        // `options` writer options
        filterOptions(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this,
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline =
            (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.width = (ref3 = options.width) != null ? ref3 : 0;
          filteredOptions.dontPrettyTextNodes =
            (ref4 =
              (ref5 = options.dontPrettyTextNodes) != null
                ? ref5
                : options.dontprettytextnodes) != null
              ? ref4
              : 0;
          filteredOptions.spaceBeforeSlash =
            (ref6 =
              (ref7 = options.spaceBeforeSlash) != null
                ? ref7
                : options.spacebeforeslash) != null
              ? ref6
              : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        }

        // Returns the indentation string for the current level

        // `node` current node
        // `options` writer options
        // `level` current indentation level
        indent(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        }

        // Returns the newline string

        // `node` current node
        // `options` writer options
        // `level` current indentation level
        endline(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        }

        attribute(att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          if (options.pretty && options.width > 0) {
            r = att.name + '="' + att.value + '"';
          } else {
            r = " " + att.name + '="' + att.value + '"';
          }
          this.closeAttribute(att, options, level);
          return r;
        }

        cdata(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        comment(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        declaration(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        docType(node, options, level) {
          var child, i, len1, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += "<!DOCTYPE " + node.root().name;
          // external identifier
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          // internal subset
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i = 0, len1 = ref.length; i < len1; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += "]";
          }
          // close tag
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        element(node, options, level) {
          var att,
            attLen,
            child,
            childNodeCount,
            firstChildNode,
            i,
            j,
            len,
            len1,
            len2,
            name,
            prettySuppressed,
            r,
            ratt,
            ref,
            ref1,
            ref2,
            ref3,
            rline;
          level || (level = 0);
          prettySuppressed = false;
          // open tag
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<" + node.name;
          // attributes
          if (options.pretty && options.width > 0) {
            len = r.length;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              ratt = this.attribute(att, options, level);
              attLen = ratt.length;
              if (len + attLen > options.width) {
                rline = this.indent(node, options, level + 1) + ratt;
                r += this.endline(node, options, level) + rline;
                len = rline.length;
              } else {
                rline = " " + ratt;
                r += rline;
                len += rline.length;
              }
            }
          } else {
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name)) continue;
              att = ref1[name];
              r += this.attribute(att, options, level);
            }
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (
            childNodeCount === 0 ||
            node.children.every(function (e) {
              return (
                (e.type === NodeType.Text ||
                  e.type === NodeType.Raw ||
                  e.type === NodeType.CData) &&
                e.value === ""
              );
            })
          ) {
            // empty element
            if (options.allowEmpty) {
              r += ">";
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r +=
                options.spaceBeforeSlash +
                "/>" +
                this.endline(node, options, level);
            }
          } else if (
            options.pretty &&
            childNodeCount === 1 &&
            (firstChildNode.type === NodeType.Text ||
              firstChildNode.type === NodeType.Raw ||
              firstChildNode.type === NodeType.CData) &&
            firstChildNode.value != null
          ) {
            // do not indent text-only nodes
            r += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            // if ANY are a text node, then suppress pretty now
            if (options.dontPrettyTextNodes) {
              ref2 = node.children;
              for (i = 0, len1 = ref2.length; i < len1; i++) {
                child = ref2[i];
                if (
                  (child.type === NodeType.Text ||
                    child.type === NodeType.Raw ||
                    child.type === NodeType.CData) &&
                  child.value != null
                ) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            // close the opening tag, after dealing with newline
            r += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref3 = node.children;
            // inner tags
            for (j = 0, len2 = ref3.length; j < len2; j++) {
              child = ref3[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            // close tag
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        }

        writeChildNode(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error(
                "Unknown XML node type: " + node.constructor.name
              );
          }
        }

        processingInstruction(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        raw(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        text(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        dtdAttList(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r +=
            " " +
            node.elementName +
            " " +
            node.attributeName +
            " " +
            node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r +=
            options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        dtdElement(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r +=
            options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        dtdEntity(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r +=
            options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        dtdNotation(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r +=
            options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }

        openNode(node, options, level) {}

        closeNode(node, options, level) {}

        openAttribute(att, options, level) {}

        closeAttribute(att, options, level) {}
      };
    }).call(this);

    /***/
  },

  /***/ 2958: /***/ function (
    module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) {
    // Generated by CoffeeScript 2.4.1
    (function () {
      var NodeType,
        WriterState,
        XMLDOMImplementation,
        XMLDocument,
        XMLDocumentCB,
        XMLStreamWriter,
        XMLStringWriter,
        assign,
        isFunction;

      ({ assign, isFunction } = __nccwpck_require__(8229));

      XMLDOMImplementation = __nccwpck_require__(8310);

      XMLDocument = __nccwpck_require__(3730);

      XMLDocumentCB = __nccwpck_require__(7356);

      XMLStringWriter = __nccwpck_require__(5913);

      XMLStreamWriter = __nccwpck_require__(8601);

      NodeType = __nccwpck_require__(9267);

      WriterState = __nccwpck_require__(9766);

      // Creates a new document and returns the root node for
      // chain-building the document tree

      // `name` name of the root element

      // `xmldec.version` A version number string, e.g. 1.0
      // `xmldec.encoding` Encoding declaration, e.g. UTF-8
      // `xmldec.standalone` standalone document declaration: true or false

      // `doctype.pubID` public identifier of the external subset
      // `doctype.sysID` system identifier of the external subset

      // `options.headless` whether XML declaration and doctype will be included:
      //     true or false
      // `options.keepNullNodes` whether nodes with null values will be kept
      //     or ignored: true or false
      // `options.keepNullAttributes` whether attributes with null values will be
      //     kept or ignored: true or false
      // `options.ignoreDecorators` whether decorator strings will be ignored when
      //     converting JS objects: true or false
      // `options.separateArrayItems` whether array items are created as separate
      //     nodes when passed as an object value: true or false
      // `options.noDoubleEncoding` whether existing html entities are encoded:
      //     true or false
      // `options.stringify` a set of functions to use for converting values to
      //     strings
      // `options.writer` the default XML writer to use for converting nodes to
      //     string. If the default writer is not set, the built-in XMLStringWriter
      //     will be used instead.
      module.exports.create = function (name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        // create the document node
        doc = new XMLDocument(options);
        // add the root node
        root = doc.element(name);
        // prolog
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root;
      };

      // Creates a new document and returns the document node for
      // chain-building the document tree

      // `options.keepNullNodes` whether nodes with null values will be kept
      //     or ignored: true or false
      // `options.keepNullAttributes` whether attributes with null values will be
      //     kept or ignored: true or false
      // `options.ignoreDecorators` whether decorator strings will be ignored when
      //     converting JS objects: true or false
      // `options.separateArrayItems` whether array items are created as separate
      //     nodes when passed as an object value: true or false
      // `options.noDoubleEncoding` whether existing html entities are encoded:
      //     true or false
      // `options.stringify` a set of functions to use for converting values to
      //     strings
      // `options.writer` the default XML writer to use for converting nodes to
      //     string. If the default writer is not set, the built-in XMLStringWriter
      //     will be used instead.

      // `onData` the function to be called when a new chunk of XML is output. The
      //          string containing the XML chunk is passed to `onData` as its single
      //          argument.
      // `onEnd`  the function to be called when the XML document is completed with
      //          `end`. `onEnd` does not receive any arguments.
      module.exports.begin = function (options, onData, onEnd) {
        if (isFunction(options)) {
          [onData, onEnd] = [options, onData];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };

      module.exports.stringWriter = function (options) {
        return new XMLStringWriter(options);
      };

      module.exports.streamWriter = function (stream, options) {
        return new XMLStreamWriter(stream, options);
      };

      module.exports.implementation = new XMLDOMImplementation();

      module.exports.nodeType = NodeType;

      module.exports.writerState = WriterState;
    }).call(this);

    /***/
  },

  /***/ 2941: /***/ (module) => {
    module.exports = eval("require")("original-fs");

    /***/
  },

  /***/ 9491: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "assert"
    );

    /***/
  },

  /***/ 852: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "async_hooks"
    );

    /***/
  },

  /***/ 4300: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "buffer"
    );

    /***/
  },

  /***/ 6206: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "console"
    );

    /***/
  },

  /***/ 2057: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "constants"
    );

    /***/
  },

  /***/ 6113: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "crypto"
    );

    /***/
  },

  /***/ 7643: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "diagnostics_channel"
    );

    /***/
  },

  /***/ 2361: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "events"
    );

    /***/
  },

  /***/ 7147: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs");

    /***/
  },

  /***/ 3685: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http");

    /***/
  },

  /***/ 5158: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http2");

    /***/
  },

  /***/ 5687: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("https");

    /***/
  },

  /***/ 1808: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("net");

    /***/
  },

  /***/ 5673: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "node:events"
    );

    /***/
  },

  /***/ 7742: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "node:process"
    );

    /***/
  },

  /***/ 4492: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "node:stream"
    );

    /***/
  },

  /***/ 2477: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "node:stream/web"
    );

    /***/
  },

  /***/ 7261: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "node:util"
    );

    /***/
  },

  /***/ 2037: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("os");

    /***/
  },

  /***/ 1017: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path");

    /***/
  },

  /***/ 4074: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "perf_hooks"
    );

    /***/
  },

  /***/ 3477: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "querystring"
    );

    /***/
  },

  /***/ 2781: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "stream"
    );

    /***/
  },

  /***/ 5356: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "stream/web"
    );

    /***/
  },

  /***/ 1576: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "string_decoder"
    );

    /***/
  },

  /***/ 4404: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tls");

    /***/
  },

  /***/ 6224: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tty");

    /***/
  },

  /***/ 7310: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("url");

    /***/
  },

  /***/ 3837: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("util");

    /***/
  },

  /***/ 9830: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "util/types"
    );

    /***/
  },

  /***/ 1267: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(
      "worker_threads"
    );

    /***/
  },

  /***/ 9796: /***/ (module) => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("zlib");

    /***/
  },

  /***/ 2960: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const WritableStream = __nccwpck_require__(4492).Writable;
    const inherits = __nccwpck_require__(7261).inherits;

    const StreamSearch = __nccwpck_require__(1142);

    const PartStream = __nccwpck_require__(1620);
    const HeaderParser = __nccwpck_require__(2032);

    const DASH = 45;
    const B_ONEDASH = Buffer.from("-");
    const B_CRLF = Buffer.from("\r\n");
    const EMPTY_FN = function () {};

    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);

      if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== "string")) {
        throw new TypeError("Boundary required");
      }

      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = undefined;
      }

      this._headerFirst = cfg.headerFirst;

      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = undefined;
      this._cb = undefined;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;

      const self = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function (header) {
        self._inHeader = false;
        self._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);

    Dicer.prototype.emit = function (ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self = this;
          process.nextTick(function () {
            self.emit("error", new Error("Unexpected end of multipart data"));
            if (self._part && !self._ignoreData) {
              const type = self._isPreamble ? "Preamble" : "Part";
              self._part.emit(
                "error",
                new Error(
                  type +
                    " terminated early due to unexpected end of multipart data"
                )
              );
              self._part.push(null);
              process.nextTick(function () {
                self._realFinish = true;
                self.emit("finish");
                self._realFinish = false;
              });
              return;
            }
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };

    Dicer.prototype._write = function (data, encoding, cb) {
      // ignore unexpected data (e.g. extra trailer data after finished)
      if (!this._hparser && !this._bparser) {
        return cb();
      }

      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== undefined && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }

      // allows for "easier" testing
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }

      this._bparser.push(data);

      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };

    Dicer.prototype.reset = function () {
      this._part = undefined;
      this._bparser = undefined;
      this._hparser = undefined;
    };

    Dicer.prototype.setBoundary = function (boundary) {
      const self = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function (isMatch, data, start, end) {
        self._oninfo(isMatch, data, start, end);
      });
    };

    Dicer.prototype._ignore = function () {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        // we must perform some kind of read on the stream even though we are
        // ignoring the data, otherwise node's Readable stream will not emit 'end'
        // after pushing null to the stream
        this._part.resume();
      }
    };

    Dicer.prototype._oninfo = function (isMatch, data, start, end) {
      let buf;
      const self = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;

      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          // no more parts will be added
          if (self._parts === 0) {
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function (n) {
          self._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (
          this._isPreamble !== true &&
          this.listenerCount("part") !== 0
        ) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== undefined && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function () {
              if (--self._parts === 0) {
                if (self._finished) {
                  self._realFinish = true;
                  self.emit("finish");
                  self._realFinish = false;
                } else {
                  self._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = undefined;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };

    Dicer.prototype._unpause = function () {
      if (!this._pause) {
        return;
      }

      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = undefined;
        cb();
      }
    };

    module.exports = Dicer;

    /***/
  },

  /***/ 2032: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const EventEmitter = __nccwpck_require__(5673).EventEmitter;
    const inherits = __nccwpck_require__(7261).inherits;
    const getLimit = __nccwpck_require__(1467);

    const StreamSearch = __nccwpck_require__(1142);

    const B_DCRLF = Buffer.from("\r\n\r\n");
    const RE_CRLF = /\r\n/g;
    const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/; // eslint-disable-line no-control-regex

    function HeaderParser(cfg) {
      EventEmitter.call(this);

      cfg = cfg || {};
      const self = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function (isMatch, data, start, end) {
        if (data && !self.maxed) {
          if (self.nread + end - start >= self.maxHeaderSize) {
            end = self.maxHeaderSize - self.nread + start;
            self.nread = self.maxHeaderSize;
            self.maxed = true;
          } else {
            self.nread += end - start;
          }

          self.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);

    HeaderParser.prototype.push = function (data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };

    HeaderParser.prototype.reset = function () {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };

    HeaderParser.prototype._finish = function () {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };

    HeaderParser.prototype._parseHeader = function () {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }

      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;

      for (var i = 0; i < len; ++i) {
        // eslint-disable-line no-var
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "\t" || lines[i][0] === " ") {
          // folded header content
          // RFC2822 says to just remove the CRLF and not the whitespace following
          // it, so we follow the RFC and include the leading whitespace ...
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }

        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };

    module.exports = HeaderParser;

    /***/
  },

  /***/ 1620: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const inherits = __nccwpck_require__(7261).inherits;
    const ReadableStream = __nccwpck_require__(4492).Readable;

    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);

    PartStream.prototype._read = function (n) {};

    module.exports = PartStream;

    /***/
  },

  /***/ 1142: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /**
     * Copyright Brian White. All rights reserved.
     *
     * @see https://github.com/mscdex/streamsearch
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to
     * deal in the Software without restriction, including without limitation the
     * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
     * sell copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
     * IN THE SOFTWARE.
     *
     * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
     * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
     */
    const EventEmitter = __nccwpck_require__(5673).EventEmitter;
    const inherits = __nccwpck_require__(7261).inherits;

    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }

      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }

      const needleLength = needle.length;

      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }

      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }

      this.maxMatches = Infinity;
      this.matches = 0;

      this._occ = new Array(256).fill(needleLength); // Initialize occurrence table.
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;

      this._lookbehind = Buffer.alloc(needleLength);

      // Populate occurrence table with analysis of the needle,
      // ignoring last letter.
      for (var i = 0; i < needleLength - 1; ++i) {
        // eslint-disable-line no-var
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter);

    SBMH.prototype.reset = function () {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };

    SBMH.prototype.push = function (chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };

    SBMH.prototype._sbmh_feed = function (data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];

      // Positive: points to a position in `data`
      //           pos == 3 points to data[3]
      // Negative: points to a position in the lookbehind buffer
      //           pos == -2 points to lookbehind[lookbehind_size - 2]
      let pos = -this._lookbehind_size;
      let ch;

      if (pos < 0) {
        // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
        // search with character lookup code that considers both the
        // lookbehind buffer and the current round's haystack data.
        //
        // Loop until
        //   there is a match.
        // or until
        //   we've moved past the position that requires the
        //   lookbehind buffer. In this case we switch to the
        //   optimized loop.
        // or until
        //   the character to look at lies outside the haystack.
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);

          if (
            ch === lastNeedleChar &&
            this._sbmh_memcmp(data, pos, needleLength - 1)
          ) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);

            return (this._bufpos = pos + needleLength);
          }
          pos += this._occ[ch];
        }

        // No match.

        if (pos < 0) {
          // There's too few data for Boyer-Moore-Horspool to run,
          // so let's use a different algorithm to skip as much as
          // we can.
          // Forward pos until
          //   the trailing part of lookbehind + data
          //   looks like the beginning of the needle
          // or until
          //   pos == 0
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }

        if (pos >= 0) {
          // Discard lookbehind buffer.
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          // Cut off part of the lookbehind buffer that has
          // been processed and append the entire haystack
          // into it.
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            // The cut off data is guaranteed not to contain the needle.
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }

          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;

          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;

          this._bufpos = len;
          return len;
        }
      }

      pos += (pos >= 0) * this._bufpos;

      // Lookbehind buffer is now empty. We only need to check if the
      // needle is in the haystack.
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }

        return (this._bufpos = pos + needleLength);
      } else {
        pos = len - needleLength;
      }

      // There was no match. If there's trailing haystack data that we cannot
      // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
      // data is less than the needle size) then match using a modified
      // algorithm that starts matching from the beginning instead of the end.
      // Whatever trailing data is left after running this algorithm is added to
      // the lookbehind buffer.
      while (
        pos < len &&
        (data[pos] !== needle[0] ||
          Buffer.compare(
            data.subarray(pos, pos + len - pos),
            needle.subarray(0, len - pos)
          ) !== 0)
      ) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }

      // Everything until pos is guaranteed not to contain needle data.
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }

      this._bufpos = len;
      return len;
    };

    SBMH.prototype._sbmh_lookup_char = function (data, pos) {
      return pos < 0
        ? this._lookbehind[this._lookbehind_size + pos]
        : data[pos];
    };

    SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
      for (var i = 0; i < len; ++i) {
        // eslint-disable-line no-var
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };

    module.exports = SBMH;

    /***/
  },

  /***/ 727: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const WritableStream = __nccwpck_require__(4492).Writable;
    const { inherits } = __nccwpck_require__(7261);
    const Dicer = __nccwpck_require__(2960);

    const MultipartParser = __nccwpck_require__(2183);
    const UrlencodedParser = __nccwpck_require__(8306);
    const parseParams = __nccwpck_require__(1854);

    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }

      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError(
          "Busboy expected an options-Object with headers-attribute."
        );
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }

      const { headers, ...streamOptions } = opts;

      this.opts = {
        autoDestroy: false,
        ...streamOptions,
      };
      WritableStream.call(this, this.opts);

      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);

    Busboy.prototype.emit = function (ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };

    Busboy.prototype.getParserByHeaders = function (headers) {
      const parsed = parseParams(headers["content-type"]);

      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath,
      };

      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };

    Busboy.prototype._write = function (chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };

    module.exports = Busboy;
    module.exports["default"] = Busboy;
    module.exports.Busboy = Busboy;

    module.exports.Dicer = Dicer;

    /***/
  },

  /***/ 2183: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    // TODO:
    //  * support 1 nested multipart level
    //    (see second multipart example here:
    //     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
    //  * support limits.fieldNameSize
    //     -- this will require modifications to utils.parseParams

    const { Readable } = __nccwpck_require__(4492);
    const { inherits } = __nccwpck_require__(7261);

    const Dicer = __nccwpck_require__(2960);

    const parseParams = __nccwpck_require__(1854);
    const decodeText = __nccwpck_require__(4619);
    const basename = __nccwpck_require__(8647);
    const getLimit = __nccwpck_require__(1467);

    const RE_BOUNDARY = /^boundary$/i;
    const RE_FIELD = /^form-data$/i;
    const RE_CHARSET = /^charset$/i;
    const RE_FILENAME = /^filename$/i;
    const RE_NAME = /^name$/i;

    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile =
        cfg.isPartAFile ||
        ((fieldName, contentType, fileName) =>
          contentType === "application/octet-stream" || fileName !== undefined);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };

      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (
          Array.isArray(parsedConType[i]) &&
          RE_BOUNDARY.test(parsedConType[i][0])
        ) {
          boundary = parsedConType[i][1];
          break;
        }
      }

      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self.end();
        }
      }

      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }

      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2000);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);

      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;

      this._needDrain = false;
      this._pause = false;
      this._cb = undefined;
      this._nparts = 0;
      this._boy = boy;

      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark,
      };

      this.parser = new Dicer(parserCfg);
      this.parser
        .on("drain", function () {
          self._needDrain = false;
          if (self._cb && !self._pause) {
            const cb = self._cb;
            self._cb = undefined;
            cb();
          }
        })
        .on("part", function onPart(part) {
          if (++self._nparts > partsLimit) {
            self.parser.removeListener("part", onPart);
            self.parser.on("part", skipPart);
            boy.hitPartsLimit = true;
            boy.emit("partsLimit");
            return skipPart(part);
          }

          // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
          // us emit 'end' early since we know the part has ended if we are already
          // seeing the next part
          if (curField) {
            const field = curField;
            field.emit("end");
            field.removeAllListeners("end");
          }

          part
            .on("header", function (header) {
              let contype;
              let fieldname;
              let parsed;
              let charset;
              let encoding;
              let filename;
              let nsize = 0;

              if (header["content-type"]) {
                parsed = parseParams(header["content-type"][0]);
                if (parsed[0]) {
                  contype = parsed[0].toLowerCase();
                  for (i = 0, len = parsed.length; i < len; ++i) {
                    if (RE_CHARSET.test(parsed[i][0])) {
                      charset = parsed[i][1].toLowerCase();
                      break;
                    }
                  }
                }
              }

              if (contype === undefined) {
                contype = "text/plain";
              }
              if (charset === undefined) {
                charset = defCharset;
              }

              if (header["content-disposition"]) {
                parsed = parseParams(header["content-disposition"][0]);
                if (!RE_FIELD.test(parsed[0])) {
                  return skipPart(part);
                }
                for (i = 0, len = parsed.length; i < len; ++i) {
                  if (RE_NAME.test(parsed[i][0])) {
                    fieldname = parsed[i][1];
                  } else if (RE_FILENAME.test(parsed[i][0])) {
                    filename = parsed[i][1];
                    if (!preservePath) {
                      filename = basename(filename);
                    }
                  }
                }
              } else {
                return skipPart(part);
              }

              if (header["content-transfer-encoding"]) {
                encoding = header["content-transfer-encoding"][0].toLowerCase();
              } else {
                encoding = "7bit";
              }

              let onData, onEnd;

              if (isPartAFile(fieldname, contype, filename)) {
                // file/binary field
                if (nfiles === filesLimit) {
                  if (!boy.hitFilesLimit) {
                    boy.hitFilesLimit = true;
                    boy.emit("filesLimit");
                  }
                  return skipPart(part);
                }

                ++nfiles;

                if (boy.listenerCount("file") === 0) {
                  self.parser._ignore();
                  return;
                }

                ++nends;
                const file = new FileStream(fileOpts);
                curFile = file;
                file.on("end", function () {
                  --nends;
                  self._pause = false;
                  checkFinished();
                  if (self._cb && !self._needDrain) {
                    const cb = self._cb;
                    self._cb = undefined;
                    cb();
                  }
                });
                file._read = function (n) {
                  if (!self._pause) {
                    return;
                  }
                  self._pause = false;
                  if (self._cb && !self._needDrain) {
                    const cb = self._cb;
                    self._cb = undefined;
                    cb();
                  }
                };
                boy.emit("file", fieldname, file, filename, encoding, contype);

                onData = function (data) {
                  if ((nsize += data.length) > fileSizeLimit) {
                    const extralen = fileSizeLimit - nsize + data.length;
                    if (extralen > 0) {
                      file.push(data.slice(0, extralen));
                    }
                    file.truncated = true;
                    file.bytesRead = fileSizeLimit;
                    part.removeAllListeners("data");
                    file.emit("limit");
                    return;
                  } else if (!file.push(data)) {
                    self._pause = true;
                  }

                  file.bytesRead = nsize;
                };

                onEnd = function () {
                  curFile = undefined;
                  file.push(null);
                };
              } else {
                // non-file field
                if (nfields === fieldsLimit) {
                  if (!boy.hitFieldsLimit) {
                    boy.hitFieldsLimit = true;
                    boy.emit("fieldsLimit");
                  }
                  return skipPart(part);
                }

                ++nfields;
                ++nends;
                let buffer = "";
                let truncated = false;
                curField = part;

                onData = function (data) {
                  if ((nsize += data.length) > fieldSizeLimit) {
                    const extralen = fieldSizeLimit - (nsize - data.length);
                    buffer += data.toString("binary", 0, extralen);
                    truncated = true;
                    part.removeAllListeners("data");
                  } else {
                    buffer += data.toString("binary");
                  }
                };

                onEnd = function () {
                  curField = undefined;
                  if (buffer.length) {
                    buffer = decodeText(buffer, "binary", charset);
                  }
                  boy.emit(
                    "field",
                    fieldname,
                    buffer,
                    false,
                    truncated,
                    encoding,
                    contype
                  );
                  --nends;
                  checkFinished();
                };
              }

              /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
         broken. Streams2/streams3 is a huge black box of confusion, but
         somehow overriding the sync state seems to fix things again (and still
         seems to work for previous node versions).
      */
              part._readableState.sync = false;

              part.on("data", onData);
              part.on("end", onEnd);
            })
            .on("error", function (err) {
              if (curFile) {
                curFile.emit("error", err);
              }
            });
        })
        .on("error", function (err) {
          boy.emit("error", err);
        })
        .on("finish", function () {
          finished = true;
          checkFinished();
        });
    }

    Multipart.prototype.write = function (chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };

    Multipart.prototype.end = function () {
      const self = this;

      if (self.parser.writable) {
        self.parser.end();
      } else if (!self._boy._done) {
        process.nextTick(function () {
          self._boy._done = true;
          self._boy.emit("finish");
        });
      }
    };

    function skipPart(part) {
      part.resume();
    }

    function FileStream(opts) {
      Readable.call(this, opts);

      this.bytesRead = 0;

      this.truncated = false;
    }

    inherits(FileStream, Readable);

    FileStream.prototype._read = function (n) {};

    module.exports = Multipart;

    /***/
  },

  /***/ 8306: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    const Decoder = __nccwpck_require__(7100);
    const decodeText = __nccwpck_require__(4619);
    const getLimit = __nccwpck_require__(1467);

    const RE_CHARSET = /^charset$/i;

    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;

      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);

      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        // eslint-disable-line no-var
        if (
          Array.isArray(parsedConType[i]) &&
          RE_CHARSET.test(parsedConType[i][0])
        ) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }

      if (charset === undefined) {
        charset = cfg.defCharset || "utf8";
      }

      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }

    UrlEncoded.prototype.write = function (data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }

      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;

      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = undefined;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 0x3d /* = */) {
              idxeq = i;
              break;
            } else if (data[i] === 0x26 /* & */) {
              idxamp = i;
              break;
            }
            if (
              this._checkingBytes &&
              this._bytesKey === this.fieldNameSizeLimit
            ) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }

          if (idxeq !== undefined) {
            // key with assignment
            if (idxeq > p) {
              this._key += this.decoder.write(
                data.toString("binary", p, idxeq)
              );
            }
            this._state = "val";

            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();

            p = idxeq + 1;
          } else if (idxamp !== undefined) {
            // key with no assignment
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(
                data.toString("binary", p, idxamp)
              );
            } else {
              key = this._key;
            }

            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();

            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }

            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            // we may not have hit the actual limit if there are encoded bytes...
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (
              (this._bytesKey = this._key.length) === this.fieldNameSizeLimit
            ) {
              // yep, we actually did hit the limit
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = undefined;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 0x26 /* & */) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }

          if (idxamp !== undefined) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(
                data.toString("binary", p, idxamp)
              );
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";

            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();

            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            // we may not have hit the actual limit if there are encoded bytes...
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (
              (this._val === "" && this.fieldSizeLimit === 0) ||
              (this._bytesVal = this._val.length) === this.fieldSizeLimit
            ) {
              // yep, we actually did hit the limit
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };

    UrlEncoded.prototype.end = function () {
      if (this.boy._done) {
        return;
      }

      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };

    module.exports = UrlEncoded;

    /***/
  },

  /***/ 7100: /***/ (module) => {
    const RE_PLUS = /\+/g;

    const HEX = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0,
    ];

    function Decoder() {
      this.buffer = undefined;
    }
    Decoder.prototype.write = function (str) {
      // Replace '+' with ' ' before decoding
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== undefined) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = undefined;
            --i; // retry character
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = undefined;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === undefined) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function () {
      this.buffer = undefined;
    };

    module.exports = Decoder;

    /***/
  },

  /***/ 8647: /***/ (module) => {
    module.exports = function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        // eslint-disable-line no-var
        switch (path.charCodeAt(i)) {
          case 0x2f: // '/'
          case 0x5c: // '\'
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };

    /***/
  },

  /***/ 4619: /***/ function (module) {
    // Node has always utf-8
    const utf8Decoder = new TextDecoder("utf-8");
    const textDecoders = new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder],
    ]);

    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii": // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === undefined) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }

    const decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },

      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },

      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },

      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },

      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }

        if (textDecoders.has(this.toString())) {
          try {
            return textDecoders.get(this).decode(data);
          } catch {}
        }
        return typeof data === "string" ? data : data.toString();
      },
    };

    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }

    module.exports = decodeText;

    /***/
  },

  /***/ 1467: /***/ (module) => {
    module.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === undefined || limits[name] === null) {
        return defaultLimit;
      }

      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }

      return limits[name];
    };

    /***/
  },

  /***/ 1854: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
    /* eslint-disable object-property-newline */

    const decodeText = __nccwpck_require__(4619);

    const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;

    const EncodedLookup = {
      "%00": "\x00",
      "%01": "\x01",
      "%02": "\x02",
      "%03": "\x03",
      "%04": "\x04",
      "%05": "\x05",
      "%06": "\x06",
      "%07": "\x07",
      "%08": "\x08",
      "%09": "\x09",
      "%0a": "\x0a",
      "%0A": "\x0a",
      "%0b": "\x0b",
      "%0B": "\x0b",
      "%0c": "\x0c",
      "%0C": "\x0c",
      "%0d": "\x0d",
      "%0D": "\x0d",
      "%0e": "\x0e",
      "%0E": "\x0e",
      "%0f": "\x0f",
      "%0F": "\x0f",
      "%10": "\x10",
      "%11": "\x11",
      "%12": "\x12",
      "%13": "\x13",
      "%14": "\x14",
      "%15": "\x15",
      "%16": "\x16",
      "%17": "\x17",
      "%18": "\x18",
      "%19": "\x19",
      "%1a": "\x1a",
      "%1A": "\x1a",
      "%1b": "\x1b",
      "%1B": "\x1b",
      "%1c": "\x1c",
      "%1C": "\x1c",
      "%1d": "\x1d",
      "%1D": "\x1d",
      "%1e": "\x1e",
      "%1E": "\x1e",
      "%1f": "\x1f",
      "%1F": "\x1f",
      "%20": "\x20",
      "%21": "\x21",
      "%22": "\x22",
      "%23": "\x23",
      "%24": "\x24",
      "%25": "\x25",
      "%26": "\x26",
      "%27": "\x27",
      "%28": "\x28",
      "%29": "\x29",
      "%2a": "\x2a",
      "%2A": "\x2a",
      "%2b": "\x2b",
      "%2B": "\x2b",
      "%2c": "\x2c",
      "%2C": "\x2c",
      "%2d": "\x2d",
      "%2D": "\x2d",
      "%2e": "\x2e",
      "%2E": "\x2e",
      "%2f": "\x2f",
      "%2F": "\x2f",
      "%30": "\x30",
      "%31": "\x31",
      "%32": "\x32",
      "%33": "\x33",
      "%34": "\x34",
      "%35": "\x35",
      "%36": "\x36",
      "%37": "\x37",
      "%38": "\x38",
      "%39": "\x39",
      "%3a": "\x3a",
      "%3A": "\x3a",
      "%3b": "\x3b",
      "%3B": "\x3b",
      "%3c": "\x3c",
      "%3C": "\x3c",
      "%3d": "\x3d",
      "%3D": "\x3d",
      "%3e": "\x3e",
      "%3E": "\x3e",
      "%3f": "\x3f",
      "%3F": "\x3f",
      "%40": "\x40",
      "%41": "\x41",
      "%42": "\x42",
      "%43": "\x43",
      "%44": "\x44",
      "%45": "\x45",
      "%46": "\x46",
      "%47": "\x47",
      "%48": "\x48",
      "%49": "\x49",
      "%4a": "\x4a",
      "%4A": "\x4a",
      "%4b": "\x4b",
      "%4B": "\x4b",
      "%4c": "\x4c",
      "%4C": "\x4c",
      "%4d": "\x4d",
      "%4D": "\x4d",
      "%4e": "\x4e",
      "%4E": "\x4e",
      "%4f": "\x4f",
      "%4F": "\x4f",
      "%50": "\x50",
      "%51": "\x51",
      "%52": "\x52",
      "%53": "\x53",
      "%54": "\x54",
      "%55": "\x55",
      "%56": "\x56",
      "%57": "\x57",
      "%58": "\x58",
      "%59": "\x59",
      "%5a": "\x5a",
      "%5A": "\x5a",
      "%5b": "\x5b",
      "%5B": "\x5b",
      "%5c": "\x5c",
      "%5C": "\x5c",
      "%5d": "\x5d",
      "%5D": "\x5d",
      "%5e": "\x5e",
      "%5E": "\x5e",
      "%5f": "\x5f",
      "%5F": "\x5f",
      "%60": "\x60",
      "%61": "\x61",
      "%62": "\x62",
      "%63": "\x63",
      "%64": "\x64",
      "%65": "\x65",
      "%66": "\x66",
      "%67": "\x67",
      "%68": "\x68",
      "%69": "\x69",
      "%6a": "\x6a",
      "%6A": "\x6a",
      "%6b": "\x6b",
      "%6B": "\x6b",
      "%6c": "\x6c",
      "%6C": "\x6c",
      "%6d": "\x6d",
      "%6D": "\x6d",
      "%6e": "\x6e",
      "%6E": "\x6e",
      "%6f": "\x6f",
      "%6F": "\x6f",
      "%70": "\x70",
      "%71": "\x71",
      "%72": "\x72",
      "%73": "\x73",
      "%74": "\x74",
      "%75": "\x75",
      "%76": "\x76",
      "%77": "\x77",
      "%78": "\x78",
      "%79": "\x79",
      "%7a": "\x7a",
      "%7A": "\x7a",
      "%7b": "\x7b",
      "%7B": "\x7b",
      "%7c": "\x7c",
      "%7C": "\x7c",
      "%7d": "\x7d",
      "%7D": "\x7d",
      "%7e": "\x7e",
      "%7E": "\x7e",
      "%7f": "\x7f",
      "%7F": "\x7f",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8a",
      "%8A": "\x8a",
      "%8b": "\x8b",
      "%8B": "\x8b",
      "%8c": "\x8c",
      "%8C": "\x8c",
      "%8d": "\x8d",
      "%8D": "\x8d",
      "%8e": "\x8e",
      "%8E": "\x8e",
      "%8f": "\x8f",
      "%8F": "\x8f",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9a",
      "%9A": "\x9a",
      "%9b": "\x9b",
      "%9B": "\x9b",
      "%9c": "\x9c",
      "%9C": "\x9c",
      "%9d": "\x9d",
      "%9D": "\x9d",
      "%9e": "\x9e",
      "%9E": "\x9e",
      "%9f": "\x9f",
      "%9F": "\x9f",
      "%a0": "\xa0",
      "%A0": "\xa0",
      "%a1": "\xa1",
      "%A1": "\xa1",
      "%a2": "\xa2",
      "%A2": "\xa2",
      "%a3": "\xa3",
      "%A3": "\xa3",
      "%a4": "\xa4",
      "%A4": "\xa4",
      "%a5": "\xa5",
      "%A5": "\xa5",
      "%a6": "\xa6",
      "%A6": "\xa6",
      "%a7": "\xa7",
      "%A7": "\xa7",
      "%a8": "\xa8",
      "%A8": "\xa8",
      "%a9": "\xa9",
      "%A9": "\xa9",
      "%aa": "\xaa",
      "%Aa": "\xaa",
      "%aA": "\xaa",
      "%AA": "\xaa",
      "%ab": "\xab",
      "%Ab": "\xab",
      "%aB": "\xab",
      "%AB": "\xab",
      "%ac": "\xac",
      "%Ac": "\xac",
      "%aC": "\xac",
      "%AC": "\xac",
      "%ad": "\xad",
      "%Ad": "\xad",
      "%aD": "\xad",
      "%AD": "\xad",
      "%ae": "\xae",
      "%Ae": "\xae",
      "%aE": "\xae",
      "%AE": "\xae",
      "%af": "\xaf",
      "%Af": "\xaf",
      "%aF": "\xaf",
      "%AF": "\xaf",
      "%b0": "\xb0",
      "%B0": "\xb0",
      "%b1": "\xb1",
      "%B1": "\xb1",
      "%b2": "\xb2",
      "%B2": "\xb2",
      "%b3": "\xb3",
      "%B3": "\xb3",
      "%b4": "\xb4",
      "%B4": "\xb4",
      "%b5": "\xb5",
      "%B5": "\xb5",
      "%b6": "\xb6",
      "%B6": "\xb6",
      "%b7": "\xb7",
      "%B7": "\xb7",
      "%b8": "\xb8",
      "%B8": "\xb8",
      "%b9": "\xb9",
      "%B9": "\xb9",
      "%ba": "\xba",
      "%Ba": "\xba",
      "%bA": "\xba",
      "%BA": "\xba",
      "%bb": "\xbb",
      "%Bb": "\xbb",
      "%bB": "\xbb",
      "%BB": "\xbb",
      "%bc": "\xbc",
      "%Bc": "\xbc",
      "%bC": "\xbc",
      "%BC": "\xbc",
      "%bd": "\xbd",
      "%Bd": "\xbd",
      "%bD": "\xbd",
      "%BD": "\xbd",
      "%be": "\xbe",
      "%Be": "\xbe",
      "%bE": "\xbe",
      "%BE": "\xbe",
      "%bf": "\xbf",
      "%Bf": "\xbf",
      "%bF": "\xbf",
      "%BF": "\xbf",
      "%c0": "\xc0",
      "%C0": "\xc0",
      "%c1": "\xc1",
      "%C1": "\xc1",
      "%c2": "\xc2",
      "%C2": "\xc2",
      "%c3": "\xc3",
      "%C3": "\xc3",
      "%c4": "\xc4",
      "%C4": "\xc4",
      "%c5": "\xc5",
      "%C5": "\xc5",
      "%c6": "\xc6",
      "%C6": "\xc6",
      "%c7": "\xc7",
      "%C7": "\xc7",
      "%c8": "\xc8",
      "%C8": "\xc8",
      "%c9": "\xc9",
      "%C9": "\xc9",
      "%ca": "\xca",
      "%Ca": "\xca",
      "%cA": "\xca",
      "%CA": "\xca",
      "%cb": "\xcb",
      "%Cb": "\xcb",
      "%cB": "\xcb",
      "%CB": "\xcb",
      "%cc": "\xcc",
      "%Cc": "\xcc",
      "%cC": "\xcc",
      "%CC": "\xcc",
      "%cd": "\xcd",
      "%Cd": "\xcd",
      "%cD": "\xcd",
      "%CD": "\xcd",
      "%ce": "\xce",
      "%Ce": "\xce",
      "%cE": "\xce",
      "%CE": "\xce",
      "%cf": "\xcf",
      "%Cf": "\xcf",
      "%cF": "\xcf",
      "%CF": "\xcf",
      "%d0": "\xd0",
      "%D0": "\xd0",
      "%d1": "\xd1",
      "%D1": "\xd1",
      "%d2": "\xd2",
      "%D2": "\xd2",
      "%d3": "\xd3",
      "%D3": "\xd3",
      "%d4": "\xd4",
      "%D4": "\xd4",
      "%d5": "\xd5",
      "%D5": "\xd5",
      "%d6": "\xd6",
      "%D6": "\xd6",
      "%d7": "\xd7",
      "%D7": "\xd7",
      "%d8": "\xd8",
      "%D8": "\xd8",
      "%d9": "\xd9",
      "%D9": "\xd9",
      "%da": "\xda",
      "%Da": "\xda",
      "%dA": "\xda",
      "%DA": "\xda",
      "%db": "\xdb",
      "%Db": "\xdb",
      "%dB": "\xdb",
      "%DB": "\xdb",
      "%dc": "\xdc",
      "%Dc": "\xdc",
      "%dC": "\xdc",
      "%DC": "\xdc",
      "%dd": "\xdd",
      "%Dd": "\xdd",
      "%dD": "\xdd",
      "%DD": "\xdd",
      "%de": "\xde",
      "%De": "\xde",
      "%dE": "\xde",
      "%DE": "\xde",
      "%df": "\xdf",
      "%Df": "\xdf",
      "%dF": "\xdf",
      "%DF": "\xdf",
      "%e0": "\xe0",
      "%E0": "\xe0",
      "%e1": "\xe1",
      "%E1": "\xe1",
      "%e2": "\xe2",
      "%E2": "\xe2",
      "%e3": "\xe3",
      "%E3": "\xe3",
      "%e4": "\xe4",
      "%E4": "\xe4",
      "%e5": "\xe5",
      "%E5": "\xe5",
      "%e6": "\xe6",
      "%E6": "\xe6",
      "%e7": "\xe7",
      "%E7": "\xe7",
      "%e8": "\xe8",
      "%E8": "\xe8",
      "%e9": "\xe9",
      "%E9": "\xe9",
      "%ea": "\xea",
      "%Ea": "\xea",
      "%eA": "\xea",
      "%EA": "\xea",
      "%eb": "\xeb",
      "%Eb": "\xeb",
      "%eB": "\xeb",
      "%EB": "\xeb",
      "%ec": "\xec",
      "%Ec": "\xec",
      "%eC": "\xec",
      "%EC": "\xec",
      "%ed": "\xed",
      "%Ed": "\xed",
      "%eD": "\xed",
      "%ED": "\xed",
      "%ee": "\xee",
      "%Ee": "\xee",
      "%eE": "\xee",
      "%EE": "\xee",
      "%ef": "\xef",
      "%Ef": "\xef",
      "%eF": "\xef",
      "%EF": "\xef",
      "%f0": "\xf0",
      "%F0": "\xf0",
      "%f1": "\xf1",
      "%F1": "\xf1",
      "%f2": "\xf2",
      "%F2": "\xf2",
      "%f3": "\xf3",
      "%F3": "\xf3",
      "%f4": "\xf4",
      "%F4": "\xf4",
      "%f5": "\xf5",
      "%F5": "\xf5",
      "%f6": "\xf6",
      "%F6": "\xf6",
      "%f7": "\xf7",
      "%F7": "\xf7",
      "%f8": "\xf8",
      "%F8": "\xf8",
      "%f9": "\xf9",
      "%F9": "\xf9",
      "%fa": "\xfa",
      "%Fa": "\xfa",
      "%fA": "\xfa",
      "%FA": "\xfa",
      "%fb": "\xfb",
      "%Fb": "\xfb",
      "%fB": "\xfb",
      "%FB": "\xfb",
      "%fc": "\xfc",
      "%Fc": "\xfc",
      "%fC": "\xfc",
      "%FC": "\xfc",
      "%fd": "\xfd",
      "%Fd": "\xfd",
      "%fD": "\xfd",
      "%FD": "\xfd",
      "%fe": "\xfe",
      "%Fe": "\xfe",
      "%fE": "\xfe",
      "%FE": "\xfe",
      "%ff": "\xff",
      "%Ff": "\xff",
      "%fF": "\xff",
      "%FF": "\xff",
    };

    function encodedReplacer(match) {
      return EncodedLookup[match];
    }

    const STATE_KEY = 0;
    const STATE_VALUE = 1;
    const STATE_CHARSET = 2;
    const STATE_LANG = 3;

    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;

      for (var i = 0; i < len; ++i) {
        // eslint-disable-line no-var
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if (
            (state === STATE_CHARSET || state === STATE_LANG) &&
            char === "'"
          ) {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (
            state === STATE_KEY &&
            (char === "*" || char === "=") &&
            res.length
          ) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, undefined];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === undefined) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "\t")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }

      if (res[p] === undefined) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }

      return res;
    }

    module.exports = parseParams;

    /***/
  },

  /***/ 8109: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Scalar = __nccwpck_require__(9338);
    var YAMLMap = __nccwpck_require__(6011);
    var YAMLSeq = __nccwpck_require__(5161);
    var resolveBlockMap = __nccwpck_require__(2986);
    var resolveBlockSeq = __nccwpck_require__(2289);
    var resolveFlowCollection = __nccwpck_require__(45);

    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll =
        token.type === "block-map"
          ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)
          : token.type === "block-seq"
            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection.resolveFlowCollection(
                CN,
                ctx,
                token,
                onError,
                tag
              );
      const Coll = coll.constructor;
      // If we got a tagName matching the class, or the tag name is '!',
      // then use the tagName from the node class used to create it.
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName) coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, tagToken, onError) {
      const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, (msg) =>
            onError(tagToken, "TAG_RESOLVE_FAILED", msg)
          );
      const expType =
        token.type === "block-map"
          ? "map"
          : token.type === "block-seq"
            ? "seq"
            : token.start.source === "{"
              ? "map"
              : "seq";
      // shortcut: check if it's a generic YAMLMap or YAMLSeq
      // before jumping into the custom tag logic.
      if (
        !tagToken ||
        !tagName ||
        tagName === "!" ||
        (tagName === YAMLMap.YAMLMap.tagName && expType === "map") ||
        (tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") ||
        !expType
      ) {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find(
        (t) => t.tag === tagName && t.collection === expType
      );
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt?.collection) {
            onError(
              tagToken,
              "BAD_COLLECTION_TYPE",
              `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`,
              true
            );
          } else {
            onError(
              tagToken,
              "TAG_RESOLVE_FAILED",
              `Unresolved tag: ${tagName}`,
              true
            );
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res =
        tag.resolve?.(
          coll,
          (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg),
          ctx.options
        ) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format) node.format = tag.format;
      return node;
    }

    exports.composeCollection = composeCollection;

    /***/
  },

  /***/ 5050: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Document = __nccwpck_require__(42);
    var composeNode = __nccwpck_require__(8676);
    var resolveEnd = __nccwpck_require__(1250);
    var resolveProps = __nccwpck_require__(6985);

    function composeDoc(
      options,
      directives,
      { offset, start, value, end },
      onError
    ) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(undefined, opts);
      const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema,
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        startOnNewline: true,
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (
          value &&
          (value.type === "block-map" || value.type === "block-seq") &&
          !props.hasNewline
        )
          onError(
            props.end,
            "MISSING_CHAR",
            "Block collection cannot start on same line with directives-end marker"
          );
      }
      // @ts-expect-error If Contents is set, let's trust the user
      doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(
            ctx,
            props.end,
            start,
            null,
            props,
            onError
          );
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment) doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }

    exports.composeDoc = composeDoc;

    /***/
  },

  /***/ 8676: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Alias = __nccwpck_require__(5639);
    var composeCollection = __nccwpck_require__(8109);
    var composeScalar = __nccwpck_require__(4766);
    var resolveEnd = __nccwpck_require__(1250);
    var utilEmptyScalarPosition = __nccwpck_require__(8781);

    const CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(
              token,
              "ALIAS_PROPS",
              "An alias node must not specify any properties"
            );
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor) node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(
            CN,
            ctx,
            token,
            tag,
            onError
          );
          if (anchor) node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message =
            token.type === "error"
              ? token.message
              : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(
            ctx,
            token.offset,
            undefined,
            null,
            props,
            onError
          );
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (spaceBefore) node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else node.commentBefore = comment;
      }
      // @ts-expect-error Type checking misses meaning of isSrcToken
      if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
      return node;
    }
    function composeEmptyNode(
      ctx,
      offset,
      before,
      pos,
      { spaceBefore, comment, anchor, tag, end },
      onError
    ) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(
          offset,
          before,
          pos
        ),
        indent: -1,
        source: "",
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore) node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(
          offset + source.length - 1,
          "BAD_ALIAS",
          "Alias ending in : is ambiguous",
          true
        );
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment) alias.comment = re.comment;
      return alias;
    }

    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;

    /***/
  },

  /***/ 4766: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Scalar = __nccwpck_require__(9338);
    var resolveBlockScalar = __nccwpck_require__(9485);
    var resolveFlowScalar = __nccwpck_require__(261);

    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } =
        token.type === "block-scalar"
          ? resolveBlockScalar.resolveBlockScalar(
              token,
              ctx.options.strict,
              onError
            )
          : resolveFlowScalar.resolveFlowScalar(
              token,
              ctx.options.strict,
              onError
            );
      const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, (msg) =>
            onError(tagToken, "TAG_RESOLVE_FAILED", msg)
          )
        : null;
      const tag =
        tagToken && tagName
          ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
          : token.type === "scalar"
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(
          value,
          (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg),
          ctx.options
        );
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type) scalar.type = type;
      if (tagName) scalar.tag = tagName;
      if (tag.format) scalar.format = tag.format;
      if (comment) scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!") return schema[identity.SCALAR]; // non-specific tag
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test) matchWithTest.push(tag);
          else return tag;
        }
      }
      for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(
          Object.assign({}, kt, { default: false, test: undefined })
        );
        return kt;
      }
      onError(
        tagToken,
        "TAG_RESOLVE_FAILED",
        `Unresolved tag: ${tagName}`,
        tagName !== "tag:yaml.org,2002:str"
      );
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest(
      { directives, schema },
      value,
      token,
      onError
    ) {
      const tag =
        schema.tags.find((tag) => tag.default && tag.test?.test(value)) ||
        schema[identity.SCALAR];
      if (schema.compat) {
        const compat =
          schema.compat.find((tag) => tag.default && tag.test?.test(value)) ??
          schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }

    exports.composeScalar = composeScalar;

    /***/
  },

  /***/ 9493: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var directives = __nccwpck_require__(5400);
    var Document = __nccwpck_require__(42);
    var errors = __nccwpck_require__(4236);
    var identity = __nccwpck_require__(5589);
    var composeDoc = __nccwpck_require__(5050);
    var resolveEnd = __nccwpck_require__(1250);

    function getErrorPos(src) {
      if (typeof src === "number") return [src, src + 1];
      if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [
        offset,
        offset + (typeof source === "string" ? source.length : 1),
      ];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment +=
              (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") +
              (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#") i += 1;
            atComment = false;
            break;
          default:
            // This may be wrong after doc-end, but in that case it doesn't matter
            if (!atComment) afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    /**
     * Compose a stream of CST nodes into a stream of YAML Documents.
     *
     * ```ts
     * import { Composer, Parser } from 'yaml'
     *
     * const src: string = ...
     * const tokens = new Parser().parse(src)
     * const docs = new Composer().compose(tokens)
     * ```
     */
    class Composer {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({
          version: options.version || "1.2",
        });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (
            identity.isCollection(dc) &&
            !dc.flow &&
            dc.items.length > 0
          ) {
            let it = dc.items[0];
            if (identity.isPair(it)) it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}\n${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings,
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens) yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (process.env.LOG_STREAM) console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(
              this.options,
              this.directives,
              token,
              this.onError
            );
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(
                token,
                "MISSING_CHAR",
                "Missing directives-end/doc-start indicator line"
              );
            this.decorate(doc, false);
            if (this.doc) yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source
              ? `${token.message}: ${JSON.stringify(token.source)}`
              : token.message;
            const error = new errors.YAMLParseError(
              getErrorPos(token),
              "UNEXPECTED_TOKEN",
              msg
            );
            if (this.atDirectives || !this.doc) this.errors.push(error);
            else this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(
                new errors.YAMLParseError(
                  getErrorPos(token),
                  "UNEXPECTED_TOKEN",
                  msg
                )
              );
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(
              token.end,
              token.offset + token.source.length,
              this.doc.options.strict,
              this.onError
            );
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(
              new errors.YAMLParseError(
                getErrorPos(token),
                "UNEXPECTED_TOKEN",
                `Unsupported token ${token.type}`
              )
            );
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign(
            { _directives: this.directives },
            this.options
          );
          const doc = new Document.Document(undefined, opts);
          if (this.atDirectives)
            this.onError(
              endOffset,
              "MISSING_CHAR",
              "Missing directives-end indicator line"
            );
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    }

    exports.Composer = Composer;

    /***/
  },

  /***/ 2986: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Pair = __nccwpck_require__(246);
    var YAMLMap = __nccwpck_require__(6011);
    var resolveProps = __nccwpck_require__(6985);
    var utilContainsNewline = __nccwpck_require__(976);
    var utilFlowIndentCheck = __nccwpck_require__(3669);
    var utilMapIncludes = __nccwpck_require__(6899);

    const startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap(
      { composeNode, composeEmptyNode },
      ctx,
      bm,
      onError,
      tag
    ) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot) ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          startOnNewline: true,
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(
                offset,
                "BLOCK_AS_IMPLICIT_KEY",
                "A block sequence may not be used as an implicit map key"
              );
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment) map.comment += "\n" + keyProps.comment;
              else map.comment = keyProps.comment;
            }
            continue;
          }
          if (
            keyProps.hasNewlineAfterProp ||
            utilContainsNewline.containsNewline(key)
          ) {
            onError(
              key ?? start[start.length - 1],
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys need to be on a single line"
            );
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
          ? composeNode(ctx, key, keyProps, onError)
          : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          startOnNewline: !key || key.type === "block-scalar",
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(
                offset,
                "BLOCK_AS_IMPLICIT_KEY",
                "Nested mappings are not allowed in compact mappings"
              );
            if (
              ctx.options.strict &&
              keyProps.start < valueProps.found.offset - 1024
            )
              onError(
                keyNode.range,
                "KEY_OVER_1024_CHARS",
                "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"
              );
          }
          // value value
          const valueNode = value
            ? composeNode(ctx, value, valueProps, onError)
            : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          // key with no value
          if (implicitKey)
            onError(
              keyNode.range,
              "MISSING_CHAR",
              "Implicit map keys need to be followed by map values"
            );
          if (valueProps.comment) {
            if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
            else keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }

    exports.resolveBlockMap = resolveBlockMap;

    /***/
  },

  /***/ 9485: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);

    function resolveBlockScalar(scalar, strict, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, strict, onError);
      if (!header)
        return {
          value: "",
          type: null,
          comment: "",
          range: [start, start, start],
        };
      const type =
        header.mode === ">"
          ? Scalar.Scalar.BLOCK_FOLDED
          : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      // determine the end of content & start of chomping
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r") chompStart = i;
        else break;
      }
      // shortcut for empty contents
      if (chompStart === 0) {
        const value =
          header.chomp === "+" && lines.length > 0
            ? "\n".repeat(Math.max(1, lines.length - 1))
            : "";
        let end = start + header.length;
        if (scalar.source) end += scalar.source.length;
        return {
          value,
          type,
          comment: header.comment,
          range: [start, end, end],
        };
      }
      // find the indentation level to trim from start
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message =
              "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0) trimIndent = indent.length;
          contentStart = i;
          break;
        }
        offset += indent.length + content.length + 1;
      }
      // include trailing more-indented empty lines in content
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent) chompStart = i + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      // leading whitespace is kept intact
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf) content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
          const src = header.indent
            ? "explicit indentation indicator"
            : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(
            offset - content.length - (crlf ? 2 : 1),
            "BAD_INDENT",
            message
          );
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "\t") {
          // more-indented content within a folded block
          if (sep === " ") sep = "\n";
          else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          // empty line
          if (sep === "\n") value += "\n";
          else sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n") value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      /* istanbul ignore if should not happen */
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n) indent = n;
          else if (error === -1) error = offset + i;
        }
      }
      if (error !== -1)
        onError(
          error,
          "UNEXPECTED_TOKEN",
          `Block scalar header includes extra characters: ${source}`
        );
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message =
                "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string") length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    /** @returns Array of lines split up as `[indent, content]` */
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }

    exports.resolveBlockScalar = resolveBlockScalar;

    /***/
  },

  /***/ 2289: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var YAMLSeq = __nccwpck_require__(5161);
    var resolveProps = __nccwpck_require__(6985);
    var utilFlowIndentCheck = __nccwpck_require__(3669);

    function resolveBlockSeq(
      { composeNode, composeEmptyNode },
      ctx,
      bs,
      onError,
      tag
    ) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot) ctx.atRoot = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          startOnNewline: true,
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(
                props.end,
                "BAD_INDENT",
                "All sequence items must start at the same column"
              );
            else
              onError(
                offset,
                "MISSING_CHAR",
                "Sequence item without - indicator"
              );
          } else {
            commentEnd = props.end;
            if (props.comment) seq.comment = props.comment;
            continue;
          }
        }
        const node = value
          ? composeNode(ctx, value, props, onError)
          : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }

    exports.resolveBlockSeq = resolveBlockSeq;

    /***/
  },

  /***/ 1250: /***/ (__unused_webpack_module, exports) => {
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(
                  token,
                  "MISSING_CHAR",
                  "Comments must be separated from other tokens by white space characters"
                );
              const cb = source.substring(1) || " ";
              if (!comment) comment = cb;
              else comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment) sep += source;
              hasSpace = true;
              break;
            default:
              onError(
                token,
                "UNEXPECTED_TOKEN",
                `Unexpected ${type} at node end`
              );
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }

    exports.resolveEnd = resolveEnd;

    /***/
  },

  /***/ 45: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Pair = __nccwpck_require__(246);
    var YAMLMap = __nccwpck_require__(6011);
    var YAMLSeq = __nccwpck_require__(5161);
    var resolveEnd = __nccwpck_require__(1250);
    var resolveProps = __nccwpck_require__(6985);
    var utilContainsNewline = __nccwpck_require__(976);
    var utilMapIncludes = __nccwpck_require__(6899);

    const blockMsg =
      "Block collections are not allowed within flow collections";
    const isBlock = (token) =>
      token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection(
      { composeNode, composeEmptyNode },
      ctx,
      fc,
      onError,
      tag
    ) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass =
        tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot) ctx.atRoot = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          startOnNewline: false,
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(
                props.comma,
                "UNEXPECTED_TOKEN",
                `Unexpected , in ${fcName}`
              );
            else if (i < fc.items.length - 1)
              onError(
                props.start,
                "UNEXPECTED_TOKEN",
                `Unexpected empty item in ${fcName}`
              );
            if (props.comment) {
              if (coll.comment) coll.comment += "\n" + props.comment;
              else coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (
            !isMap &&
            ctx.options.strict &&
            utilContainsNewline.containsNewline(key)
          )
            onError(
              key, // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(
              props.comma,
              "UNEXPECTED_TOKEN",
              `Unexpected , in ${fcName}`
            );
        } else {
          if (!props.comma)
            onError(
              props.start,
              "MISSING_CHAR",
              `Missing , between ${fcName} items`
            );
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev)) prev = prev.value ?? prev.key;
              if (prev.comment) prev.comment += "\n" + prevItemComment;
              else prev.comment = prevItemComment;
              props.comment = props.comment.substring(
                prevItemComment.length + 1
              );
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          // item is a value in a seq
          // → key & sep are empty, start does not include ? or :
          const valueNode = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          // item is a key+value pair
          // key value
          const keyStart = props.end;
          const keyNode = key
            ? composeNode(ctx, key, props, onError)
            : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          // value properties
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: false,
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found) break;
                  if (st.type === "newline") {
                    onError(
                      st,
                      "MULTILINE_IMPLICIT_KEY",
                      "Implicit keys of flow sequence pairs need to be on a single line"
                    );
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(
                  valueProps.found,
                  "KEY_OVER_1024_CHARS",
                  "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key"
                );
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(
                value,
                "MISSING_CHAR",
                `Missing space after : in ${fcName}`
              );
            else
              onError(
                valueProps.start,
                "MISSING_CHAR",
                `Missing , or : between ${fcName} items`
              );
          }
          // value value
          const valueNode = value
            ? composeNode(ctx, value, valueProps, onError)
            : valueProps.found
              ? composeEmptyNode(
                  ctx,
                  valueProps.end,
                  sep,
                  null,
                  valueProps,
                  onError
                )
              : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
            else keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
          ? `${name} must end with a ${expectedEnd}`
          : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1) ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(
          ee,
          cePos,
          ctx.options.strict,
          onError
        );
        if (end.comment) {
          if (coll.comment) coll.comment += "\n" + end.comment;
          else coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }

    exports.resolveFlowCollection = resolveFlowCollection;

    /***/
  },

  /***/ 261: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);
    var resolveEnd = __nccwpck_require__(1250);

    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(
            scalar,
            "UNEXPECTED_TOKEN",
            `Expected a flow scalar value, but found: ${type}`
          );
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length],
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset],
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "\t":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(
          0,
          "BAD_SCALAR_START",
          `Plain value cannot start with ${badChar}`
        );
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      /**
       * The negative lookbehind here and in the `re` RegExp is to
       * prevent causing a polynomial search time in certain cases.
       *
       * The try-catch is for Safari, which doesn't support this yet:
       * https://caniuse.com/js-regexp-lookbehind
       */
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy");
        line = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy");
      } catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match) return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while ((match = line.exec(source))) {
        if (match[1] === "") {
          if (sep === "\n") res += sep;
          else sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n") continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc) res += cc;
          else if (next === "\n") {
            // skip escaped newlines, but still trim the following line
            next = source[i + 1];
            while (next === " " || next === "\t") next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            // skip escaped CRLF newlines, but still trim the following line
            next = source[++i + 1];
            while (next === " " || next === "\t") next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "\t") {
          // trim trailing whitespace
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "\t") next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    /**
     * Fold a single newline into a space, multiple newlines to N - 1 newlines.
     * Presumes `source[offset] === '\n'`
     */
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "\t" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n") break;
        if (ch === "\n") fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold) fold = " ";
      return { fold, offset };
    }
    const escapeCodes = {
      0: "\0",
      a: "\x07",
      b: "\b",
      e: "\x1b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "\t",
      v: "\v",
      N: "\u0085",
      _: "\u00a0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "\t": "\t",
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }

    exports.resolveFlowScalar = resolveFlowScalar;

    /***/
  },

  /***/ 6985: /***/ (__unused_webpack_module, exports) => {
    function resolveProps(
      tokens,
      { flow, indicator, next, offset, onError, startOnNewline }
    ) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let hasNewlineAfterProp = false;
      let reqSpace = false;
      let anchor = null;
      let tag = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (
            token.type !== "space" &&
            token.type !== "newline" &&
            token.type !== "comma"
          )
            onError(
              token.offset,
              "MISSING_CHAR",
              "Tags and anchors must be separated from the next token by white space"
            );
          reqSpace = false;
        }
        switch (token.type) {
          case "space":
            // At the doc level, tabs at line start may be parsed
            // as leading white space rather than indentation.
            // In a flow collection, only the parser handles indent.
            if (
              !flow &&
              atNewline &&
              indicator !== "doc-start" &&
              token.source[0] === "\t"
            )
              onError(
                token,
                "TAB_AS_INDENT",
                "Tabs are not allowed as indentation"
              );
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(
                token,
                "MISSING_CHAR",
                "Comments must be separated from other tokens by white space characters"
              );
            const cb = token.source.substring(1) || " ";
            if (!comment) comment = cb;
            else comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment) comment += token.source;
              else spaceBefore = true;
            } else commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag) hasNewlineAfterProp = true;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(
                token,
                "MULTIPLE_ANCHORS",
                "A node can have at most one anchor"
              );
            if (token.source.endsWith(":"))
              onError(
                token.offset + token.source.length - 1,
                "BAD_ALIAS",
                "Anchor ending in : is ambiguous",
                true
              );
            anchor = token;
            if (start === null) start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(
                token,
                "MULTIPLE_TAGS",
                "A node can have at most one tag"
              );
            tag = token;
            if (start === null) start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            // Could here handle preceding comments differently
            if (anchor || tag)
              onError(
                token,
                "BAD_PROP_ORDER",
                `Anchors and tags must be after the ${token.source} indicator`
              );
            if (found)
              onError(
                token,
                "UNEXPECTED_TOKEN",
                `Unexpected ${token.source} in ${flow ?? "collection"}`
              );
            found = token;
            atNewline = false;
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(
              token,
              "UNEXPECTED_TOKEN",
              `Unexpected ${token.type} token`
            );
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (
        reqSpace &&
        next &&
        next.type !== "space" &&
        next.type !== "newline" &&
        next.type !== "comma" &&
        (next.type !== "scalar" || next.source !== "")
      )
        onError(
          next.offset,
          "MISSING_CHAR",
          "Tags and anchors must be separated from the next token by white space"
        );
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end,
      };
    }

    exports.resolveProps = resolveProps;

    /***/
  },

  /***/ 976: /***/ (__unused_webpack_module, exports) => {
    function containsNewline(key) {
      if (!key) return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n")) return true;
          if (key.end)
            for (const st of key.end) if (st.type === "newline") return true;
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start) if (st.type === "newline") return true;
            if (it.sep)
              for (const st of it.sep) if (st.type === "newline") return true;
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }

    exports.containsNewline = containsNewline;

    /***/
  },

  /***/ 8781: /***/ (__unused_webpack_module, exports) => {
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null) pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          // Technically, an empty scalar is immediately after the last non-empty
          // node, but it's more useful to place it after any whitespace.
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }

    exports.emptyScalarPosition = emptyScalarPosition;

    /***/
  },

  /***/ 3669: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var utilContainsNewline = __nccwpck_require__(976);

    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (
          end.indent === indent &&
          (end.source === "]" || end.source === "}") &&
          utilContainsNewline.containsNewline(fc)
        ) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }

    exports.flowIndentCheck = flowIndentCheck;

    /***/
  },

  /***/ 6899: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);

    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false) return false;
      const isEqual =
        typeof uniqueKeys === "function"
          ? uniqueKeys
          : (a, b) =>
              a === b ||
              (identity.isScalar(a) &&
                identity.isScalar(b) &&
                a.value === b.value &&
                !(a.value === "<<" && ctx.schema.merge));
      return items.some((pair) => isEqual(pair.key, search));
    }

    exports.mapIncludes = mapIncludes;

    /***/
  },

  /***/ 42: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Alias = __nccwpck_require__(5639);
    var Collection = __nccwpck_require__(3466);
    var identity = __nccwpck_require__(5589);
    var Pair = __nccwpck_require__(246);
    var toJS = __nccwpck_require__(2463);
    var Schema = __nccwpck_require__(6831);
    var stringifyDocument = __nccwpck_require__(5225);
    var anchors = __nccwpck_require__(8459);
    var applyReviver = __nccwpck_require__(3412);
    var createNode = __nccwpck_require__(9652);
    var directives = __nccwpck_require__(5400);

    class Document {
      constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, {
          value: identity.DOC,
        });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === undefined && replacer) {
          options = replacer;
          replacer = undefined;
        }
        const opt = Object.assign(
          {
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: "warn",
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: "1.2",
          },
          options
        );
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
          value === undefined
            ? null
            : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC },
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives) copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents)
          ? this.contents.clone(copy.schema)
          : this.contents;
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents)) this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents)) this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor =
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            !name || prev.has(name)
              ? anchors.findNewAnchor(name || "a", prev)
              : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) =>
            typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0) replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === undefined && replacer) {
          options = replacer;
          replacer = undefined;
        }
        const {
          aliasDuplicateObjects,
          anchorPrefix,
          flow,
          keepUndefined,
          onTagObj,
          tag,
        } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } =
          anchors.createNodeAnchors(
            this,
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            anchorPrefix || "a"
          );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects,
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node)) node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents)
          ? this.contents.delete(key)
          : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null) return false;
          // @ts-expect-error Presumed impossible if Strict extends false
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents)
          ? this.contents.deleteIn(path)
          : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents)
          ? this.contents.get(key, keepScalar)
          : undefined;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && identity.isScalar(this.contents)
            ? this.contents.value
            : this.contents;
        return identity.isCollection(this.contents)
          ? this.contents.getIn(path, keepScalar)
          : undefined;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents)
          ? this.contents.has(key)
          : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (Collection.isEmptyPath(path)) return this.contents !== undefined;
        return identity.isCollection(this.contents)
          ? this.contents.hasIn(path)
          : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          // @ts-expect-error We can't really know that this matches Contents.
          this.contents = Collection.collectionFromPath(
            this.schema,
            [key],
            value
          );
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
          // @ts-expect-error We can't really know that this matches Contents.
          this.contents = value;
        } else if (this.contents == null) {
          // @ts-expect-error We can't really know that this matches Contents.
          this.contents = Collection.collectionFromPath(
            this.schema,
            Array.from(path),
            value
          );
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number") version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives) this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives) this.directives.yaml.version = version;
            else this.directives = new directives.Directives({ version });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives) delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(
              `Expected '1.1', '1.2' or null as first argument, but found: ${sv}`
            );
          }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object) this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(
            `With a null YAML version, the { schema: Schema } option is required`
          );
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount:
            typeof maxAliasCount === "number" ? maxAliasCount : 100,
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res } of ctx.anchors.values())
            onAnchor(res, count);
        return typeof reviver === "function"
          ? applyReviver.applyReviver(reviver, { "": res }, "", res)
          : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if (
          "indent" in options &&
          (!Number.isInteger(options.indent) || Number(options.indent) <= 0)
        ) {
          const s = JSON.stringify(options.indent);
          throw new Error(
            `"indent" option must be a positive integer, not ${s}`
          );
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    }
    function assertCollection(contents) {
      if (identity.isCollection(contents)) return true;
      throw new Error("Expected a YAML collection as document contents");
    }

    exports.Document = Document;

    /***/
  },

  /***/ 8459: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var visit = __nccwpck_require__(6796);

    /**
     * Verify that the input string is a valid anchor.
     *
     * Will throw on errors.
     */
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor) anchors.add(node.anchor);
        },
      });
      return anchors;
    }
    /** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name)) return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          if (!prevAnchors) prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (
              typeof ref === "object" &&
              ref.anchor &&
              (identity.isScalar(ref.node) || identity.isCollection(ref.node))
            ) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error(
                "Failed to resolve repeated object (this should not happen)"
              );
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects,
      };
    }

    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;

    /***/
  },

  /***/ 3412: /***/ (__unused_webpack_module, exports) => {
    /**
     * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
     * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
     * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
     *
     * Includes extensions for handling Map and Set objects.
     */
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === undefined) delete val[i];
            else if (v1 !== v0) val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === undefined) val.delete(k);
            else if (v1 !== v0) val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === undefined) val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === undefined) delete val[k];
            else if (v1 !== v0) val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }

    exports.applyReviver = applyReviver;

    /***/
  },

  /***/ 9652: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Alias = __nccwpck_require__(5639);
    var identity = __nccwpck_require__(5589);
    var Scalar = __nccwpck_require__(9338);

    const defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) ?? match[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value)) value = value.contents;
      if (identity.isNode(value)) return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(
          ctx.schema,
          null,
          ctx
        );
        map.items.push(value);
        return map;
      }
      if (
        value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== "undefined" && value instanceof BigInt) // not supported everywhere
      ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
      }
      const {
        aliasDuplicateObjects,
        onAnchor,
        onTagObj,
        schema,
        sourceObjects,
      } = ctx;
      // Detect duplicate references to the same object & use Alias nodes for all
      // after first. The `ref` wrapper allows for circular references to resolve.
      let ref = undefined;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          if (!ref.anchor) ref.anchor = onAnchor(value);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-call
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node = new Scalar.Scalar(value);
          if (ref) ref.node = node;
          return node;
        }
        tagObj =
          value instanceof Map
            ? schema[identity.MAP]
            : Symbol.iterator in Object(value)
              ? schema[identity.SEQ]
              : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === "function"
          ? tagObj.nodeClass.from(ctx.schema, value, ctx)
          : new Scalar.Scalar(value);
      if (tagName) node.tag = tagName;
      else if (!tagObj.default) node.tag = tagObj.tag;
      if (ref) ref.node = node;
      return node;
    }

    exports.createNode = createNode;

    /***/
  },

  /***/ 5400: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var visit = __nccwpck_require__(6796);

    const escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D",
    };
    const escapeTagName = (tn) =>
      tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    class Directives {
      constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: "1.2",
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.1",
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2) return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!") return "!"; // non-specific tag
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix) onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) return prefix + decodeURIComponent(suffix);
        if (handle === "!") return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit
          ? [`%YAML ${this.yaml.version || "1.2"}`]
          : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag) tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:") continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    }
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

    exports.Directives = Directives;

    /***/
  },

  /***/ 4236: /***/ (__unused_webpack_module, exports) => {
    class YAMLError extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    }
    class YAMLParseError extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    }
    class YAMLWarning extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    }
    const prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1) return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, "");
      // Trim to max 80 chars, keeping col position near the middle
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "…" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "…";
      // Include previous line in context if pointing at line start
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(
          lc.lineStarts[line - 2],
          lc.lineStarts[line - 1]
        );
        if (prev.length > 80) prev = prev.substring(0, 79) + "…\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
      }
    };

    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;

    /***/
  },

  /***/ 4083: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var composer = __nccwpck_require__(9493);
    var Document = __nccwpck_require__(42);
    var Schema = __nccwpck_require__(6831);
    var errors = __nccwpck_require__(4236);
    var Alias = __nccwpck_require__(5639);
    var identity = __nccwpck_require__(5589);
    var Pair = __nccwpck_require__(246);
    var Scalar = __nccwpck_require__(9338);
    var YAMLMap = __nccwpck_require__(6011);
    var YAMLSeq = __nccwpck_require__(5161);
    var cst = __nccwpck_require__(9169);
    var lexer = __nccwpck_require__(5976);
    var lineCounter = __nccwpck_require__(1929);
    var parser = __nccwpck_require__(3328);
    var publicApi = __nccwpck_require__(8649);
    var visit = __nccwpck_require__(6796);

    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity.isAlias;
    exports.isCollection = identity.isCollection;
    exports.isDocument = identity.isDocument;
    exports.isMap = identity.isMap;
    exports.isNode = identity.isNode;
    exports.isPair = identity.isPair;
    exports.isScalar = identity.isScalar;
    exports.isSeq = identity.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;

    /***/
  },

  /***/ 6909: /***/ (__unused_webpack_module, exports) => {
    function debug(logLevel, ...messages) {
      if (logLevel === "debug") console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        // https://github.com/typescript-eslint/typescript-eslint/issues/7478
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else console.warn(warning);
      }
    }

    exports.debug = debug;
    exports.warn = warn;

    /***/
  },

  /***/ 5639: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var anchors = __nccwpck_require__(8459);
    var visit = __nccwpck_require__(6796);
    var identity = __nccwpck_require__(5589);
    var Node = __nccwpck_require__(1399);
    var toJS = __nccwpck_require__(2463);

    class Alias extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          },
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this) return visit.visit.BREAK;
            if (node.anchor === this.source) found = node;
          },
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx) return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          // Resolve anchors for Node.prototype.toJS()
          toJS.toJS(source, null, ctx);
          data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg =
              "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey) return `${src} `;
        }
        return src;
      }
    }
    function getAliasCount(doc, node, anchors) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors);
          if (c > count) count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    }

    exports.Alias = Alias;

    /***/
  },

  /***/ 3466: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var createNode = __nccwpck_require__(9652);
    var identity = __nccwpck_require__(5589);
    var Node = __nccwpck_require__(1399);

    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: new Map(),
      });
    }
    // Type guard is intentionally a little wrong so as to be more useful,
    // as it does not cover untypable empty non-string iterables (e.g. []).
    const isEmptyPath = (path) =>
      path == null ||
      (typeof path === "object" && !!path[Symbol.iterator]().next().done);
    class Collection extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true,
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(
          Object.getPrototypeOf(this),
          Object.getOwnPropertyDescriptors(this)
        );
        if (schema) copy.schema = schema;
        copy.items = copy.items.map((it) =>
          identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it
        );
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path)) this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (identity.isCollection(node)) node.addIn(rest, value);
          else if (node === undefined && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(
              `Expected YAML collection at ${key}. Remaining path: ${rest}`
            );
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node)) return node.deleteIn(rest);
        else
          throw new Error(
            `Expected YAML collection at ${key}. Remaining path: ${rest}`
          );
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node)
            ? node.getIn(rest, keepScalar)
            : undefined;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node)) return false;
          const n = node.value;
          return (
            n == null ||
            (allowScalar &&
              identity.isScalar(n) &&
              n.value == null &&
              !n.commentBefore &&
              !n.comment &&
              !n.tag)
          );
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node)) node.setIn(rest, value);
          else if (node === undefined && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(
              `Expected YAML collection at ${key}. Remaining path: ${rest}`
            );
        }
      }
    }
    Collection.maxFlowStringSingleLineLength = 60;

    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;

    /***/
  },

  /***/ 1399: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var applyReviver = __nccwpck_require__(3412);
    var identity = __nccwpck_require__(5589);
    var toJS = __nccwpck_require__(2463);

    class NodeBase {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(
          Object.getPrototypeOf(this),
          Object.getOwnPropertyDescriptors(this)
        );
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount:
            typeof maxAliasCount === "number" ? maxAliasCount : 100,
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res } of ctx.anchors.values())
            onAnchor(res, count);
        return typeof reviver === "function"
          ? applyReviver.applyReviver(reviver, { "": res }, "", res)
          : res;
      }
    }

    exports.NodeBase = NodeBase;

    /***/
  },

  /***/ 246: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var createNode = __nccwpck_require__(9652);
    var stringifyPair = __nccwpck_require__(4875);
    var addPairToJSMap = __nccwpck_require__(4676);
    var identity = __nccwpck_require__(5589);

    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, undefined, ctx);
      const v = createNode.createNode(value, undefined, ctx);
      return new Pair(k, v);
    }
    class Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, {
          value: identity.PAIR,
        });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key)) key = key.clone(schema);
        if (identity.isNode(value)) value = value.clone(schema);
        return new Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
          ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
          : JSON.stringify(this);
      }
    }

    exports.Pair = Pair;
    exports.createPair = createPair;

    /***/
  },

  /***/ 9338: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Node = __nccwpck_require__(1399);
    var toJS = __nccwpck_require__(2463);

    const isScalarValue = (value) =>
      !value || (typeof value !== "function" && typeof value !== "object");
    class Scalar extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    }
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;

    /***/
  },

  /***/ 6011: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var stringifyCollection = __nccwpck_require__(2466);
    var addPairToJSMap = __nccwpck_require__(4676);
    var Collection = __nccwpck_require__(3466);
    var identity = __nccwpck_require__(5589);
    var Pair = __nccwpck_require__(246);
    var Scalar = __nccwpck_require__(9338);

    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k) return it;
          if (identity.isScalar(it.key) && it.key.value === k) return it;
        }
      }
      return undefined;
    }
    class YAMLMap extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key)) return;
          if (value !== undefined || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj) add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj)) add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair)) _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          // In TypeScript, this never happens.
          _pair = new Pair.Pair(pair, pair?.value);
        } else _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
          // For scalars, keep the old node & its comments and anchors
          if (
            identity.isScalar(prev.value) &&
            Scalar.isScalarValue(_pair.value)
          )
            prev.value.value = _pair.value;
          else prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex(
            (item) => sortEntries(_pair, item) < 0
          );
          if (i === -1) this.items.push(_pair);
          else this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (
          (!keepScalar && identity.isScalar(node) ? node.value : node) ??
          undefined
        );
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(
              `Map items must all be pairs; found ${JSON.stringify(item)} instead`
            );
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment,
        });
      }
    }

    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;

    /***/
  },

  /***/ 5161: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var createNode = __nccwpck_require__(9652);
    var stringifyCollection = __nccwpck_require__(2466);
    var Collection = __nccwpck_require__(3466);
    var identity = __nccwpck_require__(5589);
    var Scalar = __nccwpck_require__(9338);
    var toJS = __nccwpck_require__(2463);

    class YAMLSeq extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return undefined;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate) ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment,
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, undefined, ctx));
          }
        }
        return seq;
      }
    }
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string") idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
    }

    exports.YAMLSeq = YAMLSeq;

    /***/
  },

  /***/ 4676: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var log = __nccwpck_require__(6909);
    var stringify = __nccwpck_require__(8409);
    var identity = __nccwpck_require__(5589);
    var Scalar = __nccwpck_require__(9338);
    var toJS = __nccwpck_require__(2463);

    const MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map, { key, value }) {
      if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (identity.isSeq(value))
          for (const it of value.items) mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
          for (const it of value) mergeToJSMap(ctx, map, it);
        else mergeToJSMap(ctx, map, value);
      } else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true,
            });
          else map[stringKey] = jsValue;
        }
      }
      return map;
    }
    const isMergeKey = (key) =>
      key === MERGE_KEY ||
      (identity.isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.Scalar.PLAIN));
    // If the value associated with a merge key is a single mapping node, each of
    // its key/value pairs is inserted into the current mapping, unless the key
    // already exists in it. If the value associated with the merge key is a
    // sequence, then this sequence is expected to contain mapping nodes and each
    // of these nodes is merged in turn according to its order in the sequence.
    // Keys in mapping nodes earlier in the sequence override keys specified in
    // later mapping nodes. -- http://yaml.org/type/merge.html
    function mergeToJSMap(ctx, map, value) {
      const source =
        ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true,
          });
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null) return "";
      if (typeof jsKey !== "object") return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(
            ctx.doc.options.logLevel,
            `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`
          );
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }

    exports.addPairToJSMap = addPairToJSMap;

    /***/
  },

  /***/ 5589: /***/ (__unused_webpack_module, exports) => {
    const ALIAS = Symbol.for("yaml.alias");
    const DOC = Symbol.for("yaml.document");
    const MAP = Symbol.for("yaml.map");
    const PAIR = Symbol.for("yaml.pair");
    const SCALAR = Symbol.for("yaml.scalar");
    const SEQ = Symbol.for("yaml.seq");
    const NODE_TYPE = Symbol.for("yaml.node.type");
    const isAlias = (node) =>
      !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    const isDocument = (node) =>
      !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    const isMap = (node) =>
      !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    const isPair = (node) =>
      !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    const isScalar = (node) =>
      !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    const isSeq = (node) =>
      !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    const hasAnchor = (node) =>
      (isScalar(node) || isCollection(node)) && !!node.anchor;

    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;

    /***/
  },

  /***/ 2463: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);

    /**
     * Recursively convert any node or its contents to native JavaScript
     *
     * @param value - The input value
     * @param arg - If `value` defines a `toJSON()` method, use this
     *   as its first argument
     * @param ctx - Conversion context, originally set in Document#toJS(). If
     *   `{ keep: true }` is not set, output should be suitable for JSON
     *   stringification.
     */
    function toJS(value, arg, ctx) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res) => {
          data.res = res;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate) ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep) return Number(value);
      return value;
    }

    exports.toJS = toJS;

    /***/
  },

  /***/ 9027: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var resolveBlockScalar = __nccwpck_require__(9485);
    var resolveFlowScalar = __nccwpck_require__(261);
    var errors = __nccwpck_require__(4236);
    var stringifyString = __nccwpck_require__(6226);

    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset =
            typeof pos === "number"
              ? pos
              : Array.isArray(pos)
                ? pos[0]
                : pos.offset;
          if (onError) onError(offset, code, message);
          else
            throw new errors.YAMLParseError(
              [offset, offset + 1],
              code,
              message
            );
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar(
              token,
              strict,
              _onError
            );
        }
      }
      return null;
    }
    /**
     * Create a new scalar token with `value`
     *
     * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
     * as this function does not support any schema operations and won't check for such conflicts.
     *
     * @param value The string representation of the value, which will have its content properly indented.
     * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
     * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
     * @param context.indent The indent level of the token.
     * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
     * @param context.offset The offset position of the token.
     * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
     */
    function createScalarToken(value, context) {
      const {
        implicitKey = false,
        indent,
        inFlow = false,
        offset = -1,
        type = "PLAIN",
      } = context;
      const source = stringifyString.stringifyString(
        { type, value },
        {
          implicitKey,
          indent: indent > 0 ? " ".repeat(indent) : "",
          inFlow,
          options: { blockQuote: true, lineWidth: -1 },
        }
      );
      const end = context.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" },
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head },
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    /**
     * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
     *
     * Best efforts are made to retain any comments previously associated with the `token`,
     * though all contents within a collection's `items` will be overwritten.
     *
     * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
     * as this function does not support any schema operations and won't check for such conflicts.
     *
     * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
     * @param value The string representation of the value, which will have its content properly indented.
     * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
     * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
     * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
     * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
     */
    function setScalarValue(token, value, context = {}) {
      let {
        afterKey = false,
        implicitKey = false,
        inFlow = false,
        type,
      } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number") indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString(
        { type, value },
        {
          implicitKey: implicitKey || indent === null,
          indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
          inFlow,
          options: { blockQuote: true, lineWidth: -1 },
        }
      );
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head },
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset") delete token[key];
        Object.assign(token, {
          type: "block-scalar",
          indent,
          props,
          source: body,
        });
      }
    }
    /** @returns `true` if last token is a newline */
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end) tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = {
            type: "newline",
            offset,
            indent: token.indent,
            source: "\n",
          };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end =
            "end" in token && Array.isArray(token.end)
              ? token.end.filter(
                  (st) =>
                    st.type === "space" ||
                    st.type === "comment" ||
                    st.type === "newline"
                )
              : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset") delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }

    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;

    /***/
  },

  /***/ 6307: /***/ (__unused_webpack_module, exports) => {
    /**
     * Stringify a CST document, token, or collection item
     *
     * Fair warning: This applies no validation whatsoever, and
     * simply concatenates the sources in their logical order.
     */
    const stringify = (cst) =>
      "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props) res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items) res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items) res += stringifyItem(item);
          for (const st of token.end) res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end) for (const st of token.end) res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end) res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start) res += st.source;
      if (key) res += stringifyToken(key);
      if (sep) for (const st of sep) res += st.source;
      if (value) res += stringifyToken(value);
      return res;
    }

    exports.stringify = stringify;

    /***/
  },

  /***/ 8497: /***/ (__unused_webpack_module, exports) => {
    const BREAK = Symbol("break visit");
    const SKIP = Symbol("skip children");
    const REMOVE = Symbol("remove item");
    /**
     * Apply a visitor to a CST document or item.
     *
     * Walks through the tree (depth-first) starting from the root, calling a
     * `visitor` function with two arguments when entering each item:
     *   - `item`: The current item, which included the following members:
     *     - `start: SourceToken[]` – Source tokens before the key or value,
     *       possibly including its anchor or tag.
     *     - `key?: Token | null` – Set for pair values. May then be `null`, if
     *       the key before the `:` separator is empty.
     *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
     *       which should include the `:` map value indicator if `value` is set.
     *     - `value?: Token` – The value of a sequence item, or of a map pair.
     *   - `path`: The steps from the root to the current node, as an array of
     *     `['key' | 'value', number]` tuples.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this token, continue with
     *      next sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current item, then continue with the next one
     *   - `number`: Set the index of the next step. This is useful especially if
     *     the index of the current token has changed.
     *   - `function`: Define the next visitor for this item. After the original
     *     visitor is called on item entry, next visitors are called after handling
     *     a non-empty `key` and when exiting the item.
     */
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visit.BREAK = BREAK;
    /** Do not visit the children of the current item */
    visit.SKIP = SKIP;
    /** Remove the current item */
    visit.REMOVE = REMOVE;
    /** Find the item at `path` from `cst` as the root */
    visit.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else return undefined;
      }
      return item;
    };
    /**
     * Get the immediate parent collection of the item at `path` from `cst` as the root.
     *
     * Throws an error if the collection is not found, which should never happen if the item itself exists.
     */
    visit.parentCollection = (cst, path) => {
      const parent = visit.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll) return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol") return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(
              Object.freeze(path.concat([[field, i]])),
              token.items[i],
              visitor
            );
            if (typeof ci === "number") i = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }

    exports.visit = visit;

    /***/
  },

  /***/ 9169: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var cstScalar = __nccwpck_require__(9027);
    var cstStringify = __nccwpck_require__(6307);
    var cstVisit = __nccwpck_require__(8497);

    /** The byte order mark */
    const BOM = "\u{FEFF}";
    /** Start of doc-mode */
    const DOCUMENT = "\x02"; // C0: Start of Text
    /** Unexpected end of flow-mode */
    const FLOW_END = "\x18"; // C0: Cancel
    /** Next token is a scalar value */
    const SCALAR = "\x1f"; // C0: Unit Separator
    /** @returns `true` if `token` is a flow or block collection */
    const isCollection = (token) => !!token && "items" in token;
    /** @returns `true` if `token` is a flow or block scalar; not an alias */
    const isScalar = (token) =>
      !!token &&
      (token.type === "scalar" ||
        token.type === "single-quoted-scalar" ||
        token.type === "double-quoted-scalar" ||
        token.type === "block-scalar");
    /* istanbul ignore next */
    /** Get a printable representation of a lexer token */
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    /** Identify the type of a lexer token. May return `null` for unknown tokens. */
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "\t":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }

    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;

    /***/
  },

  /***/ 5976: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var cst = __nccwpck_require__(9169);

    /*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
    function isEmpty(ch) {
      switch (ch) {
        case undefined:
        case " ":
        case "\n":
        case "\r":
        case "\t":
          return true;
        default:
          return false;
      }
    }
    const hexDigits = "0123456789ABCDEFabcdef".split("");
    const tagChars =
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(
        ""
      );
    const invalidFlowScalarChars = ",[]{}".split("");
    const invalidAnchorChars = " ,[]{}\n\r\t".split("");
    const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    /**
     * Splits an input string into lexical tokens, i.e. smaller strings that are
     * easily identifiable by `tokens.tokenType()`.
     *
     * Lexing starts always in a "stream" context. Incomplete input may be buffered
     * until a complete token can be emitted.
     *
     * In addition to slices of the original input, the following control characters
     * may also be emitted:
     *
     * - `\x02` (Start of Text): A document starts with the next token
     * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
     * - `\x1f` (Unit Separator): Next token is a scalar value
     * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
     */
    class Lexer {
      constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = "";
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "\t") ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n") return true;
        if (ch === "\r") return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ") ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || (!next && !this.atEnd))
              return offset + indent + 1;
          }
          return ch === "\n" ||
            indent >= this.indentNext ||
            (!ch && !this.atEnd)
            ? offset + indent
            : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if (
            (dt === "---" || dt === "...") &&
            isEmpty(this.buffer[offset + 3])
          )
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || (end !== -1 && end < this.pos)) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r") end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null) return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "\t") dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "\t") dirEnd -= 1;
            else break;
          }
          const n =
            (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n); // possible comment
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd) return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd) return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null) return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case undefined:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            // this is an error
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null) return this.setNext("flow");
        if (
          (indent !== -1 && indent < this.indentNext && line[0] !== "#") ||
          (indent === 0 &&
            (line.startsWith("---") || line.startsWith("...")) &&
            isEmpty(line[3]))
        ) {
          // Allowing for the terminal ] or } at the same (rather than greater)
          // indent level as the initial [ or { is technically invalid, but
          // failing here would be surprising to users.
          const atFlowEndMarker =
            indent === this.indentNext - 1 &&
            this.flowLevel === 1 &&
            (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            // this is an error
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case undefined:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          // double-quote
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\") n += 1;
            if (n % 2 === 0) break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1) break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            // this is an error caused by an unexpected unindent
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd) return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+") this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-") break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i + 1];
              if (!next && !this.atEnd) return this.setNext("block-scalar");
              if (next === "\n") break;
            } // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd) return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1) this.indentNext = indent;
          else this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1) break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd) return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch = this.buffer[i];
            if (ch === "\r") ch = this.buffer[--i];
            const lastChar = i; // Drop the line if last char not more indented
            while (ch === " " || ch === "\t") ch = this.buffer[--i];
            if (ch === "\n" && i >= this.pos && i + 1 + indent > lastChar)
              nl = i;
            else break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || (inFlow && next === ",")) break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else end = i;
            }
            if (
              next === "#" ||
              (inFlow && invalidFlowScalarChars.includes(next))
            )
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1) break;
              i = Math.max(i, cs - 2); // to advance, but still account for ' #'
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch)) break;
            end = i;
          }
        }
        if (!ch && !this.atEnd) return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty) yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (
              (yield* this.pushTag()) +
              (yield* this.pushSpaces(true)) +
              (yield* this.pushIndicators())
            );
          case "&":
            return (
              (yield* this.pushUntil(isNotAnchorChar)) +
              (yield* this.pushSpaces(true)) +
              (yield* this.pushIndicators())
            );
          case "-": // this is an error
          case "?": // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (
              isEmpty(ch1) ||
              (inFlow && invalidFlowScalarChars.includes(ch1))
            ) {
              if (!inFlow) this.indentNext = this.indentValue + 1;
              else if (this.flowKey) this.flowKey = false;
              return (
                (yield* this.pushCount(1)) +
                (yield* this.pushSpaces(true)) +
                (yield* this.pushIndicators())
              );
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">") ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.includes(ch)) ch = this.buffer[++i];
            else if (
              ch === "%" &&
              hexDigits.includes(this.buffer[i + 1]) &&
              hexDigits.includes(this.buffer[i + 2])
            ) {
              ch = this.buffer[(i += 3)];
            } else break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n") return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || (allowTabs && ch === "\t"));
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch)) ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    }

    exports.Lexer = Lexer;

    /***/
  },

  /***/ 1929: /***/ (__unused_webpack_module, exports) => {
    /**
     * Tracks newlines during parsing in order to provide an efficient API for
     * determining the one-indexed `{ line, col }` position for any offset
     * within the input.
     */
    class LineCounter {
      constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
            if (this.lineStarts[mid] < offset) low = mid + 1;
            else high = mid;
          }
          if (this.lineStarts[low] === offset) return { line: low + 1, col: 1 };
          if (low === 0) return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    }

    exports.LineCounter = LineCounter;

    /***/
  },

  /***/ 3328: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var cst = __nccwpck_require__(9169);
    var lexer = __nccwpck_require__(5976);

    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type) return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    /** Note: May modify input array */
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0) return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
        /* loop */
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (
            it.sep &&
            !it.value &&
            !includesToken(it.start, "explicit-key-ind") &&
            !includesToken(it.sep, "map-value-ind")
          ) {
            if (it.key) it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else it.value.end = it.sep;
            } else Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    /**
     * A YAML concrete syntax tree (CST) parser
     *
     * ```ts
     * const src: string = ...
     * for (const token of new Parser().parse(src)) {
     *   // token: Token
     * }
     * ```
     *
     * To use the parser with a user-provided lexer:
     *
     * ```ts
     * function* parse(source: string, lexer: Lexer) {
     *   const parser = new Parser()
     *   for (const lexeme of lexer.lex(source))
     *     yield* parser.next(lexeme)
     *   yield* parser.end()
     * }
     *
     * const src: string = ...
     * const lexer = new Lexer()
     * for (const token of parse(src, lexer)) {
     *   // token: Token
     * }
     * ```
     */
    class Parser {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = "";
        /** The type of the current token, set in parse() */
        this.type = "";
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0) this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete) yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS) console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({
            type: "error",
            offset: this.offset,
            message,
            source,
          });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine) this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine) this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0) yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source,
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0) yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source,
          });
          return;
        }
        if (!top) return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            // Block scalars use their parent rather than header indent
            token.indent = "indent" in top ? top.indent : 0;
          } else if (
            token.type === "flow-collection" &&
            top.type === "document"
          ) {
            // Ignore all indent for top-level flow collections
            token.indent = 0;
          }
          if (token.type === "flow-collection") fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token); // error
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value) top.items.push({ start: [], value: token });
              else it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep) it.value = token;
              else Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if (
            (top.type === "document" ||
              top.type === "block-map" ||
              top.type === "block-seq") &&
            (token.type === "block-map" || token.type === "block-seq")
          ) {
            const last = token.items[token.items.length - 1];
            if (
              last &&
              !last.sep &&
              !last.value &&
              last.start.length > 0 &&
              findNonEmptyIndex(last.start) === -1 &&
              (token.indent === 0 ||
                last.start.every(
                  (st) => st.type !== "comment" || st.indent < token.indent
                ))
            ) {
              if (top.type === "document") top.end = last.start;
              else top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield {
              type: "directive",
              offset: this.offset,
              source: this.source,
            };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: [],
            };
            if (this.type === "doc-start") doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source,
        };
      }
      *document(doc) {
        if (doc.value) return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv) this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source,
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else sep = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }],
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            // block-scalar source includes trailing newline
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : undefined;
              const last = Array.isArray(end) ? end[end.length - 1] : undefined;
              if (last?.type === "comment") end?.push(this.sourceToken);
              else map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atNextItem =
            !this.onKeyLine && this.indent === map.indent && it.sep;
          // For empty nodes, assign newline-separated not indented empty tokens to following node
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent) nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2) start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }],
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start, key: null, sep: [this.sourceToken] }],
                    });
                  }
                } else if (it.value) {
                  map.items.push({
                    start: [],
                    key: null,
                    sep: [this.sourceToken],
                  });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }],
                  });
                } else if (
                  isFlowToken(it.key) &&
                  !includesToken(it.sep, "newline")
                ) {
                  const start = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  // @ts-expect-error type guard is wrong here
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key, sep }],
                  });
                } else if (start.length > 0) {
                  // Not actually at next item
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }],
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (
                  atNextItem &&
                  bv.type !== "block-seq" &&
                  includesToken(it.start, "explicit-key-ind")
                ) {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : undefined;
              const last = Array.isArray(end) ? end[end.length - 1] : undefined;
              if (last?.type === "comment") end?.push(this.sourceToken);
              else seq.items.push({ start: [this.sourceToken] });
            } else it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value) seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent) break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent) break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep) fc.items.push({ start: [this.sourceToken] });
              else it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({
                  start: [],
                  key: null,
                  sep: [this.sourceToken],
                });
              else if (it.sep) it.sep.push(this.sourceToken);
              else Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value) fc.items.push({ start: [this.sourceToken] });
              else if (it.sep) it.sep.push(this.sourceToken);
              else it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep) this.stack.push(fs);
              else Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          /* istanbul ignore else should not happen */
          if (bv) this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (
            parent.type === "block-map" &&
            ((this.type === "map-value-ind" && parent.indent === fc.indent) ||
              (this.type === "newline" &&
                !parent.items[parent.items.length - 1].sep))
          ) {
            yield* this.pop();
            yield* this.step();
          } else if (
            this.type === "map-value-ind" &&
            parent.type !== "flow-collection"
          ) {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }],
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source,
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: "",
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: [],
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }],
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }],
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }],
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment") return false;
        if (this.indent <= indent) return false;
        return start.every(
          (st) => st.type === "newline" || st.type === "space"
        );
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end) docEnd.end.push(this.sourceToken);
          else docEnd.end = [this.sourceToken];
          if (this.type === "newline") yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            // all other values are errors
            if (token.end) token.end.push(this.sourceToken);
            else token.end = [this.sourceToken];
            if (this.type === "newline") yield* this.pop();
        }
      }
    }

    exports.Parser = Parser;

    /***/
  },

  /***/ 8649: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var composer = __nccwpck_require__(9493);
    var Document = __nccwpck_require__(42);
    var errors = __nccwpck_require__(4236);
    var log = __nccwpck_require__(6909);
    var lineCounter = __nccwpck_require__(1929);
    var parser = __nccwpck_require__(3328);

    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 =
        options.lineCounter ||
        (prettyErrors && new lineCounter.LineCounter()) ||
        null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    /**
     * Parse the input as a stream of YAML documents.
     *
     * Documents should be separated from each other by `...` or `---` marker lines.
     *
     * @returns If an empty `docs` array is returned, it will be of type
     *   EmptyStream and contain additional stream information. In
     *   TypeScript, you should use `'empty' in docs` as a type guard for it.
     */
    function parseAllDocuments(source, options = {}) {
      const { lineCounter, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
      if (docs.length > 0) return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    /** Parse an input string into a single YAML.Document */
    function parseDocument(source, options = {}) {
      const { lineCounter, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter?.addNewLine);
      const composer$1 = new composer.Composer(options);
      // `doc` is always set by compose.end(true) at the very latest
      let doc = null;
      for (const _doc of composer$1.compose(
        parser$1.parse(source),
        true,
        source.length
      )) {
        if (!doc) doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(
            new errors.YAMLParseError(
              _doc.range.slice(0, 2),
              "MULTIPLE_DOCS",
              "Source contains multiple documents; please use YAML.parseAllDocuments()"
            )
          );
          break;
        }
      }
      if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = undefined;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (
        options === undefined &&
        reviver &&
        typeof reviver === "object"
      ) {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc) return null;
      doc.warnings.forEach((warning) =>
        log.warn(doc.options.logLevel, warning)
      );
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent") throw doc.errors[0];
        else doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
      }
      if (typeof options === "string") options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options =
          indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined) return undefined;
      }
      return new Document.Document(value, _replacer, options).toString(options);
    }

    exports.parse = parse;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify;

    /***/
  },

  /***/ 6831: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var map = __nccwpck_require__(83);
    var seq = __nccwpck_require__(1693);
    var string = __nccwpck_require__(2201);
    var tags = __nccwpck_require__(4138);

    const sortMapEntriesByKey = (a, b) =>
      a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    class Schema {
      constructor({
        compat,
        customTags,
        merge,
        resolveKnownTags,
        schema,
        sortMapEntries,
        toStringDefaults,
      }) {
        this.compat = Array.isArray(compat)
          ? tags.getTags(compat, "compat")
          : compat
            ? tags.getTags(null, compat)
            : null;
        this.merge = !!merge;
        this.name = (typeof schema === "string" && schema) || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
          typeof sortMapEntries === "function"
            ? sortMapEntries
            : sortMapEntries === true
              ? sortMapEntriesByKey
              : null;
      }
      clone() {
        const copy = Object.create(
          Schema.prototype,
          Object.getOwnPropertyDescriptors(this)
        );
        copy.tags = this.tags.slice();
        return copy;
      }
    }

    exports.Schema = Schema;

    /***/
  },

  /***/ 83: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var YAMLMap = __nccwpck_require__(6011);

    const map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map, onError) {
        if (!identity.isMap(map)) onError("Expected a mapping for this tag");
        return map;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx),
    };

    exports.map = map;

    /***/
  },

  /***/ 6703: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);

    const nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) =>
        typeof source === "string" && nullTag.test.test(source)
          ? source
          : ctx.options.nullStr,
    };

    exports.nullTag = nullTag;

    /***/
  },

  /***/ 1693: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var YAMLSeq = __nccwpck_require__(5161);

    const seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq, onError) {
        if (!identity.isSeq(seq)) onError("Expected a sequence for this tag");
        return seq;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx),
    };

    exports.seq = seq;

    /***/
  },

  /***/ 2201: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var stringifyString = __nccwpck_require__(6226);

    const string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(
          item,
          ctx,
          onComment,
          onChompKeep
        );
      },
    };

    exports.string = string;

    /***/
  },

  /***/ 2045: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);

    const boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv) return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      },
    };

    exports.boolTag = boolTag;

    /***/
  },

  /***/ 6810: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);
    var stringifyNumber = __nccwpck_require__(4174);

    const floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) =>
        str.slice(-3).toLowerCase() === "nan"
          ? NaN
          : str[0] === "-"
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber,
    };
    const floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num)
          ? num.toExponential()
          : stringifyNumber.stringifyNumber(node);
      },
    };
    const float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber,
    };

    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;

    /***/
  },

  /***/ 3019: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var stringifyNumber = __nccwpck_require__(4174);

    const intIdentify = (value) =>
      typeof value === "bigint" || Number.isInteger(value);
    const intResolve = (str, offset, radix, { intAsBigInt }) =>
      intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    const intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o"),
    };
    const int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber,
    };
    const intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x"),
    };

    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;

    /***/
  },

  /***/ 27: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var map = __nccwpck_require__(83);
    var _null = __nccwpck_require__(6703);
    var seq = __nccwpck_require__(1693);
    var string = __nccwpck_require__(2201);
    var bool = __nccwpck_require__(2045);
    var float = __nccwpck_require__(6810);
    var int = __nccwpck_require__(3019);

    const schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
    ];

    exports.schema = schema;

    /***/
  },

  /***/ 4545: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);
    var map = __nccwpck_require__(83);
    var seq = __nccwpck_require__(1693);

    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    const stringifyJSON = ({ value }) => JSON.stringify(value);
    const jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON,
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON,
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON,
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) =>
          intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) =>
          intIdentify(value) ? value.toString() : JSON.stringify(value),
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON,
      },
    ];
    const jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      },
    };
    const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

    exports.schema = schema;

    /***/
  },

  /***/ 4138: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var map = __nccwpck_require__(83);
    var _null = __nccwpck_require__(6703);
    var seq = __nccwpck_require__(1693);
    var string = __nccwpck_require__(2201);
    var bool = __nccwpck_require__(2045);
    var float = __nccwpck_require__(6810);
    var int = __nccwpck_require__(3019);
    var schema = __nccwpck_require__(27);
    var schema$1 = __nccwpck_require__(4545);
    var binary = __nccwpck_require__(5724);
    var omap = __nccwpck_require__(8974);
    var pairs = __nccwpck_require__(9841);
    var schema$2 = __nccwpck_require__(5389);
    var set = __nccwpck_require__(7847);
    var timestamp = __nccwpck_require__(1156);

    const schemas = new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema],
    ]);
    const tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp,
    };
    const coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp,
    };
    function getTags(customTags, schemaName) {
      let tags = schemas.get(schemaName);
      if (!tags) {
        if (Array.isArray(customTags)) tags = [];
        else {
          const keys = Array.from(schemas.keys())
            .filter((key) => key !== "yaml11")
            .map((key) => JSON.stringify(key))
            .join(", ");
          throw new Error(
            `Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`
          );
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags) tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      return tags.map((tag) => {
        if (typeof tag !== "string") return tag;
        const tagObj = tagsByName[tag];
        if (tagObj) return tagObj;
        const keys = Object.keys(tagsByName)
          .map((key) => JSON.stringify(key))
          .join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      });
    }

    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;

    /***/
  },

  /***/ 5724: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);
    var stringifyString = __nccwpck_require__(6226);

    const binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          // On IE 11, atob() can't handle newlines
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError(
            "This environment does not support reading binary tags; either Buffer or atob is required"
          );
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === "function") {
          str =
            buf instanceof Buffer
              ? buf.toString("base64")
              : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error(
            "This environment does not support writing binary tags; either Buffer or btoa is required"
          );
        }
        if (!type) type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(
            ctx.options.lineWidth - ctx.indent.length,
            ctx.options.minContentWidth
          );
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString(
          { comment, type, value: str },
          ctx,
          onComment,
          onChompKeep
        );
      },
    };

    exports.binary = binary;

    /***/
  },

  /***/ 2631: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);

    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source)) return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    const trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify,
    };
    const falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify,
    };

    exports.falseTag = falseTag;
    exports.trueTag = trueTag;

    /***/
  },

  /***/ 8035: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);
    var stringifyNumber = __nccwpck_require__(4174);

    const floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) =>
        str.slice(-3).toLowerCase() === "nan"
          ? NaN
          : str[0] === "-"
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber,
    };
    const floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num)
          ? num.toExponential()
          : stringifyNumber.stringifyNumber(node);
      },
    };
    const float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber,
    };

    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;

    /***/
  },

  /***/ 9503: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var stringifyNumber = __nccwpck_require__(4174);

    const intIdentify = (value) =>
      typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+") offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n = BigInt(str);
        return sign === "-" ? BigInt(-1) * n : n;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    const intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b"),
    };
    const intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0"),
    };
    const int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber,
    };
    const intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x"),
    };

    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;

    /***/
  },

  /***/ 8974: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var toJS = __nccwpck_require__(2463);
    var YAMLMap = __nccwpck_require__(6011);
    var YAMLSeq = __nccwpck_require__(5161);
    var pairs = __nccwpck_require__(9841);

    class YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx) return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
      }
    }
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    const omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(
                `Ordered maps must not include duplicate keys: ${key.value}`
              );
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) =>
        YAMLOMap.from(schema, iterable, ctx),
    };

    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;

    /***/
  },

  /***/ 9841: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Pair = __nccwpck_require__(246);
    var Scalar = __nccwpck_require__(9338);
    var YAMLSeq = __nccwpck_require__(5161);

    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item)) continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair =
              item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore
                ? `${item.commentBefore}\n${pair.key.commentBefore}`
                : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment
                ? `${item.comment}\n${cn.comment}`
                : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs = new YAMLSeq.YAMLSeq(schema);
      pairs.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(
                `Expected tuple with one key, not ${keys.length} keys`
              );
            }
          } else {
            key = it;
          }
          pairs.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs;
    }
    const pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs,
    };

    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;

    /***/
  },

  /***/ 5389: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var map = __nccwpck_require__(83);
    var _null = __nccwpck_require__(6703);
    var seq = __nccwpck_require__(1693);
    var string = __nccwpck_require__(2201);
    var binary = __nccwpck_require__(5724);
    var bool = __nccwpck_require__(2631);
    var float = __nccwpck_require__(8035);
    var int = __nccwpck_require__(9503);
    var omap = __nccwpck_require__(8974);
    var pairs = __nccwpck_require__(9841);
    var set = __nccwpck_require__(7847);
    var timestamp = __nccwpck_require__(1156);

    const schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp,
    ];

    exports.schema = schema;

    /***/
  },

  /***/ 7847: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Pair = __nccwpck_require__(246);
    var YAMLMap = __nccwpck_require__(6011);

    class YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key)) pair = key;
        else if (
          key &&
          typeof key === "object" &&
          "key" in key &&
          "value" in key &&
          key.value === null
        )
          pair = new Pair.Pair(key.key, null);
        else pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair)
          ? identity.isScalar(pair.key)
            ? pair.key.value
            : pair.key
          : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(
            `Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`
          );
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(
            Object.assign({}, ctx, { allNullValues: true }),
            onComment,
            onChompKeep
          );
        else throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set.items.push(Pair.createPair(value, null, ctx));
          }
        return set;
      }
    }
    YAMLSet.tag = "tag:yaml.org,2002:set";
    const set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) =>
        YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else onError("Set items must all have null values");
        } else onError("Expected a mapping for this tag");
        return map;
      },
    };

    exports.YAMLSet = YAMLSet;
    exports.set = set;

    /***/
  },

  /***/ 1156: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var stringifyNumber = __nccwpck_require__(4174);

    /** Internal types handle bigint as number, because TS can't figure it out. */
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => (asBigInt ? BigInt(n) : Number(n));
      const res = parts
        .replace(/_/g, "")
        .split(":")
        .reduce((res, p) => res * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    /**
     * hhhh:mm:ss.sss
     *
     * Internal types handle bigint as number, because TS can't figure it out.
     */
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint") num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60]; // seconds, including ms
      if (value < 60) {
        parts.unshift(0); // at least one : is required
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value); // hours
        }
      }
      return (
        sign +
        parts
          .map((n) => String(n).padStart(2, "0"))
          .join(":")
          .replace(/000000\d*$/, "") // % 60 may introduce error
      );
    }
    const intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) =>
        parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal,
    };
    const floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal,
    };
    const timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp(
        "^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + // YYYY-Mm-Dd
          "(?:" + // time is optional
          "(?:t|T|[ \\t]+)" + // t | T | whitespace
          "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + // Hh:Mm:Ss(.ss)?
          "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + // Z | +5 | -03:30
          ")?$"
      ),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error(
            "!!timestamp expects a date, starting with yyyy-mm-dd"
          );
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(
          year,
          month - 1,
          day,
          hour || 0,
          minute || 0,
          second || 0,
          millisec
        );
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30) d *= 60;
          date -= 60000 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) =>
        value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, ""),
    };

    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;

    /***/
  },

  /***/ 2889: /***/ (__unused_webpack_module, exports) => {
    const FOLD_FLOW = "flow";
    const FOLD_BLOCK = "block";
    const FOLD_QUOTED = "quoted";
    /**
     * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
     * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
     * terminated with `\n` and started with `indent`.
     */
    function foldFlowLines(
      text,
      indent,
      mode = "flow",
      {
        indentAtStart,
        lineWidth = 80,
        minContentWidth = 20,
        onFold,
        onOverflow,
      } = {}
    ) {
      if (!lineWidth || lineWidth < 0) return text;
      const endStep = Math.max(
        1 + minContentWidth,
        1 + lineWidth - indent.length
      );
      if (text.length <= endStep) return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else end = lineWidth - indentAtStart;
      }
      let split = undefined;
      let prev = undefined;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1) end = i + endStep;
      }
      for (let ch; (ch = text[(i += 1)]); ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = undefined;
        } else {
          if (
            ch === " " &&
            prev &&
            prev !== " " &&
            prev !== "\n" &&
            prev !== "\t"
          ) {
            // space surrounded by non-space can be replaced with newline + indent
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "\t")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = undefined;
            } else if (mode === FOLD_QUOTED) {
              // white-space collected at end may stretch past lineWidth
              while (prev === " " || prev === "\t") {
                prev = ch;
                ch = text[(i += 1)];
                overflow = true;
              }
              // Account for newline escape, but don't break preceding escape
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              // Bail out if lineWidth & minContentWidth are shorter than an escape string
              if (escapedFolds[j]) return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = undefined;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow) onOverflow();
      if (folds.length === 0) return text;
      if (onFold) onFold();
      let res = text.slice(0, folds[0]);
      for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
      }
      return res;
    }
    /**
     * Presumes `i + 1` is at the start of a line
     * @returns index of last newline in more-indented block
     */
    function consumeMoreIndentedLines(text, i) {
      let ch = text[i + 1];
      while (ch === " " || ch === "\t") {
        do {
          ch = text[(i += 1)];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    }

    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;

    /***/
  },

  /***/ 8409: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var anchors = __nccwpck_require__(8459);
    var identity = __nccwpck_require__(5589);
    var stringifyComment = __nccwpck_require__(2950);
    var stringifyString = __nccwpck_require__(6226);

    function createStringifyContext(doc, options) {
      const opt = Object.assign(
        {
          blockQuote: true,
          commentString: stringifyComment.stringifyComment,
          defaultKeyType: null,
          defaultStringType: "PLAIN",
          directives: null,
          doubleQuotedAsJSON: false,
          doubleQuotedMinMultiLineLength: 40,
          falseStr: "false",
          flowCollectionPadding: true,
          indentSeq: true,
          lineWidth: 80,
          minContentWidth: 20,
          nullStr: "null",
          simpleKeys: false,
          singleQuote: null,
          trueStr: "true",
          verifyAliasOrder: true,
        },
        doc.schema.toStringOptions,
        options
      );
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep:
          typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt,
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) ?? match[0];
      }
      let tagObj = undefined;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        const match = tags.filter((t) => t.identify?.(obj));
        tagObj =
          match.find((t) => t.format === item.format) ??
          match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    // needs to be called before value stringifier to allow for circular anchor refs
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives) return "";
      const props = [];
      const anchor =
        (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag) props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives) return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(
            `Cannot stringify circular structure without alias nodes`
          );
        } else {
          if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
          else ctx.resolvedAliases = new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = undefined;
      const node = identity.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: (o) => (tagObj = o) });
      if (!tagObj) tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str =
        typeof tagObj.stringify === "function"
          ? tagObj.stringify(node, ctx, onComment, onChompKeep)
          : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
      if (!props) return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "["
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
    }

    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify;

    /***/
  },

  /***/ 2466: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Collection = __nccwpck_require__(3466);
    var identity = __nccwpck_require__(5589);
    var stringify = __nccwpck_require__(8409);
    var stringifyComment = __nccwpck_require__(2950);

    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify = flow
        ? stringifyFlowCollection
        : stringifyBlockCollection;
      return stringify(collection, ctx, options);
    }
    function stringifyBlockCollection(
      { comment, items },
      ctx,
      { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }
    ) {
      const {
        indent,
        options: { commentString },
      } = ctx;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        type: null,
      });
      let chompKeep = false; // flag for the preceding node's status
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore) lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment) comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore) lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str = stringify.stringify(
          item,
          itemCtx,
          () => (comment = null),
          () => (chompKeep = true)
        );
        if (comment)
          str += stringifyComment.lineComment(
            str,
            itemIndent,
            commentString(comment)
          );
        if (chompKeep && comment) chompKeep = false;
        lines.push(blockItemPrefix + str);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `\n${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str +=
          "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment) onComment();
      } else if (chompKeep && onChompKeep) onChompKeep();
      return str;
    }
    function stringifyFlowCollection(
      { comment, items },
      ctx,
      { flowChars, itemIndent, onComment }
    ) {
      const {
        indent,
        indentStep,
        flowCollectionPadding: fcPadding,
        options: { commentString },
      } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null,
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore) lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment) comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore) lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment) reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment) comment = iv.comment;
            if (iv.commentBefore) reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment) reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1) str += ",";
        if (comment)
          str += stringifyComment.lineComment(
            str,
            itemIndent,
            commentString(comment)
          );
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      let str;
      const { start, end } = flowChars;
      if (lines.length === 0) {
        str = start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline =
            len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
          str = start;
          for (const line of lines)
            str += line ? `\n${indentStep}${indent}${line}` : "\n";
          str += `\n${indent}${end}`;
        } else {
          str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
      if (comment) {
        str += stringifyComment.lineComment(
          str,
          indent,
          commentString(comment)
        );
        if (onComment) onComment();
      }
      return str;
    }
    function addCommentBefore(
      { indent, options: { commentString } },
      lines,
      comment,
      chompKeep
    ) {
      if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(
          commentString(comment),
          indent
        );
        lines.push(ic.trimStart()); // Avoid double indent on first line
      }
    }

    exports.stringifyCollection = stringifyCollection;

    /***/
  },

  /***/ 2950: /***/ (__unused_webpack_module, exports) => {
    /**
     * Stringifies a comment.
     *
     * Empty comment lines are left empty,
     * lines consisting of a single space are replaced by `#`,
     * and all other lines are prefixed with a `#`.
     */
    const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment)) return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    const lineComment = (str, indent, comment) =>
      str.endsWith("\n")
        ? indentComment(comment, indent)
        : comment.includes("\n")
          ? "\n" + indentComment(comment, indent)
          : (str.endsWith(" ") ? "" : " ") + comment;

    exports.indentComment = indentComment;
    exports.lineComment = lineComment;
    exports.stringifyComment = stringifyComment;

    /***/
  },

  /***/ 5225: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var stringify = __nccwpck_require__(8409);
    var stringifyComment = __nccwpck_require__(2950);

    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart) hasDirectives = true;
      }
      if (hasDirectives) lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1) lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives) lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          // top-level block scalars need to be indented if followed by a comment
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment
          ? undefined
          : () => (chompKeep = true);
        let body = stringify.stringify(
          doc.contents,
          ctx,
          () => (contentComment = null),
          onChompKeep
        );
        if (contentComment)
          body += stringifyComment.lineComment(
            body,
            "",
            commentString(contentComment)
          );
        if (
          (body[0] === "|" || body[0] === ">") &&
          lines[lines.length - 1] === "---"
        ) {
          // Top-level block scalars with a preceding doc marker ought to use the
          // same line for their header.
          lines[lines.length - 1] = `--- ${body}`;
        } else lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }

    exports.stringifyDocument = stringifyDocument;

    /***/
  },

  /***/ 4174: /***/ (__unused_webpack_module, exports) => {
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint") return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (
        !format &&
        minFractionDigits &&
        (!tag || tag === "tag:yaml.org,2002:float") &&
        /^\d/.test(n)
      ) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0) n += "0";
      }
      return n;
    }

    exports.stringifyNumber = stringifyNumber;

    /***/
  },

  /***/ 4875: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);
    var Scalar = __nccwpck_require__(9338);
    var stringify = __nccwpck_require__(8409);
    var stringifyComment = __nccwpck_require__(2950);

    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const {
        allNullValues,
        doc,
        indent,
        indentStep,
        options: { commentString, indentSeq, simpleKeys },
      } = ctx;
      let keyComment = (identity.isNode(key) && key.comment) || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key)) {
          const msg =
            "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey =
        !simpleKeys &&
        (!key ||
          (keyComment && value == null && !ctx.inFlow) ||
          identity.isCollection(key) ||
          (identity.isScalar(key)
            ? key.type === Scalar.Scalar.BLOCK_FOLDED ||
              key.type === Scalar.Scalar.BLOCK_LITERAL
            : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep,
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(
        key,
        ctx,
        () => (keyCommentDone = true),
        () => (chompKeep = true)
      );
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error(
            "With simple keys, single line scalar must not span more than 1024 characters"
          );
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment) onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (
        (allNullValues && !simpleKeys) ||
        (value == null && explicitKey)
      ) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(
            str,
            ctx.indent,
            commentString(keyComment)
          );
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str;
      }
      if (keyCommentDone) keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(
            str,
            ctx.indent,
            commentString(keyComment)
          );
        str = `? ${str}\n${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(
            str,
            ctx.indent,
            commentString(keyComment)
          );
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object") value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (
        !indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        identity.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor
      ) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(
        value,
        ctx,
        () => (valueCommentDone = true),
        () => (chompKeep = true)
      );
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n") ws = "\n\n";
        } else {
          ws += `\n${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (
              vs0 === "&" &&
              sp0 !== -1 &&
              sp0 < nl0 &&
              valueStr[sp0 + 1] === "!"
            ) {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
          }
          if (!hasPropsLine) ws = `\n${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment) onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(
          str,
          ctx.indent,
          commentString(valueComment)
        );
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }

    exports.stringifyPair = stringifyPair;

    /***/
  },

  /***/ 6226: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var Scalar = __nccwpck_require__(9338);
    var foldFlowLines = __nccwpck_require__(2889);

    const getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth,
    });
    // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
    // presume that's starting a new document.
    const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0) return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit) return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit) return true;
          start = i + 1;
          if (strLen - start <= limit) return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON) return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          // space before newline needs to be escaped to not be folded
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (
                implicitKey ||
                json[i + 2] === '"' ||
                json.length < minMultiLineLength
              ) {
                i += 1;
              } else {
                // folding will eat first newline
                str += json.slice(start, i) + "\n\n";
                while (
                  json[i + 2] === "\\" &&
                  json[i + 3] === "n" &&
                  json[i + 4] !== '"'
                ) {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                // space after newline needs to be escaped to not be folded
                if (json[i + 2] === " ") str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(
            str,
            indent,
            foldFlowLines.FOLD_QUOTED,
            getFoldOptions(ctx, false)
          );
    }
    function singleQuotedString(value, ctx) {
      if (
        ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes("\n")) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
      )
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res =
        "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
      return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(
            res,
            indent,
            foldFlowLines.FOLD_FLOW,
            getFoldOptions(ctx, false)
          );
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false) qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle) qs = singleQuotedString;
        else if (hasSingle && !hasDouble) qs = doubleQuotedString;
        else qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    // The negative lookbehind avoids a polynomial search,
    // but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
    let blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString(
      { comment, type, value },
      ctx,
      onComment,
      onChompKeep
    ) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      // 1. Block can't end in whitespace unless the last line is non-empty.
      // 2. Strings consisting of only whitespace are best rendered explicitly.
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent =
        ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal =
        blockQuote === "literal"
          ? true
          : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
              ? true
              : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value) return literal ? "|\n" : ">\n";
      // determine chomping from whitespace at value end
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "\t" && ch !== " ") break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-"; // strip
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+"; // keep
        if (onChompKeep) onChompKeep();
      } else {
        chomp = ""; // clip
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n") end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      // determine indent indicator from whitespace at value start
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ") startWithSpace = true;
        else if (ch === "\n") startNlPos = startEnd;
        else break;
      }
      let start = value.substring(
        0,
        startNlPos < startEnd ? startNlPos + 1 : startEnd
      );
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1"; // root is at -1
      let header =
        (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment) onComment();
      }
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
      }
      value = value
        .replace(/\n+/g, "\n$&")
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2") // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines.foldFlowLines(
        `${start}${value}${end}`,
        indent,
        foldFlowLines.FOLD_BLOCK,
        getFoldOptions(ctx, true)
      );
      return `${header}\n${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (
        (implicitKey && value.includes("\n")) ||
        (inFlow && /[[\]{},]/.test(value))
      ) {
        return quotedString(value, ctx);
      }
      if (
        !value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(
          value
        )
      ) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes("\n")
          ? quotedString(value, ctx)
          : blockString(item, ctx, onComment, onChompKeep);
      }
      if (
        !implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes("\n")
      ) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&\n${indent}`);
      // Verify that output will be parsed as a string, as e.g. plain numbers and
      // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
      // and others in v1.1.
      if (actualString) {
        const test = (tag) =>
          tag.default &&
          tag.tag !== "tag:yaml.org,2002:str" &&
          tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(
            str,
            indent,
            foldFlowLines.FOLD_FLOW,
            getFoldOptions(ctx, false)
          );
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss =
        typeof item.value === "string"
          ? item
          : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow
              ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
              : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }

    exports.stringifyString = stringifyString;

    /***/
  },

  /***/ 6796: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
    var identity = __nccwpck_require__(5589);

    const BREAK = Symbol("break visit");
    const SKIP = Symbol("skip children");
    const REMOVE = Symbol("remove node");
    /**
     * Apply a visitor to an AST node or document.
     *
     * Walks through the tree (depth-first) starting from `node`, calling a
     * `visitor` function with three arguments:
     *   - `key`: For sequence values and map `Pair`, the node's index in the
     *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
     *     `null` for the root node.
     *   - `node`: The current node.
     *   - `path`: The ancestry of the current node.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this node, continue with next
     *     sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current node, then continue with the next one
     *   - `Node`: Replace the current node, then continue by visiting it
     *   - `number`: While iterating the items of a sequence or map, set the index
     *     of the next step. This is useful especially if the index of the current
     *     node has changed.
     *
     * If `visitor` is a single function, it will be called with all values
     * encountered in the tree, including e.g. `null` values. Alternatively,
     * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
     * `Alias` and `Scalar` node. To define the same visitor function for more than
     * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
     * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
     * specific defined one will be used for each node.
     */
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE) node.contents = null;
      } else visit_(null, node, visitor_, Object.freeze([]));
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visit.BREAK = BREAK;
    /** Do not visit the children of the current node */
    visit.SKIP = SKIP;
    /** Remove the current node */
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
      const ctrl = callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path);
            if (typeof ci === "number") i = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = visit_("key", node.key, visitor, path);
          if (ck === BREAK) return BREAK;
          else if (ck === REMOVE) node.key = null;
          const cv = visit_("value", node.value, visitor, path);
          if (cv === BREAK) return BREAK;
          else if (cv === REMOVE) node.value = null;
        }
      }
      return ctrl;
    }
    /**
     * Apply an async visitor to an AST node or document.
     *
     * Walks through the tree (depth-first) starting from `node`, calling a
     * `visitor` function with three arguments:
     *   - `key`: For sequence values and map `Pair`, the node's index in the
     *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
     *     `null` for the root node.
     *   - `node`: The current node.
     *   - `path`: The ancestry of the current node.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `Promise`: Must resolve to one of the following values
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this node, continue with next
     *     sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current node, then continue with the next one
     *   - `Node`: Replace the current node, then continue by visiting it
     *   - `number`: While iterating the items of a sequence or map, set the index
     *     of the next step. This is useful especially if the index of the current
     *     node has changed.
     *
     * If `visitor` is a single function, it will be called with all values
     * encountered in the tree, including e.g. `null` values. Alternatively,
     * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
     * `Alias` and `Scalar` node. To define the same visitor function for more than
     * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
     * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
     * specific defined one will be used for each node.
     */
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(
          null,
          node.contents,
          visitor_,
          Object.freeze([node])
        );
        if (cd === REMOVE) node.contents = null;
      } else await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visitAsync.BREAK = BREAK;
    /** Do not visit the children of the current node */
    visitAsync.SKIP = SKIP;
    /** Remove the current node */
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path) {
      const ctrl = await callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path);
            if (typeof ci === "number") i = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path);
          if (ck === BREAK) return BREAK;
          else if (ck === REMOVE) node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path);
          if (cv === BREAK) return BREAK;
          else if (cv === REMOVE) node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (
        typeof visitor === "object" &&
        (visitor.Collection || visitor.Node || visitor.Value)
      ) {
        return Object.assign(
          {
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node,
          },
          visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value,
          },
          visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection,
          },
          visitor
        );
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path) {
      if (typeof visitor === "function") return visitor(key, node, path);
      if (identity.isMap(node)) return visitor.Map?.(key, node, path);
      if (identity.isSeq(node)) return visitor.Seq?.(key, node, path);
      if (identity.isPair(node)) return visitor.Pair?.(key, node, path);
      if (identity.isScalar(node)) return visitor.Scalar?.(key, node, path);
      if (identity.isAlias(node)) return visitor.Alias?.(key, node, path);
      return undefined;
    }
    function replaceNode(key, path, node) {
      const parent = path[path.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key") parent.key = node;
        else parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }

    exports.visit = visit;
    exports.visitAsync = visitAsync;

    /***/
  },

  /***/ 8572: /***/ (
    __unused_webpack_module,
    __unused_webpack_exports,
    __nccwpck_require__
  ) => {
    /* c8 ignore start */
    // 64 KiB (same size chrome slice theirs blob into Uint8array's)
    const POOL_SIZE = 65536;

    if (!globalThis.ReadableStream) {
      // `node:stream/web` got introduced in v16.5.0 as experimental
      // and it's preferred over the polyfilled version. So we also
      // suppress the warning that gets emitted by NodeJS for using it.
      try {
        const process = __nccwpck_require__(7742);
        const { emitWarning } = process;
        try {
          process.emitWarning = () => {};
          Object.assign(globalThis, __nccwpck_require__(2477));
          process.emitWarning = emitWarning;
        } catch (error) {
          process.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        // fallback to polyfill implementation
        Object.assign(globalThis, __nccwpck_require__(1452));
      }
    }

    try {
      // Don't use node: prefix for this, require+node: is not supported until node v14.14
      // Only `import()` can use prefix in 12.20 and later
      const { Blob } = __nccwpck_require__(4300);
      if (Blob && !Blob.prototype.stream) {
        Blob.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;

          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(
                position,
                Math.min(blob.size, position + POOL_SIZE)
              );
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));

              if (position === blob.size) {
                ctrl.close();
              }
            },
          });
        };
      }
    } catch (error) {}
    /* c8 ignore end */

    /***/
  },

  /***/ 3213: /***/ (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __nccwpck_require__
  ) => {
    /* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
      /* harmony export */ Z: () => __WEBPACK_DEFAULT_EXPORT__,
      /* harmony export */
    });
    /* unused harmony export File */
    /* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ =
      __nccwpck_require__(1410);

    const _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__ /* ["default"] */.Z {
      #lastModified = 0;
      #name = "";

      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */ // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(
            `Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        super(fileBits, options);

        if (options === null) options = {};

        // Simulate WebIDL type casting for NaN value in lastModified option.
        const lastModified =
          options.lastModified === undefined
            ? Date.now()
            : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }

        this.#name = String(fileName);
      }

      get name() {
        return this.#name;
      }

      get lastModified() {
        return this.#lastModified;
      }

      get [Symbol.toStringTag]() {
        return "File";
      }

      static [Symbol.hasInstance](object) {
        return (
          !!object &&
          object instanceof
            _index_js__WEBPACK_IMPORTED_MODULE_0__ /* ["default"] */.Z &&
          /^(File)$/.test(object[Symbol.toStringTag])
        );
      }
    };

    /** @type {typeof globalThis.File} */ // @ts-ignore
    const File = _File;
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = File;

    /***/
  },

  /***/ 2777: /***/ (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __nccwpck_require__
  ) => {
    // EXPORTS
    __nccwpck_require__.d(__webpack_exports__, {
      $B: () => /* reexport */ file /* default */.Z,
    }); // CONCATENATED MODULE: external "node:fs"

    // UNUSED EXPORTS: Blob, blobFrom, blobFromSync, default, fileFrom, fileFromSync

    const external_node_fs_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
      import.meta.url
    )("node:fs"); // CONCATENATED MODULE: external "node:path"
    const external_node_path_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
      import.meta.url
    )("node:path");
    // EXTERNAL MODULE: ./node_modules/node-domexception/index.js
    var node_domexception = __nccwpck_require__(7760);
    // EXTERNAL MODULE: ./node_modules/fetch-blob/file.js
    var file = __nccwpck_require__(3213);
    // EXTERNAL MODULE: ./node_modules/fetch-blob/index.js
    var fetch_blob = __nccwpck_require__(1410); // CONCATENATED MODULE: ./node_modules/fetch-blob/from.js
    const { stat } = external_node_fs_namespaceObject.promises;

    /**
     * @param {string} path filepath on the disk
     * @param {string} [type] mimetype to use
     */
    const blobFromSync = (path, type) => fromBlob(statSync(path), path, type);

    /**
     * @param {string} path filepath on the disk
     * @param {string} [type] mimetype to use
     * @returns {Promise<Blob>}
     */
    const blobFrom = (path, type) =>
      stat(path).then((stat) => fromBlob(stat, path, type));

    /**
     * @param {string} path filepath on the disk
     * @param {string} [type] mimetype to use
     * @returns {Promise<File>}
     */
    const fileFrom = (path, type) =>
      stat(path).then((stat) => fromFile(stat, path, type));

    /**
     * @param {string} path filepath on the disk
     * @param {string} [type] mimetype to use
     */
    const fileFromSync = (path, type) => fromFile(statSync(path), path, type);

    // @ts-ignore
    const fromBlob = (stat, path, type = "") =>
      new Blob(
        [
          new BlobDataItem({
            path,
            size: stat.size,
            lastModified: stat.mtimeMs,
            start: 0,
          }),
        ],
        { type }
      );

    // @ts-ignore
    const fromFile = (stat, path, type = "") =>
      new File(
        [
          new BlobDataItem({
            path,
            size: stat.size,
            lastModified: stat.mtimeMs,
            start: 0,
          }),
        ],
        basename(path),
        { type, lastModified: stat.mtimeMs }
      );

    /**
     * This is a blob backed up by a file on the disk
     * with minium requirement. Its wrapped around a Blob as a blobPart
     * so you have no direct access to this.
     *
     * @private
     */
    class BlobDataItem {
      #path;
      #start;

      constructor(options) {
        this.#path = options.path;
        this.#start = options.start;
        this.size = options.size;
        this.lastModified = options.lastModified;
      }

      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new BlobDataItem({
          path: this.#path,
          lastModified: this.lastModified,
          size: end - start,
          start: this.#start + start,
        });
      }

      async *stream() {
        const { mtimeMs } = await stat(this.#path);
        if (mtimeMs > this.lastModified) {
          throw new DOMException(
            "The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.",
            "NotReadableError"
          );
        }
        yield* createReadStream(this.#path, {
          start: this.#start,
          end: this.#start + this.size - 1,
        });
      }

      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }

    /* harmony default export */ const from =
      /* unused pure expression or super */ null && blobFromSync;

    /***/
  },

  /***/ 1410: /***/ (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __nccwpck_require__
  ) => {
    /* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
      /* harmony export */ Z: () => __WEBPACK_DEFAULT_EXPORT__,
      /* harmony export */
    });
    /* unused harmony export Blob */
    /* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ =
      __nccwpck_require__(8572);
    /*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

    // TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
    // Node has recently added whatwg stream into core

    // 64 KiB (same size chrome slice theirs blob into Uint8array's)
    const POOL_SIZE = 65536;

    /** @param {(Blob | Uint8Array)[]} parts */
    async function* toIterator(parts, clone = true) {
      for (const part of parts) {
        if ("stream" in part) {
          yield* /** @type {AsyncIterableIterator<Uint8Array>} */ (
            part.stream()
          );
        } else if (ArrayBuffer.isView(part)) {
          if (clone) {
            let position = part.byteOffset;
            const end = part.byteOffset + part.byteLength;
            while (position !== end) {
              const size = Math.min(end - position, POOL_SIZE);
              const chunk = part.buffer.slice(position, position + size);
              position += chunk.byteLength;
              yield new Uint8Array(chunk);
            }
          } else {
            yield part;
          }
          /* c8 ignore next 10 */
        } else {
          // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
          let position = 0,
            b = /** @type {Blob} */ (part);
          while (position !== b.size) {
            const chunk = b.slice(
              position,
              Math.min(b.size, position + POOL_SIZE)
            );
            const buffer = await chunk.arrayBuffer();
            position += buffer.byteLength;
            yield new Uint8Array(buffer);
          }
        }
      }
    }

    const _Blob = class Blob {
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";

      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError(
            "Failed to construct 'Blob': The provided value cannot be converted to a sequence."
          );
        }

        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError(
            "Failed to construct 'Blob': The object must have a callable @@iterator property."
          );
        }

        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError(
            "Failed to construct 'Blob': parameter 2 cannot convert to dictionary."
          );
        }

        if (options === null) options = {};

        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(
              element.buffer.slice(
                element.byteOffset,
                element.byteOffset + element.byteLength
              )
            );
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }

          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }

        this.#endings = `${options.endings === undefined ? "transparent" : options.endings}`;
        const type = options.type === undefined ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }

      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }

      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }

      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        // More optimized than using this.arrayBuffer()
        // that requires twice as much ram
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        // Remaining
        str += decoder.decode();
        return str;
      }

      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        // Easier way... Just a unnecessary overhead
        // const view = new Uint8Array(this.size);
        // await this.stream().getReader({mode: 'byob'}).read(view);
        // return view.buffer;

        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }

        return data.buffer;
      }

      stream() {
        const it = toIterator(this.#parts, true);

        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },

          async cancel() {
            await it.return();
          },
        });
      }

      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;

        let relativeStart =
          start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd =
          end < 0 ? Math.max(size + end, 0) : Math.min(end, size);

        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;

        for (const part of parts) {
          // don't add the overflow to new blobParts
          if (added >= span) {
            break;
          }

          const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size <= relativeStart) {
            // Skip the beginning and change the relative
            // start & end position as we skip the unwanted parts
            relativeStart -= size;
            relativeEnd -= size;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size;
            blobParts.push(chunk);
            relativeStart = 0; // All next sequential parts should start at 0
          }
        }

        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;

        return blob;
      }

      get [Symbol.toStringTag]() {
        return "Blob";
      }

      static [Symbol.hasInstance](object) {
        return (
          object &&
          typeof object === "object" &&
          typeof object.constructor === "function" &&
          (typeof object.stream === "function" ||
            typeof object.arrayBuffer === "function") &&
          /^(Blob|File)$/.test(object[Symbol.toStringTag])
        );
      }
    };

    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true },
    });

    /** @type {typeof globalThis.Blob} */
    const Blob = _Blob;
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = Blob;

    /***/
  },

  /***/ 8010: /***/ (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __nccwpck_require__
  ) => {
    /* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
      /* harmony export */ Ct: () => /* binding */ FormData,
      /* harmony export */ au: () => /* binding */ formDataToBlob,
      /* harmony export */
    });
    /* unused harmony export File */
    /* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ =
      __nccwpck_require__(1410);
    /* harmony import */ var fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ =
      __nccwpck_require__(3213);
    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

    var { toStringTag: t, iterator: i, hasInstance: h } = Symbol,
      r = Math.random,
      m =
        "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(
          ","
        ),
      f = (a, b, c) => (
        (a += ""),
        /^(Blob|File)$/.test(b && b[t])
          ? [
              ((c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob"),
              a),
              b.name !== c || b[t] == "blob"
                ? new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ /* ["default"] */.Z(
                    [b],
                    c,
                    b
                  )
                : b,
            ]
          : [a, b + ""]
      ),
      e = (c, f) =>
        (f ? c : c.replace(/\r?\n|\r/g, "\r\n"))
          .replace(/\n/g, "%0A")
          .replace(/\r/g, "%0D")
          .replace(/"/g, "%22"),
      x = (n, a, e) => {
        if (a.length < e) {
          throw new TypeError(
            `Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`
          );
        }
      };

    const File = /* unused pure expression or super */ null && F;

    /** @type {typeof globalThis.FormData} */
    const FormData = class FormData {
      #d = [];
      constructor(...a) {
        if (a.length)
          throw new TypeError(
            `Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`
          );
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return (
          o &&
          typeof o === "object" &&
          o[t] === "FormData" &&
          !m.some((m) => typeof o[m] != "function")
        );
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a) return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this) a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [],
          c = !0;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this) yield a;
      }
      *values() {
        for (var [, a] of this) yield a;
      }
    };

    /** @param {FormData} F */
    function formDataToBlob(
      F,
      B = fetch_blob__WEBPACK_IMPORTED_MODULE_0__ /* ["default"] */.Z
    ) {
      var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"),
        c = [],
        p = `--${b}\r\nContent-Disposition: form-data; name="`;
      F.forEach((v, n) =>
        typeof v == "string"
          ? c.push(
              p +
                e(n) +
                `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r\n`
            )
          : c.push(
              p +
                e(n) +
                `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`,
              v,
              "\r\n"
            )
      );
      c.push(`--${b}--`);
      return new B(c, { type: "multipart/form-data; boundary=" + b });
    }

    /***/
  },

  /******/
};
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/
/******/ // The require function
/******/ function __nccwpck_require__(moduleId) {
  /******/ // Check if module is in cache
  /******/ var cachedModule = __webpack_module_cache__[moduleId];
  /******/ if (cachedModule !== undefined) {
    /******/ return cachedModule.exports;
    /******/
  }
  /******/ // Create a new module (and put it into the cache)
  /******/ var module = (__webpack_module_cache__[moduleId] = {
    /******/ // no module.id needed
    /******/ // no module.loaded needed
    /******/ exports: {},
    /******/
  });
  /******/
  /******/ // Execute the module function
  /******/ var threw = true;
  /******/ try {
    /******/ __webpack_modules__[moduleId].call(
      module.exports,
      module,
      module.exports,
      __nccwpck_require__
    );
    /******/ threw = false;
    /******/
  } finally {
    /******/ if (threw) delete __webpack_module_cache__[moduleId];
    /******/
  }
  /******/
  /******/ // Return the exports of the module
  /******/ return module.exports;
  /******/
}
/******/
/******/ // expose the modules object (__webpack_modules__)
/******/ __nccwpck_require__.m = __webpack_modules__;
/******/
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/ __nccwpck_require__.n = (module) => {
    /******/ var getter =
      module && module.__esModule
        ? /******/ () => module["default"]
        : /******/ () => module;
    /******/ __nccwpck_require__.d(getter, { a: getter });
    /******/ return getter;
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
  /******/ // define getter functions for harmony exports
  /******/ __nccwpck_require__.d = (exports, definition) => {
    /******/ for (var key in definition) {
      /******/ if (
        __nccwpck_require__.o(definition, key) &&
        !__nccwpck_require__.o(exports, key)
      ) {
        /******/ Object.defineProperty(exports, key, {
          enumerable: true,
          get: definition[key],
        });
        /******/
      }
      /******/
    }
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
  /******/ __nccwpck_require__.f = {};
  /******/ // This file contains only the entry chunk.
  /******/ // The chunk loading function for additional chunks
  /******/ __nccwpck_require__.e = (chunkId) => {
    /******/ return Promise.all(
      Object.keys(__nccwpck_require__.f).reduce((promises, key) => {
        /******/ __nccwpck_require__.f[key](chunkId, promises);
        /******/ return promises;
        /******/
      }, [])
    );
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
  /******/ // This function allow to reference async chunks
  /******/ __nccwpck_require__.u = (chunkId) => {
    /******/ // return url for filenames based on template
    /******/ return "" + chunkId + ".index.js";
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
  /******/ __nccwpck_require__.o = (obj, prop) =>
    Object.prototype.hasOwnProperty.call(obj, prop);
  /******/
})();
/******/
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
  /******/ // define __esModule on exports
  /******/ __nccwpck_require__.r = (exports) => {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module",
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/compat */
/******/
/******/ if (typeof __nccwpck_require__ !== "undefined")
  __nccwpck_require__.ab =
    new URL(".", import.meta.url).pathname.slice(
      import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0,
      -1
    ) + "/";
/******/
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
  /******/ // no baseURI
  /******/
  /******/ // object to store loaded and loading chunks
  /******/ // undefined = chunk not loaded, null = chunk preloaded/prefetched
  /******/ // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
  /******/ var installedChunks = {
    /******/ 179: 0,
    /******/
  };
  /******/
  /******/ var installChunk = (data) => {
    /******/ var { ids, modules, runtime } = data;
    /******/ // add "modules" to the modules object,
    /******/ // then flag all "ids" as loaded and fire callback
    /******/ var moduleId,
      chunkId,
      i = 0;
    /******/ for (moduleId in modules) {
      /******/ if (__nccwpck_require__.o(modules, moduleId)) {
        /******/ __nccwpck_require__.m[moduleId] = modules[moduleId];
        /******/
      }
      /******/
    }
    /******/ if (runtime) runtime(__nccwpck_require__);
    /******/ for (; i < ids.length; i++) {
      /******/ chunkId = ids[i];
      /******/ if (
        __nccwpck_require__.o(installedChunks, chunkId) &&
        installedChunks[chunkId]
      ) {
        /******/ installedChunks[chunkId][0]();
        /******/
      }
      /******/ installedChunks[ids[i]] = 0;
      /******/
    }
    /******/
    /******/
  };
  /******/
  /******/ __nccwpck_require__.f.j = (chunkId, promises) => {
    /******/ // import() chunk loading for javascript
    /******/ var installedChunkData = __nccwpck_require__.o(
      installedChunks,
      chunkId
    )
      ? installedChunks[chunkId]
      : undefined;
    /******/ if (installedChunkData !== 0) {
      // 0 means "already installed".
      /******/
      /******/ // a Promise means "currently loading".
      /******/ if (installedChunkData) {
        /******/ promises.push(installedChunkData[1]);
        /******/
      } else {
        /******/ if (true) {
          // all chunks have JS
          /******/ // setup Promise in chunk cache
          /******/ var promise = import(
            "./" + __nccwpck_require__.u(chunkId)
          ).then(installChunk, (e) => {
            /******/ if (installedChunks[chunkId] !== 0)
              installedChunks[chunkId] = undefined;
            /******/ throw e;
            /******/
          });
          /******/ var promise = Promise.race([
            promise,
            new Promise(
              (resolve) =>
                (installedChunkData = installedChunks[chunkId] = [resolve])
            ),
          ]);
          /******/ promises.push((installedChunkData[1] = promise));
          /******/
        } else installedChunks[chunkId] = 0;
        /******/
      }
      /******/
    }
    /******/
  };
  /******/
  /******/ // no external install chunk
  /******/
  /******/ // no on chunks loaded
  /******/
})();
/******/
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
  // EXPORTS
  __nccwpck_require__.d(__webpack_exports__, {
    K: () => /* binding */ run,
  });

  // EXTERNAL MODULE: ./node_modules/@actions/core/lib/core.js
  var core = __nccwpck_require__(2186);
  // EXTERNAL MODULE: ./node_modules/fs-extra/lib/index.js
  var lib = __nccwpck_require__(5630);
  var lib_default = /*#__PURE__*/ __nccwpck_require__.n(lib);
  // EXTERNAL MODULE: external "os"
  var external_os_ = __nccwpck_require__(2037);
  // EXTERNAL MODULE: external "path"
  var external_path_ = __nccwpck_require__(1017);
  var external_path_default =
    /*#__PURE__*/ __nccwpck_require__.n(external_path_); // CONCATENATED MODULE: external "child_process"
  const external_child_process_namespaceObject =
    __WEBPACK_EXTERNAL_createRequire(import.meta.url)("child_process");
  var external_child_process_default = /*#__PURE__*/ __nccwpck_require__.n(
    external_child_process_namespaceObject
  );
  // EXTERNAL MODULE: external "https"
  var external_https_ = __nccwpck_require__(5687);
  var external_https_default =
    /*#__PURE__*/ __nccwpck_require__.n(external_https_);
  // EXTERNAL MODULE: ./node_modules/adm-zip/adm-zip.js
  var adm_zip = __nccwpck_require__(6761);
  var adm_zip_default = /*#__PURE__*/ __nccwpck_require__.n(adm_zip);
  // EXTERNAL MODULE: ./node_modules/plist/index.js
  var plist = __nccwpck_require__(1933);
  var plist_default = /*#__PURE__*/ __nccwpck_require__.n(plist); // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/array.js
  /**
   * Create a generator that yields each
   * subsequent number from some start point
   * to some end point (inclusive). If the
   * second number is smaller than the first,
   * will yield descending. Numbers are floored.
   */
  function* nextNumberUntil(start, end) {
    start = Math.floor(start);
    end = Math.floor(end);
    const descending = start > end;
    for (
      let i = start;
      descending ? i >= end : i <= end;
      descending ? i-- : i++
    ) {
      yield i;
    }
  }
  /* harmony default export */ const array = { nextNumberUntil };
  function array_literal(v) {
    return v;
  }
  function filterTruthy(array) {
    return array.filter((x) => x);
  }
  function filterDefined(array) {
    return array.filter((x) => x !== undefined);
  }
  function filterNotNullish(array) {
    return array.filter((x) => ![undefined, null].includes(x));
  }
  /**
   * If the provided value is not an array,
   * wrap it in an array. If the value is undefined
   * will return an empty array.
   */
  function arrayWrapped(item) {
    if (Array.isArray(item)) {
      // @ts-expect-error Help! Does work, but Typescript doesn't like it.
      return item;
    }
    // @ts-expect-error Help! Does work, but Typescript doesn't like it.
    return typeof item == "undefined" ? [] : [item];
  }
  /**
   * Return `true` if the `comparison` function returns true
   * when applied to each adjacent pair of values. For example,
   * can be used to determine if an array of numbers is increasing
   * with `(current,last)=>current>last`.
   *
   * If the array has zero or one entry, `true`
   * is returned.
   */
  function arrayEveryPair(arrayOfComparables, comparison) {
    return arrayOfComparables.every((value, i) => {
      if (i === 0) {
        return true;
      }
      return comparison(value, arrayOfComparables[i - 1]);
    });
  }
  function arrayWithoutNullish(array) {
    return array.filter((x) => ![undefined, null].includes(x));
  }
  /**
   * Return true if each value is greater than the last
   */
  function arrayIsIncreasing(increasingArray) {
    return arrayEveryPair(increasingArray, (curr, last) => curr > last);
  }
  /**
   * Returns `true` if every entry is the same.
   * Uses a strict-equal (`===`) comparison by
   * default.
   */
  function array_arrayIsDuplicates(arr, options) {
    return arrayEveryPair(arr, (a, b) => (options?.loose ? a == b : a === b));
  }
  /**
   * Return true if each value is greater than the last
   */
  function arrayIsDecreasing(decreasingArray) {
    return arrayEveryPair(decreasingArray, (curr, last) => curr < last);
  }
  /**
   * If not an array, return self. Otherwise return 0th item.
   */
  function arrayUnwrapped(items) {
    if (items instanceof Array) {
      // @ts-expect-error can't figure out how to get this to behave,
      // but it does work as intended!
      return items[0];
    }
    // @ts-expect-error (see prior comment)
    return items;
  }
  function sortResult(
    numbersOrArrayItem1,
    array2ItemOrDescending,
    descending = false
  ) {
    if (typeof numbersOrArrayItem1 == "number") {
      if (typeof array2ItemOrDescending != "number") {
        throw new Error("Second argument must be a number");
      }
      const diff = numbersOrArrayItem1 - array2ItemOrDescending;
      // @ts-ignore
      return descending ? -diff : diff;
    } else if (Array.isArray(numbersOrArrayItem1)) {
      // @ts-ignore
      return numbersOrArrayItem1.sort((a, b) => sortResult(a, b, descending));
    }
    throw new Error("Invalid arguments for arraySortNumeric");
  }
  function arraySortNumeric(numbersOrArrayItem1, array2Item) {
    // @ts-ignore
    return sortResult(numbersOrArrayItem1, array2Item);
  }
  function arraySortNumericDescending(numbersOrArrayItem1, array2Item) {
    // @ts-ignore
    return sortResult(numbersOrArrayItem1, array2Item, true);
  }
  /**
   * Find an object in an array by one of its fields.
   *
   * For the value, use {@link findByField}
   */
  function findIndexByField(arr, field, value) {
    return arr.findIndex((item) => item[field] === value);
  }
  /**
   * Find an object in an array by one of its fields.
   *
   * For the index position, use {@link findIndexByField}
   */
  function findByField(arr, field, value) {
    return arr[findIndexByField(arr, field, value)];
  }
  /**
   * Find an object in an array, and its index position, by one of its fields.
   */
  function findEntryAndIndexByField(arr, field, value) {
    const idx = arr.findIndex((item) => item[field] === value);
    return [arr[idx], idx];
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/constants.js
  //# sourceMappingURL=array.js.map
  /**
   * See {@link https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string}.
   *
   * Their docs are out of date for JavaScript:
   * replacing `"?P<"` with `"?<"` in the Perl-compatible regex
   * results in the JavaScript-compatible regex (with capture groups)
   * below.
   */
  const semverRegex =
    /^(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  const prereleaseRegex =
    /(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)/;
  const versionBumpLevels = [
    "major",
    "minor",
    "patch",
    "premajor",
    "preminor",
    "prepatch",
    "prerelease",
  ];
  Object.freeze(versionBumpLevels); // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/types.js
  //# sourceMappingURL=constants.js.map
  class types_BscotchUtilError extends Error {
    constructor(message, asserter) {
      super(message);
      this.name = "BscotchUtilError";
      Error.captureStackTrace(this, asserter || this.constructor);
    }
  }
  function types_assert(claim, message, stackStart) {
    if (!claim) {
      throw new types_BscotchUtilError(message, stackStart || types_assert);
    }
  }
  function isBoolean(thing) {
    return typeof thing === "boolean";
  }
  function isDate(thing) {
    return thing instanceof Date;
  }
  function isValidDate(thing) {
    return isDate(thing) && !isNaN(thing.getTime());
  }
  function types_assertValidDate(date) {
    types_assert(
      isValidDate(date),
      `${date} is not a valid date`,
      types_assertValidDate
    );
  }
  function isArray(thing) {
    return Array.isArray(thing);
  }
  function isEmptyArray(thing) {
    return isArray(thing) && thing.length === 0;
  }
  function isNonEmptyArray(thing) {
    return isArray(thing) && thing.length > 0;
  }
  function isNullish(thing) {
    return thing === null || thing === undefined;
  }
  function isDefined(thing) {
    return thing !== undefined;
  }
  function isNotNullish(thing) {
    return !isNullish(thing);
  }
  function isString(thing) {
    return typeof thing === "string";
  }
  function isNumber(thing) {
    return typeof thing === "number";
  }
  // We can make a function that checks if a string is empty or not,
  // where the return *type* is `true` if it is definitely empty, `false`
  // if it is definitely not empty, and the more general `boolean` if
  // we can't tell.
  function isEmptyString(thing) {
    return thing === "";
  }
  function isNonEmptyString(thing) {
    return isString(thing) && !isEmptyString(thing);
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/dates.js
  //# sourceMappingURL=types.js.map
  /** Positive if date2 is in the past. */
  function dateDifferenceMillis(date1, date2) {
    return date1.getTime() - date2.getTime();
  }
  /** Positive if date2 is in the past. */
  function dateDifferenceSeconds(date1, date2) {
    return dateDifferenceMillis(date1, date2) / 1000;
  }
  /** Positive if date2 is in the past. */
  function dateDifferenceMinutes(date1, date2) {
    return dateDifferenceSeconds(date1, date2) / 60;
  }
  /** Positive if date2 is in the past. */
  function dateDifferenceHours(date1, date2) {
    return dateDifferenceMinutes(date1, date2) / 60;
  }
  /** Positive if date2 is in the past. */
  function dateDifferenceDays(date1, date2) {
    return dateDifferenceHours(date1, date2) / 24;
  }
  function dateIsOlderThanMillisAgo(date, millisAgo) {
    return dateDifferenceMillis(new Date(), date) > millisAgo;
  }
  function dateIsOlderThanSecondsAgo(date, secondsAgo) {
    return dateIsOlderThanMillisAgo(date, secondsAgo * 1000);
  }
  function dateIsOlderThanMinutesAgo(date, minutes = 1) {
    return dateIsOlderThanSecondsAgo(date, 60 * minutes);
  }
  function dateIsOlderThanHoursAgo(date, hours = 1) {
    return dateIsOlderThanMinutesAgo(date, 60 * hours);
  }
  function dateIsOlderThanDaysAgo(date, days = 1) {
    return dateIsOlderThanHoursAgo(date, 24 * days);
  }
  function dateIsInTheFuture(date) {
    const nowInMilliseconds = Date.now();
    date = new Date(date);
    assertValidDate(date);
    const dateInMilliseconds = (date && date.getTime && date.getTime()) || 0;
    return dateInMilliseconds > nowInMilliseconds;
  }
  function dateIsInThePast(date) {
    return dateIsOlderThanSecondsAgo(date, 0);
  }
  function dateIsGreaterThan(date, otherDate) {
    assertValidDate(date);
    assertValidDate(otherDate);
    return date > otherDate;
  }
  function dateIsLessThan(date, otherDate) {
    assertValidDate(date);
    assertValidDate(otherDate);
    return date < otherDate;
  }
  function chronologySort(date1, date2) {
    assertValidDate(date1);
    assertValidDate(date2);
    return date1.getTime() - date2.getTime();
  }
  /** @alias chronologySort */
  const dateSort = /* unused pure expression or super */ null && chronologySort;
  function chronologySortReverse(date1, date2) {
    return chronologySort(date2, date1);
  }
  /** @alias chronologySortReverse */
  const dateSortDescending =
    /* unused pure expression or super */ null && chronologySortReverse;
  /**
   * Format a timestamp. Enforces UTC,
   * defaults to ISO 8601 extended.
   */
  function formatTimestamp(date, options) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();
    const hours = date.getUTCHours();
    const minutes = date.getUTCMinutes();
    const seconds = date.getUTCSeconds();
    const milliseconds = date.getUTCMilliseconds();
    let timestamp = [year, month, day]
      .map((n) => n.toString().padStart(2, "0"))
      .join(options?.dateSeparator ?? "-");
    if (!options?.excludeTime) {
      const timeParts = [
        hours,
        minutes,
        (seconds + milliseconds / 1000).toFixed(options?.secondsPrecision ?? 3),
      ];
      timestamp +=
        (options?.dateTimeSeparator ?? "T") +
        timeParts
          .map((n) => n.toString().padStart(2, "0"))
          .join(options?.timeSeparator ?? ":");
    }
    if (!options?.excludeTimezoneSuffix) {
      timestamp += "Z";
    }
    return timestamp;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/decorator.js
  //# sourceMappingURL=dates.js.map
  /**
   * Utilities for decorator functions.
   */

  function decorator_createDecorator(
    /**
     * The name of the decorator. This is used to provide a
     * function name to the decorator (useful for debugging
     * and logging).
     */
    name,
    /**
     * This function is called only once, when the decorator is
     * first evaluated at run-time. It can be used to set up a store,
     * mutate the
     * target function, log application initialization steps, etc.
     *
     * In the absence of the `before`, `after`, and related
     * lifecycle functions, this is essentially equivalent to
     * how you'd set up a decorator function, just with some
     * useful context already computed for you.
     */
    setup,
    options
  ) {
    const decorator = {
      [name]: function (...args) {
        const [target, propertyKey, descriptor] = args;
        const value = descriptor?.value;
        const isInstance = Object.hasOwn(target, "constructor");
        const decoratorType =
          typeof propertyKey === "undefined"
            ? "class"
            : typeof value === "function"
              ? "method"
              : "accessor";
        const classConstructor = isInstance ? target.constructor : target;
        const baseContext = {
          target,
          propertyKey,
          value,
          isStatic: !isInstance,
          classConstructor,
          className: isInstance ? target.constructor.name : target.name,
          descriptor,
          isAsync:
            decoratorType == "method" &&
            !!(value.constructor.name === "AsyncFunction"),
          type: decoratorType,
        };
        const store = setup?.(baseContext);
        // If any method hooks are used, need to set them up
        const usingLifecycleHooks =
          decoratorType === "method" &&
          options?.methodHooks &&
          Object.keys(options.methodHooks).length > 0;
        if (!usingLifecycleHooks) {
          return;
        }
        // Replace the original function with a wrapper function
        const hooks = options.methodHooks;
        descriptor.value = {
          // using an indexed object to allow dynamic naming
          // (for debugging purposes), calling lifecycle functions
          // as needed.
          [propertyKey]: function (...args) {
            const context = {
              ...baseContext,
              arguments: args,
              store,
            };
            // If we have a value from the `before` hook, use
            // that as the return value and skip the function call!
            const returned = hooks.before?.(context) ?? value.apply(this, args);
            const returnedContext = {
              ...context,
              returned,
              store,
            };
            const newReturned = hooks.after?.(returnedContext);
            if (hooks.afterResolved) {
              if (isPromiseLike(returned)) {
                void returned.then((resolved) => {
                  return hooks.afterResolved({
                    ...context,
                    returned: resolved,
                  });
                });
              } else {
                hooks.afterResolved(returnedContext);
              }
            }
            return typeof newReturned === "undefined" ? returned : newReturned;
          },
        }[propertyKey];
      },
    }[name];
    return decorator;
  }
  function hasFunction(value, functionName) {
    try {
      // @ts-ignore
      const func = value[functionName];
      types_assert(
        typeof func === "function",
        `Expected ${functionName} to be a function`
      );
      // @ts-ignore
      return value;
    } catch {}
    // @ts-ignore
    return false;
  }
  function isPromiseLike(result) {
    return hasFunction(result, "then");
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/jsonPointer.js
  //# sourceMappingURL=decorator.js.map
  class Pointable {
    target;
    pointer;
    constructor(target, pointer) {
      this.target = target;
      this.pointer = pointer;
    }
    at(path) {
      path = ensureParsedJsonPointer(path);
      return new Pointable(this.target, path);
    }
    get() {
      return getJsonPointerValue(this.target, this.pointer);
    }
    /**
     * Returns the value that was deleted, or `undefined` if
     * any keys along the pointer could not be resolved.
     */
    delete() {
      return deleteJsonPointerValue(this.target, this.pointer);
    }
    set(value, options) {
      return setJsonPointerValue(this.target, this.pointer, value, options);
    }
  }
  function pointable(value) {
    return new Pointable(value, []);
  }
  function setJsonPointerValue(object, _path, value, options) {
    const path = ensureParsedJsonPointer(_path);
    assert(
      path.length > 0,
      `Path must be non-empty, otherwise the value cannot be mutated.`
    );
    assert(
      object,
      `Can only set values when there is at least a root object/array.`
    );
    let [key] = path;
    const [, nextKey, ...rest] = path;
    // Make sure that the key type makes sense for the object type
    if (Array.isArray(object)) {
      assert(
        typeof key === "number" || key === "-",
        `Array keys must be numbers or '-'`
      );
      key = key === "-" ? object.length : key;
    } else {
      assert(
        typeof object === "object",
        `Pointer came across non-object/array value of type ${typeof object} at key ${key}`
      );
      key = String(key);
    }
    // If we're already at the end, set the value if possible.
    if (nextKey === undefined) {
      if (options?.noClobber && key in object && object[key] !== undefined) {
        // Then we don't want to clobber, just return what's there.
        return object[key];
      }
      object[key] = value;
      return value;
    }
    // Make sure that the key references an existing entry
    if (key in object) {
      assert(
        object[key] === undefined || typeof object[key] === "object",
        `The value at key ${key} is not an object or array, and therefore cannot be indexed with key ${nextKey}`
      );
    }
    if (!(key in object) || object[key] === undefined) {
      assert(options?.createMissing, `Upstream key ${key} does not exist.`);
      object[key] = typeof nextKey === "number" ? [] : {};
    }
    return setJsonPointerValue(object[key], [nextKey, ...rest], value, options);
  }
  /**
   * Given an input that is either a JSON Pointer string or
   * a parsed JSON Pointer array, return a parsed array.
   *
   * Performs a little validation/casting on inputs,
   * but does not guarantee that the output is a valid pointer.
   */
  function ensureParsedJsonPointer(pointer) {
    assert(
      typeof pointer === "string" || Array.isArray(pointer),
      "pointer must be a string or array"
    );
    assert(
      typeof pointer !== "string" || pointer === "" || pointer.startsWith("/"),
      'pointer must start with "/" or be an empty string'
    );
    pointer =
      typeof pointer === "string" ? pointer.split("/").slice(1) : pointer;
    return pointer.map((_part) => {
      const part =
        typeof _part === "string" && _part.match(/^\d+$/)
          ? Number(_part)
          : _part;
      assert(
        ["string", "number"].includes(typeof part),
        `pointer must be an array of strings and numbers: ${_part} is of type ${typeof _part}`
      );
      return part;
    });
  }
  function getJsonPointerValue(object, _path) {
    const path = ensureParsedJsonPointer(_path);
    if (path.length === 0) {
      return object;
    }
    const [key, ...rest] = path;
    // the `in` operator works for fields as strings and numbers,
    // whether the rhs is an array or object
    if (key in object) {
      return getJsonPointerValue(object[key], rest);
    }
    return undefined;
  }
  function deleteJsonPointerValue(object, _path) {
    const path = ensureParsedJsonPointer(_path);
    assert(path.length, `Cannot delete the root of an object`);
    const [key, ...rest] = path;
    // the `in` operator works for fields as strings and numbers,
    // whether the rhs is an array or object
    if (key in object) {
      if (rest.length === 0) {
        // Then we need to delete this key, if it exists
        const value = object[key];
        if (Array.isArray(object)) {
          if (key === "-") {
            return;
          }
          assert(
            typeof +key === "number" && !isNaN(+key),
            `Expected ${key} to be a number`
          );
          object.splice(+key, 1);
        } else {
          delete object[key];
        }
        return value;
      }
      return deleteJsonPointerValue(object[key], rest);
    }
    return undefined;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/markdown.js
  //# sourceMappingURL=jsonPointer.js.map
  /**
   * Given a Markdown table with a header row,
   * return an array of row objects with fields matching
   * the column name from the header.
   */
  function markdownTableToObjects(table, options) {
    const rowStrings = table.trim().split("\n");
    const rows = rowStrings.map((row) => {
      const columns = row.trim().split(/\s*\|\s*/);
      // First and last will be empty, so remove them
      columns.shift();
      columns.pop();
      return columns;
    });
    const headers = rows
      .shift()
      ?.map((header, headerIndex) =>
        options?.transformColumnName
          ? options.transformColumnName(header, headerIndex)
          : header
      );
    assert(headers?.length, "No headers found");
    const headerBreakRow = rows.shift();
    assert(
      headerBreakRow.every((col) => col.match(/^-+$/)),
      "Header break row is not all dashes"
    );
    const asObjects = rows.map((row, rowNumber) => {
      return headers.reduce((obj, header, columnNumber) => {
        if (typeof row[columnNumber] === "undefined") {
          return obj;
        }
        const value = options?.transformCellContent
          ? options.transformCellContent(
              row[columnNumber],
              rowNumber,
              columnNumber,
              header
            )
          : row[columnNumber];
        if (value === undefined) {
          return obj;
        }
        // @ts-ignore
        obj[header] = value;
        return obj;
      }, {});
    });
    return asObjects;
  }
  //# sourceMappingURL=markdown.js.map
  // EXTERNAL MODULE: ./node_modules/debug/src/index.js
  var src = __nccwpck_require__(8237); // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/trace.js
  const _traceDecoratorCache = {};
  const _traceCache = {};
  /**
   * Get a [debug](https://www.npmjs.com/package/debug) logging
   * function for a given namespace.
   *
   * @example
   * // For scope `DEBUG=@bscotch/my-package`
   * const trace = useTracer('@bscotch/my-package');
   * trace("Ooooh, a mesage!");
   *
   * // For scope `DEBUG=@bscotch/my-package:*`
   * const subTrace = debug.extend("more-specific");
   * subTrace("A more specific message!");
   */
  function useTracer(namespace) {
    const debug = _traceCache[namespace] || src(namespace);
    _traceCache[namespace] = debug;
    return debug;
  }
  /**
   * Get a "debug decorator" function for a given namespace. This
   * decorator uses the `debug` package to log method arguments
   * and return values.
   */
  function Trace(namespace) {
    _traceDecoratorCache[namespace] ||= createDecorator(
      "trace",
      (context) => {
        // If this is the class decorator, add a `trace` method
        if (context.type === "class") {
          context.classConstructor.prototype.trace = function trace(...args) {
            useTracer(`${namespace}:${context.className}:inline`)(...args);
          };
        } else if (context.type === "accessor") {
          const getter = context.descriptor.get;
          if (getter) {
            context.descriptor.get = function traceGetter() {
              const result = getter.call(this);
              useTracer(
                `${namespace}:${context.className}:${context.propertyKey}`
              )("getter result", simplify(result));
              return result;
            };
          }
        }
        return {
          debug: useTracer(
            `${namespace}:${context.className}:${context.propertyKey}`
          ),
        };
      },
      {
        methodHooks: {
          before(context) {
            context.store.debug("called with: %o", simplify(context.arguments));
          },
          afterResolved(context) {
            context.store.debug("returned: %o", simplify(context.returned));
          },
        },
      }
    );
    return _traceDecoratorCache[namespace];
  }
  function simplify(data) {
    const isArray = Array.isArray(data);
    const asArray = isArray ? data : [data];
    const simplified = [];
    for (const item of asArray) {
      const hasToJsonFunction = typeof item?.toJSON === "function";
      simplified.push(hasToJsonFunction ? item.toJSON() : item);
    }
    return isArray ? simplified : simplified[0];
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/memoize.lib.js
  //# sourceMappingURL=trace.js.map
  const trace = useTracer("@bscotch:Memoize");
  function isExpired(value) {
    return value.expiresAt && value.expiresAt <= new Date();
  }
  function canUseStaleWhileRevalidate(value) {
    return (
      value.staleWhileRevalidateUntil &&
      value.staleWhileRevalidateUntil >= new Date()
    );
  }
  function cacheHas(cache, key) {
    if (cache.has(key)) {
      // See if it has expired
      const value = cache.get(key);
      if (isExpired(value) && !canUseStaleWhileRevalidate(value)) {
        // Expired
        cache.delete(key);
      } else {
        return true;
      }
    }
    return false;
  }
  /**
   * Get a memoized value if it already exists, otherwise
   * call the value-generating function to create and store
   * it, and return that value.
   */
  function memoizedValue(
    calledBy,
    decorated,
    valueGenerator,
    keyGenerator,
    ttl
  ) {
    const args = "arguments" in decorated ? decorated.arguments : [];
    const cacheKey = keyGenerator?.(args);
    const cache = memoizer.forProperty(
      decorated.classConstructor,
      calledBy,
      decorated.propertyKey
    );
    let usingStaleValue = false;
    if (cacheHas(cache, cacheKey)) {
      const cached = cache.get(cacheKey);
      trace(
        `used cached for [${decorated.className}]:${decorated.propertyKey}`
      );
      if (isExpired(cached) && canUseStaleWhileRevalidate(cached)) {
        usingStaleValue = true;
      } else {
        return cached.value;
      }
    }
    trace(`missed cache for [${decorated.className}]:${decorated.propertyKey}`);
    trace(`computing value from args: %o`, args);
    trace(`using property function: %s`, decorated.propertyKey);
    const cached = cache.get(cacheKey);
    // If using stale, only re-run if we aren't already
    // waiting for a re-run to complete.
    if (usingStaleValue && cached?.nextValue) {
      return cached.value;
    }
    const nextValue = valueGenerator.bind(calledBy)(...args);
    if (cached && usingStaleValue && nextValue instanceof Promise) {
      // Then set it to the next value, with a THEN
      // that replaces the value upon resolution.
      cached.nextValue = nextValue;
      nextValue.finally(() => {
        cache.set(cacheKey, toCachedValue(nextValue, ttl));
      });
      return cached.value;
    }
    cache.set(cacheKey, toCachedValue(nextValue, ttl));
    return nextValue;
  }
  function toCachedValue(value, ttl) {
    const expiresAt = ttl?.maxAge
      ? new Date(Date.now() + ttl.maxAge * 1000)
      : undefined;
    const staleWhileRevalidateUntil =
      expiresAt && ttl?.staleWhileRevalidate
        ? new Date(expiresAt.getTime() + ttl.staleWhileRevalidate * 1000)
        : undefined;
    return {
      value,
      expiresAt,
      staleWhileRevalidateUntil,
    };
  }
  function clearMemoized(context, scope) {
    const isInstanceScope = scope === undefined;
    const isClassScope = !isInstanceScope && scope === context.classConstructor;
    if (isInstanceScope) {
      clearMemoizedTarget(context.classConstructor, this);
      trace(`purged instance cache [${context.className}]`);
    } else if (isClassScope) {
      clearMemoizedClass(context.classConstructor);
      trace(`purged class cache [${context.className}]`);
    } else if (typeof scope === "string") {
      // Must be property scope!
      clearMemoizedProperty(context.classConstructor, this, scope);
      trace(`purged property cache [${context.className}]`);
    } else {
      throw new Error(`Invalid purge scope: ${scope}`);
    }
  }
  /**
   * Store for memoized content, set up hierarchically
   * for automatic memory management and easy
   * clearing/adding/removal of memoized content by class
   * or by target.
   *
   * Keyed by decorator parameters (allowed `undefined`):
   *
   * constructor -> target -> propertyKey -> cacheKey -> value
   *
   * Then keyed by the user-provided key generator function results.
   */
  const decoratorStorage = new Map();
  const memoizer = {
    forClass(theClass) {
      return ensureChildMap(decoratorStorage, theClass, WeakMap);
    },
    forTarget(theClass, target) {
      return ensureChildMap(memoizer.forClass(theClass), target, Map);
    },
    forProperty(theClass, target, propertyKey) {
      return ensureChildMap(
        memoizer.forTarget(theClass, target),
        propertyKey,
        Map
      );
    },
  };
  function clearMemoizedValue(theClass, target, propertyKey, cacheKey) {
    memoizer.forProperty(theClass, target, propertyKey).delete(cacheKey);
  }
  function clearMemoizedProperty(theClass, target, propertyKey) {
    memoizer.forProperty(theClass, target, propertyKey).clear();
  }
  /**
   * Clear all stored values for a given target. If the
   * target is an instance, that instance's stores will
   * all be cleared. If that instance is a class, all
   * static stores will be cached.
   *
   * This does *not* clear per-instance caches. For that
   * purpose, use {@link clearMemoizedClass}.
   */
  function clearMemoizedTarget(theClass, target) {
    memoizer.forTarget(theClass, target).clear();
  }
  /**
   * Clear all storage of any sort for a class and all
   * instances of that class.
   */
  function clearMemoizedClass(theClass) {
    decoratorStorage.delete(theClass);
  }
  /**
   * Given a parent Map and a child key that itself should
   * key onto a Map, ensure that such a Map exists and
   * return a reference to it.
   */
  function ensureChildMap(parentMap, childKey, mapConstructor) {
    if (!parentMap.has(childKey)) {
      parentMap.set(childKey, new mapConstructor());
    }
    return parentMap.get(childKey);
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/memoize.js
  //# sourceMappingURL=memoize.lib.js.map
  /**
   * A simple decorator for adding caching to a class method
   * or accessor using the default memoization key
   * (JSON stringification of the arguments).
   */
  const memoize = Memoize();
  const memoizeUnresolved = MaxAge(0, 10);
  function MaxAge(seconds, staleWhileRerunSeconds = seconds / 10) {
    return Memoize({
      ttl: { maxAge: seconds, staleWhileRevalidate: staleWhileRerunSeconds },
    });
  }
  /**
   * A decorator for caching the result of a method call, including
   * getter methods.
   */
  function Memoize(options) {
    return decorator_createDecorator("cache", (context) => {
      if (context.type === "class") {
        // Add the per-instance all-cache clear method
        const name = "clearMemoized";
        context.classConstructor.prototype[name] = function (scope) {
          return clearMemoized.apply(this, [context, scope]);
        };
      } else if (["accessor", "method"].includes(context.type)) {
        const methodName = context.type === "accessor" ? "get" : "value";
        const valueGenerator = context.descriptor?.[methodName];
        if (typeof valueGenerator !== "function") {
          return;
        }
        context.descriptor[methodName] = function (...args) {
          return memoizedValue(
            this,
            { ...context, arguments: args },
            valueGenerator,
            options?.keyGen || JSON.stringify,
            options?.ttl
          );
        };
      }
    });
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/objects.js
  //# sourceMappingURL=memoize.js.map
  function toJson(value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    if ("toJSON" in value && typeof value.toJSON === "function") {
      return value.toJSON();
    }
    value = value?.valueOf() ?? value;
    if (Array.isArray(value)) {
      return value.map(toJson);
    } else {
      return Object.entries(value).reduce((acc, [key, value]) => {
        acc[key] = toJson(value);
        return acc;
      }, {});
    }
  }
  function sortKeysByReference(data, reference) {
    if (!isPlainObjectOrArray(data)) {
      return data;
    }
    if (!isPlainObjectOrArray(reference)) {
      return data;
    }
    // Make sure that they're either both arrays or both
    // plain objects.
    if (!arrayIsDuplicates([Array.isArray(data), Array.isArray(reference)])) {
      // Then we have non-comparable types
      return data;
    }
    // Finally we should be able to attempt to sort
    if (isPlainObject(data)) {
      const unsortedKeys = Object.keys(data);
      const sampleKeys = Object.keys(reference);
      const sortedObject = {};
      // Add all of the entries by example key-order
      for (const key of sampleKeys) {
        if (key in data) {
          // `in` allows for keys that exist but have undefined values
          sortedObject[key] = sortKeysByReference(data[key], reference[key]);
        }
      }
      // Add all leftoever entries in their original (relative) order
      for (const key of unsortedKeys) {
        if (!(key in sortedObject)) {
          sortedObject[key] = sortKeysByReference(data[key], reference[key]);
        }
      }
      data = sortedObject;
    } else if (Array.isArray(data)) {
      let i = 0;
      const sampleArray = reference;
      const sortedObjectArray = [];
      // Use the matching position in the example array
      // until no examples remain, then use the last example
      // for any remaining data entries.
      let lastSeenReferenceObject;
      for (; i < sampleArray.length && i < data.length; i++) {
        lastSeenReferenceObject = isPlainObject(sampleArray[i])
          ? sampleArray[i]
          : lastSeenReferenceObject;
        sortedObjectArray.push(
          sortKeysByReference(data[i], lastSeenReferenceObject)
        );
      }
      for (; i < data.length; i++) {
        sortedObjectArray.push(
          sortKeysByReference(data[i], lastSeenReferenceObject)
        );
      }
      data = sortedObjectArray;
    }
    return data;
  }
  function isPlainObject(something) {
    return (
      something &&
      typeof something == "object" &&
      !Array.isArray(something) &&
      (!something.toString || something.toString?.() == "[object Object]")
    );
  }
  function isPlainObjectOrArray(something) {
    return Array.isArray(something) || isPlainObject(something);
  }
  /**
   * Convert an array into objects that use numeric
   * strings as indices. Non-array items are returned as-is.
   */
  function arrayToObject(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    return array.reduce((asMap, value, index) => {
      asMap[`${index}`] = value;
      return asMap;
    }, {});
  }
  /**
   * Flatten a nested data structure into a one-level-deep
   * map, with keys as paths like "firstLevel.secondLevel.0.3".
   * It's assumed that object keys are not castable as numbers,
   * so that all numeric parts of the path are unambiguously from
   * arrays.
   */
  function flattenObjectPaths(object) {
    if (!isPlainObjectOrArray(object)) {
      return object;
    }
    // Make a shallow clone.
    object = Array.isArray(object) ? [...object] : { ...object };
    const toReturn = {};
    for (const key of Object.keys(object)) {
      assert(!key.includes("."), "Keys must not have periods in them.");
      object[key] = arrayToObject(object[key]);
      // Convert arrays to objects
      if (isPlainObject(object[key])) {
        const flatObject = flattenObjectPaths(object[key]);
        for (const subkey of Object.keys(flatObject)) {
          toReturn[`${key}.${subkey}`] = flatObject[subkey];
        }
      } else {
        toReturn[key] = object[key];
      }
    }
    return toReturn;
  }
  function objectPaths(object) {
    const flattened = flattenObjectPaths(object);
    if (!isPlainObject(flattened)) {
      return [];
    }
    return Object.keys(flattened);
  }
  /** Get the value at a fully defined (no wildcards) path. */
  function getValueAtPath(object, path) {
    const pathParts = path.split(".");
    let subObject = object;
    for (const part of pathParts) {
      subObject = subObject?.[part];
      if (!subObject) {
        return;
      }
    }
    return subObject;
  }
  /**
   * Set the value at a fully defined (no wildcards) path.
   * Any missing data structures will be added.
   */
  function setValueAtPath(object, path, value, options) {
    const pathParts = path.split(options?.sep || ".").filter((s) => s !== "");
    let subObject = object;
    for (let level = 0; level < pathParts.length - 1; level++) {
      const index = pathParts[level].match(/^\d+$/)
        ? Number(pathParts[level])
        : pathParts[level];
      if (typeof subObject[index] == "undefined") {
        subObject[index] = typeof index == "number" ? [] : {};
      }
      subObject = subObject[index];
    }
    const finalKey = pathParts[pathParts.length - 1];
    subObject[finalKey] = options?.noClobber
      ? typeof subObject[finalKey] === "undefined"
        ? value
        : subObject[finalKey]
      : value;
  }
  /**
   * Given an object path that *may* include wildcards
   * (e.g. `a.*.b`), get all paths that match. Assumes
   * that path components do not include regex special
   * characters (except '.' and '*');
   */
  function objectPathsFromWildcardPath(path, object) {
    const allPaths = objectPaths(object);
    const pathAsRegex = new RegExp(
      `^(${path.replace(/\./, "\\.").replace(/\*/g, "[^.]+")})(\\.|$)`
    );
    const matches = allPaths
      .map((path) => path.match(pathAsRegex)?.[1])
      .filter((x) => x);
    return [...new Set(matches)]; // ensure unique
  }
  /**
   * Apply a function to a value inside an object,
   * using a path string for complex data structures.
   * Allows using `*` to mean *all* fields.
   * For example, `a.b.3.*`, for structure
   * `{a:{b:[0,1,{c:'hello',d:'world'}]}}`
   * would capture paths `a.b.3.c` and `a.b.3.d`
   * and apply the transform to both values.
   * If a path does not exist, no action is taken.
   */
  function transformValueByPath(object, path, transformer) {
    if (!isPlainObjectOrArray(object)) {
      return object;
    }
    const paths = objectPathsFromWildcardPath(path, object);
    for (const subpath of paths) {
      const value = getValueAtPath(object, subpath);
      setValueAtPath(object, subpath, transformer(value));
    }
    return object;
  }
  /**
   * Get an object's keys. Simply uses `Object.keys`,
   * but with type support.
   */
  function keysOf(obj) {
    return Object.keys(obj);
  }
  /**
   * Delete any keys whose values are `undefined`. Mutates and returns the provided object.
   */
  function deleteUndefinedValues(obj) {
    for (const key of keysOf(obj)) {
      if (obj[key] === undefined) {
        delete obj[key];
      }
    }
    return obj;
  }
  /**
   * Same as {@link deleteUndefinedValues},
   * but acting on a copy of the provided
   * object instead of mutating in place.
   */
  function omitUndefinedValues(obj) {
    return deleteUndefinedValues({ ...obj });
  }
  /**
   * Merge two objects. Values in
   * the second object will overwrite values
   * in the first, *except for `undefined`*
   * (note that built-in `Object.assign` does
   * clobber with `undefined` values).
   *
   * Arrays clobber by default, but can
   * optionally be set to merge.
   *
   * Returns a new object. Does not mutate
   * the provided objects.
   */
  function merge(o1, o2, options) {
    const merged = { ...o1 };
    for (const key of keysOf(o2)) {
      if (o2[key] === undefined) {
        continue;
      }
      // Otherwise manage clobbering/combining
      // based on options.
      if (Array.isArray(merged[key]) && Array.isArray(o2[key])) {
        // If concatting, combine them together
        if (options?.concatArrays) {
          merged[key] = [...merged[key], ...o2[key]];
          if (options?.unique) {
            const alreadySeen = new Set();
            for (let i = merged[key].length; i > -1; i--) {
              if (typeof options.unique === "string") {
                const value = merged[key][i][options.unique];
                if (value !== undefined && alreadySeen.has(value)) {
                  merged[key].splice(i, 1);
                }
                alreadySeen.add(value);
              } else if (alreadySeen.has(merged[key][i])) {
                merged[key].splice(i, 1);
              } else {
                alreadySeen.add(merged[key][i]);
              }
            }
          }
        }
        // Otherwise, clobber
        else {
          merged[key] = o2[key];
        }
        continue;
      } else if (
        typeof o2[key] === "object" &&
        typeof merged[key] === "object"
      ) {
        merged[key] = merge(merged[key], o2[key], options);
        continue;
      }
      // Fallback to clobbering
      merged[key] = o2[key];
    }
    return merged;
  }
  /**
   * Return a new object whose keys and values
   * are swapped.
   */
  function invert(obj) {
    const keys = keysOf(obj);
    const inverted = {};
    for (const key of keys) {
      const value = obj[key];
      if (["string", "number", "symbol"].includes(typeof value)) {
        inverted[obj[key]] = key;
      }
    }
    return inverted;
  }
  /**
   * Return a new object with a subset of fields.
   */
  function pick(obj, select) {
    const result = {};
    for (const key of select) {
      if (key in obj) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  /**
   * Return a new object with a blocklisted
   * set of fields.
   */
  function omit(obj, select) {
    const result = {};
    for (const prop of keysOf(obj)) {
      if (!select.includes(prop)) {
        result[prop] = obj[prop];
      }
    }
    return result;
  }
  /**
   * Return a list of all non-#private methods
   * on an object, following the prototype chain.
   */
  function listPublicAsyncMethods(obj) {
    const methods = [];
    for (
      let proto = obj;
      proto !== Object.prototype;
      proto = Object.getPrototypeOf(proto)
    ) {
      const descriptors = Object.getOwnPropertyDescriptors(proto);
      for (const key of Object.keys(descriptors)) {
        const isValidAsyncFunction =
          descriptors[key]?.value instanceof Function &&
          descriptors[key].value.constructor.name === "AsyncFunction" &&
          key !== "constructor";
        if (!isValidAsyncFunction) {
          continue;
        }
        methods.push(key);
      }
    }
    return methods;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/sequentializer.js
  //# sourceMappingURL=objects.js.map
  const sequence = Symbol("sequence");
  function isSequentialized(fn) {
    return typeof fn === "function" && sequence in fn;
  }
  function sequentialize(fn, options) {
    const name = `sequentialized(${fn.name || "anonymous"})`;
    const subqueues = options?.shareQueueWith?.[sequence] || {};
    const sequentialized = {
      // eslint-disable-next-line require-await
      [name]: async function (...args) {
        const call = () => fn.apply(this, args);
        // Get the subqueue key
        const subqueueKey = `${options?.subqueueBy?.(...args) ?? ""}`;
        // Only run the sequentialized function after the previous one has completed
        const lastResult = subqueues[subqueueKey];
        subqueues[subqueueKey] = lastResult?.finally().then(call) ?? call();
        const thisResult = subqueues[subqueueKey];
        // When this invocation completes, if it's also the latest one in the queue,
        // then we can replace it with an empty promise to avoid memory leaks
        thisResult.finally(() => {
          if (thisResult === subqueues[subqueueKey]) {
            Reflect.deleteProperty(subqueues, subqueueKey);
          }
        });
        return thisResult;
      },
    }[name];
    sequentialized[sequence] = subqueues;
    // Overwrite `.bind()`, since otherwise the function it returns
    // will have lost the `[sequence]` field.
    sequentialized.bind = (thisArg) => {
      return sequentialize(fn.bind(thisArg), options);
    };
    return sequentialized;
  }
  /**
   * Decorator to make a function sequentialized, so that
   * each call will only run after the previous one has completed.
   */
  const sequential = Sequential();
  /**
   * Generate a decorator that will sequentialize the decorated async method.
   *
   * @param shareQueueWith - Optionally use a shared queue with another sequentialized function.
   * If a string is provided, it must be the name of a method on the class that is sequentialized
   * before this one (defined earlier).
   */
  function Sequential(options) {
    return decorator_createDecorator("sequentializer", (context) => {
      types_assert(
        context.type === "method",
        "The @Sequential decorator can only be used on methods"
      );
      types_assert(
        context.isAsync,
        "The @Sequential decorator can only be used on async methods"
      );
      let queueSource = isSequentialized(options?.shareQueueWith)
        ? options?.shareQueueWith
        : undefined;
      if (typeof options?.shareQueueWith === "string") {
        types_assert(
          options?.shareQueueWith in context.target,
          `Method ${context.propertyKey} cannot share a queue with ${options?.shareQueueWith}; the latter was not found on the target.`
        );
        queueSource = context.target[options?.shareQueueWith];
      }
      types_assert(
        !queueSource || isSequentialized(queueSource),
        `Method ${context.propertyKey} cannot share a queue with ${options?.shareQueueWith}; the latter exists but is not sequentialized.`
      );
      types_assert(
        context.descriptor && "value" in context.descriptor,
        `Method ${context.propertyKey} cannot be sequentialized; it does not have a value descriptor.`
      );
      types_assert(
        typeof context.descriptor.value === "function",
        `Method ${context.propertyKey} cannot be sequentialized; its value is not a function.`
      );
      context.descriptor.value = sequentialize(context.descriptor.value, {
        ...options,
        shareQueueWith: queueSource,
      });
    });
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/lib/strings.js
  //# sourceMappingURL=sequentializer.js.map
  function withoutInitialLinebreaks(string) {
    return string.replace(/^[\r\n]+/, "");
  }
  function withoutTrailingWhitespace(string) {
    return string.replace(/\s+$/, "");
  }
  function cleanTemplate(strings, ...interps) {
    // Trim these things up
    const cleanStrings = [...strings];
    cleanStrings[0] = withoutInitialLinebreaks(cleanStrings[0]);
    const lastStringIdx = cleanStrings.length - 1;
    cleanStrings[lastStringIdx] = withoutTrailingWhitespace(
      cleanStrings[lastStringIdx]
    );
    // For each interp, if it has newlines when stringified each
    // line after the first needs to inherit the indentation
    // level of its starting point.
    let string = "";
    for (let i = 0; i < cleanStrings.length; i++) {
      string += cleanStrings[i];
      if (i == lastStringIdx) {
        break;
      }
      let interp = `${interps[i]}`;
      const linebreakRegex = /(\r?\n)/;
      const interpLines = interp.split(linebreakRegex).filter((x) => x);
      if (interpLines.length && i < lastStringIdx) {
        // How indented are we?
        const indentMatch = string.match(/\n?([^\n]+?)$/);
        if (indentMatch) {
          // amount of indent to add to each entry that is a break
          // (skip the last one, since if it's a newline we don't
          //  want that to cause an indent on the next line also)
          for (let i = 0; i < interpLines.length; i++) {
            if (interpLines[i].match(linebreakRegex)) {
              interpLines[i] += " ".repeat(indentMatch[1].length);
            }
          }
        }
      }
      interp = interpLines.join("");
      string += interp;
    }
    return string;
  }
  function sortStringsByLength(strings) {
    return strings.sort((string1, string2) => string1.length - string2.length);
  }
  function getShortestString(strings) {
    return sortStringsByLength(strings)[0];
  }
  /**
   * Shift all lines left by the *smallest* indentation level,
   * and remove initial newline and all trailing spaces.
   * Lines that only have spaces are not used to determine the
   * indentation level.
   *
   * @example
   * undent`
   *  All lines will
   * be un-inindented
   *    based on the line
   *  with the smallest indentation.
   * `;
   * // =>
   * //`  All lines will
   * //be un-inindented
   * //    based on the line
   * //  with the smallest indentation.`
   *
   */
  function undent(strings, ...interps) {
    const string = cleanTemplate(strings, ...interps);
    // Remove initial and final newlines
    // Find all indentations *on lines that are not just whitespace!*
    const indentRegex = /^(?<indent>[ \t]*)(?<nonSpace>[^\s])?/;
    const dents = string
      .match(new RegExp(indentRegex, "gm"))
      ?.map((dentedLine) => {
        const { indent, nonSpace } = dentedLine.match(indentRegex).groups;
        const isNotJustWhitespace = nonSpace?.length;
        if (isNotJustWhitespace) {
          return indent || "";
        }
        return;
      })
      .filter((indentLevel) => typeof indentLevel == "string");
    if (!dents || dents.length == 0) {
      return string;
    }
    const minDent = getShortestString(dents);
    if (!minDent) {
      // Then min indentation is 0, no change needed
      return string;
    }
    const dedented = string.replace(new RegExp(`^${minDent}`, "gm"), "");
    return dedented;
  }
  /**
   * Remove ALL indents, from every line.
   *
   * @example
   * nodent`
   *  All lines will
   * be un-indented
   *    completely
   *  but still on separate lines.
   * `;
   * // =>
   * //`All lines will
   * //be un-indented
   * //completely
   * //but still on separate lines.`
   *
   */
  function nodent(strings, ...interps) {
    let string = cleanTemplate(strings, ...interps);
    // Remove initial and final newlines
    string = string.replace(/^[\r\n]+/, "").replace(/\s+$/, "");
    return string
      .split(/\r?\n/g)
      .map((line) => line.replace(/^\s*(.*?)/, "$1"))
      .join("\n");
  }
  /**
   * Remove linebreaks and extra spacing in a template string.
   *
   * @example
   * oneline`
   *  This string
   *      will be converted
   *  into
   *            one that is
   *  on a single line.
   * `;
   * // => "This string will be converted into one that is on a single line."
   */
  function oneline(strings, ...interps) {
    return cleanTemplate(strings, ...interps)
      .replace(/^\s+/, "")
      .replace(/\s+$/, "")
      .replace(/\s+/g, " ");
  }
  function encodeToBase64(content) {
    return (Buffer.isBuffer(content) ? content : Buffer.from(content)).toString(
      "base64"
    );
  }
  function decodeFromBase64(base64) {
    return Buffer.from(base64, "base64").toString();
  }
  function decodeFromBase64JsonString(string) {
    try {
      return JSON.parse(decodeFromBase64(string));
    } catch {
      throw new BscotchUtilError("Object is not JSON parseable");
    }
  }
  function encodeToBase64JsonString(something) {
    try {
      return encodeToBase64(JSON.stringify(something));
    } catch {
      throw new BscotchUtilError("Object is not JSON stringifiable");
    }
  }
  function capitalize(string) {
    return `${string}`.charAt(0).toLocaleUpperCase() + `${string}`.slice(1);
  }
  /**
   * Explode a string using a separator.
   */
  function explode(string, options) {
    options ||= {};
    options.sep = typeof options.sep == "undefined" ? /\s*,\s*/ : options.sep;
    if (!string || typeof string != "string" || options.limit === 0) {
      return [];
    }
    let entries = string[options?.noTrim ? "toString" : "trim"]()
      .split(options.sep)
      .map((entry) => (options?.noTrim ? entry : entry.trim()))
      .filter((entry) => entry || options?.keepEmpty);
    entries = entries.slice(0, options.limit || entries.length);
    return options.unique ? [...new Set(entries)] : entries;
  }
  /**
   * Check a string for a match against one or
   * more patterns. String patterns are tested
   * for an **exact** match, while RegExp patterns
   * are tested with `.test()`.
   *
   * Returns `true` if *any* patterns match.
   */
  function stringIsMatch(str, pattern) {
    return arrayWrapped(pattern).some((pattern) => {
      if (pattern instanceof RegExp) {
        return pattern.test(str);
      }
      return str === pattern;
    });
  }
  function matchAll(string, pattern) {
    let flags = pattern.flags;
    for (const requiredFlags of "gd") {
      if (!flags.includes(requiredFlags)) {
        flags += requiredFlags;
      }
    }
    const matches = string.matchAll(new RegExp(pattern.source, flags));
    return matches;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/utility/dist/browser.js
  // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/urls.js
  //# sourceMappingURL=strings.js.map
  /** @module browser Browser-compatible utilities */

  //# sourceMappingURL=browser.js.map
  function urls_ideFeedUrls() {
    const prefix = `https://gms.yoyogames.com/update-win`;
    return literal({
      lts: `${prefix}-LTS.rss`,
      stable: `${prefix}.rss`,
      beta: `${prefix}-NuBeta.rss`,
      unstable: `${prefix}-NuBeta-I.rss`,
    });
  }
  function urls_runtimeFeedUrls() {
    const prefix = `https://gms.yoyogames.com/Zeus-Runtime`;
    return literal({
      lts: `${prefix}-LTS.rss`,
      stable: `${prefix}.rss`,
      beta: `${prefix}-NuBeta.rss`,
      unstable: `${prefix}-NuBeta-I.rss`,
    });
  } // CONCATENATED MODULE: ./node_modules/zod/lib/index.mjs
  //# sourceMappingURL=urls.js.map
  var util;
  (function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util.getValidEnumValues = (obj) => {
      const validKeys = util
        .objectKeys(obj)
        .filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
      return util.objectKeys(obj).map(function (e) {
        return obj[e];
      });
    };
    util.objectKeys =
      typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
              if (Object.prototype.hasOwnProperty.call(object, key)) {
                keys.push(key);
              }
            }
            return keys;
          };
    util.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item)) return item;
      }
      return undefined;
    };
    util.isInteger =
      typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) =>
            typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array
        .map((val) => (typeof val === "string" ? `'${val}'` : val))
        .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second, // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (
          data.then &&
          typeof data.then === "function" &&
          data.catch &&
          typeof data.catch === "function"
        ) {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };

  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        // eslint-disable-next-line ban/ban
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper =
        _mapper ||
        function (issue) {
          return issue.message;
        };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
                // if (typeof el === "string") {
                //   curr[el] = curr[el] || { _errors: [] };
                // } else if (typeof el === "number") {
                //   const errorArray: any = [];
                //   errorArray._errors = [];
                //   curr[el] = curr[el] || errorArray;
                // }
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };

  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${
            issue.exact
              ? `exactly equal to `
              : issue.inclusive
                ? `greater than or equal to `
                : `greater than `
          }${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${
            issue.exact
              ? `exactly equal to `
              : issue.inclusive
                ? `greater than or equal to `
                : `greater than `
          }${new Date(Number(issue.minimum))}`;
        else message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${
            issue.exact
              ? `exactly`
              : issue.inclusive
                ? `less than or equal to`
                : `less than`
          } ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${
            issue.exact
              ? `exactly`
              : issue.inclusive
                ? `less than or equal to`
                : `less than`
          } ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${
            issue.exact
              ? `exactly`
              : issue.inclusive
                ? `smaller than or equal to`
                : `smaller than`
          } ${new Date(Number(issue.maximum))}`;
        else message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };

  let overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }

  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
      ...issueData,
      path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
      .filter((m) => !!m)
      .slice()
      .reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, {
        data,
        defaultError: errorMessage,
      }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage,
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData: issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap, // then global default map
      ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid") this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted") return INVALID;
        if (s.status === "dirty") status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value,
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted") return INVALID;
        if (value.status === "aborted") return INVALID;
        if (key.status === "dirty") status.dirty();
        if (value.status === "dirty") status.dirty();
        if (
          key.value !== "__proto__" &&
          (typeof value.value !== "undefined" || pair.alwaysSet)
        ) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted",
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

  var errorUtil;
  (function (errorUtil) {
    errorUtil.errToObj = (message) =>
      typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) =>
      typeof message === "string"
        ? message
        : message === null || message === void 0
          ? void 0
          : message.message;
  })(errorUtil || (errorUtil = {}));

  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error) return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        },
      };
    }
  };
  function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } =
      params;
    if (errorMap && (invalid_type_error || required_error)) {
      throw new Error(
        `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
      );
    }
    if (errorMap) return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type") return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return {
          message:
            required_error !== null && required_error !== void 0
              ? required_error
              : ctx.defaultError,
        };
      }
      return {
        message:
          invalid_type_error !== null && invalid_type_error !== void 0
            ? invalid_type_error
            : ctx.defaultError,
      };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    constructor(def) {
      /** Alias of safeParseAsync */
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return (
        ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent,
        }
      );
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent,
        },
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success) return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async:
            (_a =
              params === null || params === void 0 ? void 0 : params.async) !==
              null && _a !== void 0
              ? _a
              : false,
          contextualErrorMap:
            params === null || params === void 0 ? void 0 : params.errorMap,
        },
        path:
          (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data),
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success) return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap:
            params === null || params === void 0 ? void 0 : params.errorMap,
          async: true,
        },
        path:
          (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data),
      };
      const maybeAsyncResult = this._parse({
        data,
        path: ctx.path,
        parent: ctx,
      });
      const result = await (isAsync(maybeAsyncResult)
        ? maybeAsyncResult
        : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () =>
          ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val),
          });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(
            typeof refinementData === "function"
              ? refinementData(val, ctx)
              : refinementData
          );
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement },
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform },
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def),
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description,
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(undefined).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[a-z][a-z0-9]*$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  // const uuidRegex =
  //   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
  const uuidRegex =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  // from https://stackoverflow.com/a/46181/1550155
  // old version: too slow, didn't support unicode
  // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
  //old email regex
  // const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
  // eslint-disable-next-line
  // const emailRegex =
  //   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
  // const emailRegex =
  //   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  // const emailRegex =
  //   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
  const emailRegex =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  // const emailRegex =
  //   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
  // from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex =
    /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  const ipv6Regex =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  // Adapted from https://stackoverflow.com/a/3143231
  const datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(
          `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
        );
      } else {
        return new RegExp(
          `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`
        );
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(
          `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
        );
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(
          `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`
        );
      } else {
        return new RegExp(
          `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`
        );
      }
    }
  };
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx.parsedType,
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message,
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message,
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message,
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message),
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check],
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options,
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision:
          typeof (options === null || options === void 0
            ? void 0
            : options.precision) === "undefined"
            ? null
            : options === null || options === void 0
              ? void 0
              : options.precision,
        offset:
          (_a =
            options === null || options === void 0
              ? void 0
              : options.offset) !== null && _a !== void 0
            ? _a
            : false,
        ...errorUtil.errToObj(
          options === null || options === void 0 ? void 0 : options.message
        ),
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex,
        ...errorUtil.errToObj(message),
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value: value,
        position:
          options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(
          options === null || options === void 0 ? void 0 : options.message
        ),
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value: value,
        ...errorUtil.errToObj(message),
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value: value,
        ...errorUtil.errToObj(message),
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message),
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message),
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message),
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }],
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }],
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }],
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min) min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max) max = ch.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce:
        (_a = params === null || params === void 0 ? void 0 : params.coerce) !==
          null && _a !== void 0
          ? _a
          : false,
      ...processCreateParams(params),
    });
  };
  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive
            ? input.data < check.value
            : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive
            ? input.data > check.value
            : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message,
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message),
          },
        ],
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check],
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message),
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message),
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message),
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message),
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message),
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value: value,
        message: errorUtil.toString(message),
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message),
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message),
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message),
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min) min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max) max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find(
        (ch) =>
          ch.kind === "int" ||
          (ch.kind === "multipleOf" && util.isInteger(ch.value))
      );
    }
    get isFinite() {
      let max = null,
        min = null;
      for (const ch of this._def.checks) {
        if (
          ch.kind === "finite" ||
          ch.kind === "int" ||
          ch.kind === "multipleOf"
        ) {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min) min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max) max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce:
        (params === null || params === void 0 ? void 0 : params.coerce) ||
        false,
      ...processCreateParams(params),
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive
            ? input.data < check.value
            : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive
            ? input.data > check.value
            : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message,
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message,
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message),
          },
        ],
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check],
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message),
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message),
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message),
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message),
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message),
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min) min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max) max = ch.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce:
        (_a = params === null || params === void 0 ? void 0 : params.coerce) !==
          null && _a !== void 0
          ? _a
          : false,
      ...processCreateParams(params),
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce:
        (params === null || params === void 0 ? void 0 : params.coerce) ||
        false,
      ...processCreateParams(params),
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_date,
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date",
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date",
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime()),
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check],
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message),
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message),
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min) min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max) max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce:
        (params === null || params === void 0 ? void 0 : params.coerce) ||
        false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params),
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params),
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params),
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params),
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params),
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      // required
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params),
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType,
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params),
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params),
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message,
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message,
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message,
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all(
          [...ctx.data].map((item, i) => {
            return def.type._parseAsync(
              new ParseInputLazyPath(ctx, item, ctx.path, i)
            );
          })
        ).then((result) => {
          return ParseStatus.mergeArray(status, result);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(
          new ParseInputLazyPath(ctx, item, ctx.path, i)
        );
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) },
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) },
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) },
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params),
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape,
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element),
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      /**
       * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
       * If you want to pass through unknown properties, use `.passthrough()` instead.
       */
      this.nonstrict = this.passthrough;
      // extend<
      //   Augmentation extends ZodRawShape,
      //   NewOutput extends util.flatten<{
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   }>,
      //   NewInput extends util.flatten<{
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }>
      // >(
      //   augmentation: Augmentation
      // ): ZodObject<
      //   extendShape<T, Augmentation>,
      //   UnknownKeys,
      //   Catchall,
      //   NewOutput,
      //   NewInput
      // > {
      //   return new ZodObject({
      //     ...this._def,
      //     shape: () => ({
      //       ...this._def.shape(),
      //       ...augmentation,
      //     }),
      //   }) as any;
      // }
      /**
       * @deprecated Use `.extend` instead
       *  */
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return (this._cached = { shape, keys });
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (
        !(
          this._def.catchall instanceof ZodNever &&
          this._def.unknownKeys === "strip"
        )
      ) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
          ),
          alwaysSet: key in ctx.data,
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] },
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys,
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip");
        else {
          throw new Error(
            `Internal ZodObject error: invalid unknownKeys value.`
          );
        }
      } else {
        // run catchall validation
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data,
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve()
          .then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet,
              });
            }
            return syncPairs;
          })
          .then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...(message !== undefined
          ? {
              errorMap: (issue, ctx) => {
                var _a, _b, _c, _d;
                const defaultError =
                  (_c =
                    (_b = (_a = this._def).errorMap) === null || _b === void 0
                      ? void 0
                      : _b.call(_a, issue, ctx).message) !== null &&
                  _c !== void 0
                    ? _c
                    : ctx.defaultError;
                if (issue.code === "unrecognized_keys")
                  return {
                    message:
                      (_d = errorUtil.errToObj(message).message) !== null &&
                      _d !== void 0
                        ? _d
                        : defaultError,
                  };
                return {
                  message: defaultError,
                };
              },
            }
          : {}),
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip",
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough",
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation,
        }),
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape(),
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject,
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index,
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape,
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape,
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape,
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape,
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        // return first issue-free validation if it exists
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            // add issues from dirty option
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        // return invalid
        const unionErrors = results.map(
          (result) => new ZodError(result.ctx.common.issues)
        );
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors,
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(
          options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: [],
              },
              parent: null,
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx,
              }),
              ctx: childCtx,
            };
          })
        ).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: [],
            },
            parent: null,
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx,
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues) => new ZodError(issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors,
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params),
    });
  };
  /////////////////////////////////////////////////////
  /////////////////////////////////////////////////////
  //////////                                 //////////
  //////////      ZodDiscriminatedUnion      //////////
  //////////                                 //////////
  /////////////////////////////////////////////////////
  /////////////////////////////////////////////////////
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      // eslint-disable-next-line ban/ban
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [undefined];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator],
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      // Get all the valid discriminator values
      const optionsMap = new Map();
      // try {
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(
            `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`
          );
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(
              `Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`
            );
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params),
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (
      aType === ZodParsedType.object &&
      bType === ZodParsedType.object
    ) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util
        .objectKeys(a)
        .filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (
      aType === ZodParsedType.date &&
      bType === ZodParsedType.date &&
      +a === +b
    ) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types,
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          }),
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(
          this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          }),
          this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          })
        );
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left: left,
      right: right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params),
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array",
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array",
        });
        status.dirty();
      }
      const items = [...ctx.data]
        .map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema) return null;
          return schema._parse(
            new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)
          );
        })
        .filter((x) => !!x); // filter nulls
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest,
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params),
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(
            new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)
          ),
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third),
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second),
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(
            new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])
          ),
          value: valueType._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])
          ),
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params),
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message,
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message,
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements) {
        const parsedSet = new Set();
        for (const element of elements) {
          if (element.status === "aborted") return INVALID;
          if (element.status === "dirty") status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) =>
        valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
      );
      if (ctx.common.async) {
        return Promise.all(elements).then((elements) => finalizeSet(elements));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) },
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) },
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params),
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap,
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error,
          },
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap,
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error,
          },
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        // Would love a way to avoid disabling this rule, but we need
        // an alias (using an arrow function was what caused 2651).
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const me = this;
        return OK(async function (...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args
            .parseAsync(args, params)
            .catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type
            .parseAsync(result, params)
            .catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
          return parsedReturns;
        });
      } else {
        // Would love a way to avoid disabling this rule, but we need
        // an alias (using an arrow function was what caused 2651).
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const me = this;
        return OK(function (...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create()),
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType,
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params),
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter: getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params),
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value,
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value: value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params),
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params),
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type,
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues,
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return ZodEnum.create(values);
    }
    exclude(values) {
      return ZodEnum.create(
        this.options.filter((opt) => !values.includes(opt))
      );
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (
        ctx.parsedType !== ZodParsedType.string &&
        ctx.parsedType !== ZodParsedType.number
      ) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type,
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues,
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values: values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params),
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (
        ctx.parsedType !== ZodParsedType.promise &&
        ctx.common.async === false
      ) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      const promisified =
        ctx.parsedType === ZodParsedType.promise
          ? ctx.data
          : Promise.resolve(ctx.data);
      return OK(
        promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap,
          });
        })
      );
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params),
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
        ? this._def.schema.sourceType()
        : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        },
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data,
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed) => {
            return this._def.schema._parseAsync({
              data: processed,
              path: ctx.path,
              parent: ctx,
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx,
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (
          acc
          // effect: RefinementEffect<any>
        ) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error(
              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
            );
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          });
          if (inner.status === "aborted") return INVALID;
          if (inner.status === "dirty") status.dirty();
          // return value is ignored
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema
            ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
            .then((inner) => {
              if (inner.status === "aborted") return INVALID;
              if (inner.status === "dirty") status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          });
          if (!isValid(base)) return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(
              `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
            );
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema
            ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
            .then((base) => {
              if (!isValid(base)) return base;
              return Promise.resolve(
                effect.transform(base.value, checkCtx)
              ).then((result) => ({ status: status.value, value: result }));
            });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params),
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params),
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params),
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params),
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx,
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue:
        typeof params.default === "function"
          ? params.default
          : () => params.default,
      ...processCreateParams(params),
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      // newCtx is used to not collect issues from inner types in ctx
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: [],
        },
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx,
        },
      });
      if (isAsync(result)) {
        return result.then((result) => {
          return {
            status: "valid",
            value:
              result.status === "valid"
                ? result.value
                : this._def.catchValue({
                    get error() {
                      return new ZodError(newCtx.common.issues);
                    },
                    input: newCtx.data,
                  }),
          };
        });
      } else {
        return {
          status: "valid",
          value:
            result.status === "valid"
              ? result.value
              : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data,
                }),
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue:
        typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params),
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType,
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params),
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx,
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx,
          });
          if (inResult.status === "aborted") return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx,
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inResult.status === "aborted") return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value,
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx,
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline,
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      if (isValid(result)) {
        result.value = Object.freeze(result.value);
      }
      return result;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params),
    });
  };
  const custom = (
    check,
    params = {},
    /**
     * @deprecated
     *
     * Pass `fatal` into the params object instead:
     *
     * ```ts
     * z.string().custom((val) => val.length > 5, { fatal: false })
     * ```
     *
     */
    fatal
  ) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p =
            typeof params === "function"
              ? params(data)
              : typeof params === "string"
                ? { message: params }
                : params;
          const _fatal =
            (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !==
              null && _b !== void 0
              ? _b
              : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  const late = {
    object: ZodObject.lazycreate,
  };
  var ZodFirstPartyTypeKind;
  (function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (
    // const instanceOfType = <T extends new (...args: any[]) => any>(
    cls,
    params = {
      message: `Input not instance of ${cls.name}`,
    }
  ) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) =>
      ZodBoolean.create({
        ...arg,
        coerce: true,
      }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true }),
  };
  const NEVER = INVALID;

  var lib_z = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    void: voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError,
  }); // CONCATENATED MODULE: ./node_modules/entities/lib/esm/generated/decode-data-html.js

  // Generated using scripts/write-decode-map.ts
  /* harmony default export */ const decode_data_html = new Uint16Array(
    // prettier-ignore
    "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
    .split("")
    .map((c) => c.charCodeAt(0))
  ); // CONCATENATED MODULE: ./node_modules/entities/lib/esm/generated/decode-data-xml.js
  //# sourceMappingURL=decode-data-html.js.map
  // Generated using scripts/write-decode-map.ts
  /* harmony default export */ const decode_data_xml = new Uint16Array(
    // prettier-ignore
    "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
    .split("")
    .map((c) => c.charCodeAt(0))
  ); // CONCATENATED MODULE: ./node_modules/entities/lib/esm/decode_codepoint.js
  //# sourceMappingURL=decode-data-xml.js.map
  // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
  var _a;
  const decodeMap = new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
  ]);
  /**
   * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
   */
  const fromCodePoint =
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0
      ? _a
      : function (codePoint) {
          let output = "";
          if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(
              ((codePoint >>> 10) & 0x3ff) | 0xd800
            );
            codePoint = 0xdc00 | (codePoint & 0x3ff);
          }
          output += String.fromCharCode(codePoint);
          return output;
        };
  /**
   * Replace the given code point with a replacement character if it is a
   * surrogate or is outside the valid range. Otherwise return the code
   * point unchanged.
   */
  function replaceCodePoint(codePoint) {
    var _a;
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
      return 0xfffd;
    }
    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0
      ? _a
      : codePoint;
  }
  /**
   * Replace the code point if relevant, then convert it to a string.
   *
   * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
   * @param codePoint The code point to decode.
   * @returns The decoded code point.
   */
  function decodeCodePoint(codePoint) {
    return fromCodePoint(replaceCodePoint(codePoint));
  } // CONCATENATED MODULE: ./node_modules/entities/lib/esm/decode.js
  //# sourceMappingURL=decode_codepoint.js.map
  // Re-export for use by eg. htmlparser2

  var CharCodes;
  (function (CharCodes) {
    CharCodes[(CharCodes["NUM"] = 35)] = "NUM";
    CharCodes[(CharCodes["SEMI"] = 59)] = "SEMI";
    CharCodes[(CharCodes["EQUALS"] = 61)] = "EQUALS";
    CharCodes[(CharCodes["ZERO"] = 48)] = "ZERO";
    CharCodes[(CharCodes["NINE"] = 57)] = "NINE";
    CharCodes[(CharCodes["LOWER_A"] = 97)] = "LOWER_A";
    CharCodes[(CharCodes["LOWER_F"] = 102)] = "LOWER_F";
    CharCodes[(CharCodes["LOWER_X"] = 120)] = "LOWER_X";
    CharCodes[(CharCodes["LOWER_Z"] = 122)] = "LOWER_Z";
    CharCodes[(CharCodes["UPPER_A"] = 65)] = "UPPER_A";
    CharCodes[(CharCodes["UPPER_F"] = 70)] = "UPPER_F";
    CharCodes[(CharCodes["UPPER_Z"] = 90)] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  /** Bit that needs to be set to convert an upper case ASCII character to lower case */
  const TO_LOWER_BIT = 0b100000;
  var BinTrieFlags;
  (function (BinTrieFlags) {
    BinTrieFlags[(BinTrieFlags["VALUE_LENGTH"] = 49152)] = "VALUE_LENGTH";
    BinTrieFlags[(BinTrieFlags["BRANCH_LENGTH"] = 16256)] = "BRANCH_LENGTH";
    BinTrieFlags[(BinTrieFlags["JUMP_TABLE"] = 127)] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function decode_isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code) {
    return (
      (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
      (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)
    );
  }
  function isAsciiAlphaNumeric(code) {
    return (
      (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
      (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
      decode_isNumber(code)
    );
  }
  /**
   * Checks if the given character is a valid end character for an entity in an attribute.
   *
   * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
   * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
   */
  function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  }
  var EntityDecoderState;
  (function (EntityDecoderState) {
    EntityDecoderState[(EntityDecoderState["EntityStart"] = 0)] = "EntityStart";
    EntityDecoderState[(EntityDecoderState["NumericStart"] = 1)] =
      "NumericStart";
    EntityDecoderState[(EntityDecoderState["NumericDecimal"] = 2)] =
      "NumericDecimal";
    EntityDecoderState[(EntityDecoderState["NumericHex"] = 3)] = "NumericHex";
    EntityDecoderState[(EntityDecoderState["NamedEntity"] = 4)] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var decode_DecodingMode;
  (function (DecodingMode) {
    /** Entities in text nodes that can end with any character. */
    DecodingMode[(DecodingMode["Legacy"] = 0)] = "Legacy";
    /** Only allow entities terminated with a semicolon. */
    DecodingMode[(DecodingMode["Strict"] = 1)] = "Strict";
    /** Entities in attributes have limitations on ending characters. */
    DecodingMode[(DecodingMode["Attribute"] = 2)] = "Attribute";
  })(decode_DecodingMode || (decode_DecodingMode = {}));
  /**
   * Token decoder with support of writing partial entities.
   */
  class EntityDecoder {
    constructor(
      /** The tree used to decode entities. */
      decodeTree,
      /**
       * The function that is called when a codepoint is decoded.
       *
       * For multi-byte named entities, this will be called multiple times,
       * with the second codepoint, and the same `consumed` value.
       *
       * @param codepoint The decoded codepoint.
       * @param consumed The number of bytes consumed by the decoder.
       */
      emitCodePoint,
      /** An object that is used to produce errors. */
      errors
    ) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors;
      /** The current state of the decoder. */
      this.state = EntityDecoderState.EntityStart;
      /** Characters that were consumed while parsing an entity. */
      this.consumed = 1;
      /**
       * The result of the entity.
       *
       * Either the result index of a numeric entity, or the codepoint of a
       * numeric entity.
       */
      this.result = 0;
      /** The current index in the decode tree. */
      this.treeIndex = 0;
      /** The number of characters that were consumed in excess. */
      this.excess = 1;
      /** The mode in which the decoder is operating. */
      this.decodeMode = decode_DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start, end, base) {
      if (start !== end) {
        const digitCount = end - start;
        this.result =
          this.result * Math.pow(base, digitCount) +
          parseInt(str.substr(start, digitCount), base);
        this.consumed += digitCount;
      }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (decode_isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (decode_isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
      var _a;
      // Ensure we consumed at least one digit.
      if (this.consumed <= expectedLength) {
        (_a = this.errors) === null || _a === void 0
          ? void 0
          : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      // Figure out if this is a legit end of the entity
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === decode_DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
      const { decodeTree } = this;
      let current = decodeTree[this.treeIndex];
      // The mask is the number of bytes of the value, including the current byte.
      let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (; offset < str.length; offset++, this.excess++) {
        const char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(
          decodeTree,
          current,
          this.treeIndex + Math.max(1, valueLength),
          char
        );
        if (this.treeIndex < 0) {
          return this.result === 0 ||
            // If we are parsing an attribute
            (this.decodeMode === decode_DecodingMode.Attribute &&
              // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 ||
                // And there should be no invalid characters.
                isEntityInAttributeInvalidEnd(char)))
            ? 0
            : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        // If the branch is a value, store it and continue
        if (valueLength !== 0) {
          // If the entity is terminated by a semicolon, we are done.
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(
              this.treeIndex,
              valueLength,
              this.consumed + this.excess
            );
          }
          // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
          if (this.decodeMode !== decode_DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
      var _a;
      const { result, decodeTree } = this;
      const valueLength =
        (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a = this.errors) === null || _a === void 0
        ? void 0
        : _a.missingSemicolonAfterCharacterReference();
      return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
      const { decodeTree } = this;
      this.emitCodePoint(
        valueLength === 1
          ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
          : decodeTree[result + 1],
        consumed
      );
      if (valueLength === 3) {
        // For multi-byte values, we need to emit the second byte.
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
      var _a;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          // Emit a named entity if we have one.
          return this.result !== 0 &&
            (this.decodeMode !== decode_DecodingMode.Attribute ||
              this.result === this.treeIndex)
            ? this.emitNotTerminatedNamedEntity()
            : 0;
        }
        // Otherwise, emit a numeric entity if we have one.
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a = this.errors) === null || _a === void 0
            ? void 0
            : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          // Return 0 if we have no entity.
          return 0;
        }
      }
    }
  }
  /**
   * Creates a function that decodes entities in a string.
   *
   * @param decodeTree The decode tree.
   * @returns A function that decodes entities in a string.
   */
  function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder(
      decodeTree,
      (str) => (ret += fromCodePoint(str))
    );
    return function decodeWithTrie(str, decodeMode) {
      let lastIndex = 0;
      let offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        const len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        // If `len` is 0, skip the current `&` and continue.
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      const result = ret + str.slice(lastIndex);
      // Make sure we don't keep a reference to the final string.
      ret = "";
      return result;
    };
  }
  /**
   * Determines the branch of the current node that is taken given the current
   * character. This function is used to traverse the trie.
   *
   * @param decodeTree The trie.
   * @param current The current node.
   * @param nodeIdx The index right after the current node and its value.
   * @param char The current character.
   * @returns The index of the next node, or -1 if no branch is taken.
   */
  function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    // Case 1: Single branch encoded in jump offset
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    // Case 2: Multiple branches encoded in jump table
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount
        ? -1
        : decodeTree[nodeIdx + value] - 1;
    }
    // Case 3: Multiple branches encoded in dictionary
    // Binary search for the character.
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  const htmlDecoder = getDecoder(decode_data_html);
  const xmlDecoder = getDecoder(decode_data_xml);
  /**
   * Decodes an HTML string.
   *
   * @param str The string to decode.
   * @param mode The decoding mode.
   * @returns The decoded string.
   */
  function decodeHTML(str, mode = decode_DecodingMode.Legacy) {
    return htmlDecoder(str, mode);
  }
  /**
   * Decodes an HTML string in an attribute.
   *
   * @param str The string to decode.
   * @returns The decoded string.
   */
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, decode_DecodingMode.Attribute);
  }
  /**
   * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
   *
   * @param str The string to decode.
   * @returns The decoded string.
   */
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, decode_DecodingMode.Strict);
  }
  /**
   * Decodes an XML string, requiring all entities to be terminated by a semicolon.
   *
   * @param str The string to decode.
   * @returns The decoded string.
   */
  function decodeXML(str) {
    return xmlDecoder(str, decode_DecodingMode.Strict);
  } // CONCATENATED MODULE: ./node_modules/entities/lib/esm/generated/encode-html.js
  //# sourceMappingURL=decode.js.map
  // Generated using scripts/write-encode-map.ts
  function restoreDiff(arr) {
    for (let i = 1; i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  }
  // prettier-ignore
  /* harmony default export */ const encode_html = (new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]))); // CONCATENATED MODULE: ./node_modules/entities/lib/esm/escape.js
  //# sourceMappingURL=encode-html.js.map
  const escape_xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  const xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"],
  ]);
  // For compatibility with node < 4, we wrap `codePointAt`
  const escape_getCodePoint =
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null
      ? (str, index) => str.codePointAt(index)
      : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (c, index) =>
          (c.charCodeAt(index) & 0xfc00) === 0xd800
            ? (c.charCodeAt(index) - 0xd800) * 0x400 +
              c.charCodeAt(index + 1) -
              0xdc00 +
              0x10000
            : c.charCodeAt(index);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using XML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */
  function escape_encodeXML(str) {
    let ret = "";
    let lastIdx = 0;
    let match;
    while ((match = escape_xmlReplacer.exec(str)) !== null) {
      const i = match.index;
      const char = str.charCodeAt(i);
      const next = xmlCodeMap.get(char);
      if (next !== undefined) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += `${str.substring(lastIdx, i)}&#x${escape_getCodePoint(str, i).toString(16)};`;
        // Increase by 1 if we have a surrogate pair
        lastIdx = escape_xmlReplacer.lastIndex += Number(
          (char & 0xfc00) === 0xd800
        );
      }
    }
    return ret + str.substr(lastIdx);
  }
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using numeric hexadecimal reference (eg. `&#xfc;`).
   *
   * Have a look at `escapeUTF8` if you want a more concise output at the expense
   * of reduced transportability.
   *
   * @param data String to escape.
   */
  const escape_escape =
    /* unused pure expression or super */ null && escape_encodeXML;
  /**
   * Creates a function that escapes all characters matched by the given regular
   * expression using the given map of characters to escape to their entities.
   *
   * @param regex Regular expression to match characters to escape.
   * @param map Map of characters to escape to their entities.
   *
   * @returns Function that escapes all characters matched by the given regular
   * expression using the given map of characters to escape to their entities.
   */
  function getEscaper(regex, map) {
    return function escape(data) {
      let match;
      let lastIdx = 0;
      let result = "";
      while ((match = regex.exec(data))) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        // We know that this character will be in the map.
        result += map.get(match[0].charCodeAt(0));
        // Every match will be of length 1
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  }
  /**
   * Encodes all characters not valid in XML documents using XML entities.
   *
   * Note that the output will be character-set dependent.
   *
   * @param data String to escape.
   */
  const escape_escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  /**
   * Encodes all characters that have to be escaped in HTML attributes,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   *
   * @param data String to escape.
   */
  const escape_escapeAttribute = getEscaper(
    /["&\u00A0]/g,
    new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"],
    ])
  );
  /**
   * Encodes all characters that have to be escaped in HTML text,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   *
   * @param data String to escape.
   */
  const escape_escapeText = getEscaper(
    /[&<>\u00A0]/g,
    new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"],
    ])
  ); // CONCATENATED MODULE: ./node_modules/entities/lib/esm/encode.js
  //# sourceMappingURL=escape.js.map
  const htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  /**
   * Encodes all characters in the input using HTML entities. This includes
   * characters that are valid ASCII characters in HTML documents, such as `#`.
   *
   * To get a more compact output, consider using the `encodeNonAsciiHTML`
   * function, which will only encode characters that are not valid in HTML
   * documents, as well as non-ASCII characters.
   *
   * If a character has no equivalent entity, a numeric hexadecimal reference
   * (eg. `&#xfc;`) will be used.
   */
  function encode_encodeHTML(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
  }
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in HTML
   * documents using HTML entities. This function will not encode characters that
   * are valid in HTML documents, such as `#`.
   *
   * If a character has no equivalent entity, a numeric hexadecimal reference
   * (eg. `&#xfc;`) will be used.
   */
  function encode_encodeNonAsciiHTML(data) {
    return encodeHTMLTrieRe(xmlReplacer, data);
  }
  function encodeHTMLTrieRe(regExp, str) {
    let ret = "";
    let lastIdx = 0;
    let match;
    while ((match = regExp.exec(str)) !== null) {
      const i = match.index;
      ret += str.substring(lastIdx, i);
      const char = str.charCodeAt(i);
      let next = htmlTrie.get(char);
      if (typeof next === "object") {
        // We are in a branch. Try to match the next char.
        if (i + 1 < str.length) {
          const nextChar = str.charCodeAt(i + 1);
          const value =
            typeof next.n === "number"
              ? next.n === nextChar
                ? next.o
                : undefined
              : next.n.get(nextChar);
          if (value !== undefined) {
            ret += value;
            lastIdx = regExp.lastIndex += 1;
            continue;
          }
        }
        next = next.v;
      }
      // We might have a tree node without a value; skip and use a numeric entity.
      if (next !== undefined) {
        ret += next;
        lastIdx = i + 1;
      } else {
        const cp = getCodePoint(str, i);
        ret += `&#x${cp.toString(16)};`;
        // Increase by 1 if we have a surrogate pair
        lastIdx = regExp.lastIndex += Number(cp !== char);
      }
    }
    return ret + str.substr(lastIdx);
  } // CONCATENATED MODULE: ./node_modules/entities/lib/esm/index.js
  //# sourceMappingURL=encode.js.map
  /** The level of entities to support. */
  var EntityLevel;
  (function (EntityLevel) {
    /** Support only XML entities. */
    EntityLevel[(EntityLevel["XML"] = 0)] = "XML";
    /** Support HTML entities, which are a superset of XML entities. */
    EntityLevel[(EntityLevel["HTML"] = 1)] = "HTML";
  })(EntityLevel || (EntityLevel = {}));
  var EncodingMode;
  (function (EncodingMode) {
    /**
     * The output is UTF-8 encoded. Only characters that need escaping within
     * XML will be escaped.
     */
    EncodingMode[(EncodingMode["UTF8"] = 0)] = "UTF8";
    /**
     * The output consists only of ASCII characters. Characters that need
     * escaping within HTML, and characters that aren't ASCII characters will
     * be escaped.
     */
    EncodingMode[(EncodingMode["ASCII"] = 1)] = "ASCII";
    /**
     * Encode all characters that have an equivalent entity, as well as all
     * characters that are not ASCII characters.
     */
    EncodingMode[(EncodingMode["Extensive"] = 2)] = "Extensive";
    /**
     * Encode all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[(EncodingMode["Attribute"] = 3)] = "Attribute";
    /**
     * Encode all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[(EncodingMode["Text"] = 4)] = "Text";
  })(EncodingMode || (EncodingMode = {}));
  /**
   * Decodes a string with entities.
   *
   * @param data String to decode.
   * @param options Decoding options.
   */
  function decode(data, options = EntityLevel.XML) {
    const level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
      const mode = typeof options === "object" ? options.mode : undefined;
      return decodeHTML(data, mode);
    }
    return decodeXML(data);
  }
  /**
   * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
   *
   * @param data String to decode.
   * @param options Decoding options.
   * @deprecated Use `decode` with the `mode` set to `Strict`.
   */
  function decodeStrict(data, options = EntityLevel.XML) {
    var _a;
    const opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== void 0
      ? _a
      : (opts.mode = DecodingMode.Strict);
    return decode(data, opts);
  }
  /**
   * Encodes a string with entities.
   *
   * @param data String to encode.
   * @param options Encoding options.
   */
  function encode(data, options = EntityLevel.XML) {
    const opts = typeof options === "number" ? { level: options } : options;
    // Mode `UTF8` just escapes XML entities
    if (opts.mode === EncodingMode.UTF8) return escapeUTF8(data);
    if (opts.mode === EncodingMode.Attribute) return escapeAttribute(data);
    if (opts.mode === EncodingMode.Text) return escapeText(data);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return encodeNonAsciiHTML(data);
      }
      return encodeHTML(data);
    }
    // ASCII and Extensive are equivalent
    return encodeXML(data);
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/utils.js

  //# sourceMappingURL=index.js.map
  function utils_findMax(items, propOrFunc) {
    assert(items.length, "Cannot find max of empty array");
    const score = (item, idx) =>
      propOrFunc === undefined
        ? item
        : typeof propOrFunc === "function"
          ? propOrFunc(item, idx, items)
          : item[propOrFunc];
    let maxScore = score(items[0], 0);
    let maxIdx = 0;
    for (let i = 1; i < items.length; i++) {
      const itemScore = score(items[i], i);
      if (itemScore > maxScore) {
        maxScore = itemScore;
        maxIdx = i;
      }
    }
    return items[maxIdx];
  }
  function htmlString() {
    return lib_z.string().transform((s) => {
      if (!s || typeof s !== "string") {
        return s;
      }
      // decode HTML entities
      s = decode(s.trim());
      // remove anchor targets
      s = s.replace(/\btarget=[^\s>]+/g, "");
      // remove excess space
      s = s.replace(/ +/g, " ");
      s = s.replace(/\r/g, "");
      s = s.replace(/[\t ]*\n[\t ]*(\n[\t ]*)+/g, "\n\n");
      return s;
    });
  }
  function utils_countNonUnique(arr) {
    return arr.length - new Set(arr).size;
  }
  function utils_isError(thing) {
    return thing instanceof Error;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/feeds.types.js
  //# sourceMappingURL=utils.js.map
  const feeds_types_channels = ["lts", "stable", "beta", "unstable"];
  const channelSchema = lib_z["enum"](feeds_types_channels);
  Object.freeze(feeds_types_channels);
  const artifactTypes = ["ide", "runtime"];
  Object.freeze(artifactTypes);
  const feeds_types_rssFeedSchema = lib_z.object({
    rss: lib_z.object({
      channel: lib_z.object({
        title: htmlString(),
        description: htmlString(),
        link: lib_z.string(),
        item: lib_z.preprocess(
          (arg) => {
            if (!Array.isArray(arg)) {
              return [arg];
            }
            return arg;
          },
          lib_z.array(
            lib_z.object({
              title: lib_z.string().regex(/^Version \d+\.\d+\.\d+\.\d+$/),
              pubDate: lib_z.string(),
              link: lib_z.string().optional(),
              comments: lib_z.string(),
              description: htmlString().optional(),
            })
          )
        ),
      }),
    }),
  });
  const feeds_types_gameMakerArtifactSchema = lib_z.object({
    type: lib_z["enum"](artifactTypes),
    version: lib_z.string().regex(/^\d+\.\d+\.\d+\.\d+$/),
    channel: channelSchema,
    summary: lib_z.string().optional(),
    feedUrl: lib_z.string(),
    publishedAt: lib_z.string().transform((arg) => new Date(arg).toISOString()),
    link: lib_z.string().optional(),
    notesUrl: lib_z.string(),
  });
  const gameMakerArtifactWithNotesSchema =
    feeds_types_gameMakerArtifactSchema.extend({
      notes: lib_z.object({
        since: lib_z.string().nullable(),
        groups: lib_z.array(
          lib_z.object({
            title: htmlString(),
            changes: lib_z.array(htmlString()),
          })
        ),
      }),
    });
  const gameMakerReleaseBaseSchema = lib_z.object({
    channel: channelSchema,
    publishedAt: lib_z
      .string()
      .transform((arg) => new Date(arg).toISOString())
      .describe("Date of release for the IDE in this pair"),
    summary: htmlString().describe(
      "Summary of the release, from the RSS feed for the IDE"
    ),
  });
  const feeds_types_gameMakerReleaseWithNotesSchema =
    gameMakerReleaseBaseSchema.extend({
      ide: gameMakerArtifactWithNotesSchema.omit({ summary: true }),
      runtime: gameMakerArtifactWithNotesSchema.omit({ summary: true }),
    });
  const feeds_types_gameMakerReleaseSchema = gameMakerReleaseBaseSchema.extend({
    ide: feeds_types_gameMakerArtifactSchema.omit({ summary: true }),
    runtime: feeds_types_gameMakerArtifactSchema.omit({ summary: true }),
  });
  const feeds_types_rawReleaseNoteSchema = lib_z
    .object({
      type: lib_z["enum"](artifactTypes).optional(),
      version: lib_z.string(),
      release_notes: lib_z.array(lib_z.string()),
    })
    .strict();
  const feeds_types_rawReleaseNotesCacheSchema = lib_z.record(
    feeds_types_rawReleaseNoteSchema
  ); // CONCATENATED MODULE: external "node:http"
  //# sourceMappingURL=feeds.types.js.map
  const external_node_http_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:http"); // CONCATENATED MODULE: external "node:https"
  const external_node_https_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:https"); // CONCATENATED MODULE: external "node:zlib"
  const external_node_zlib_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:zlib");
  // EXTERNAL MODULE: external "node:stream"
  var external_node_stream_ = __nccwpck_require__(4492); // CONCATENATED MODULE: external "node:buffer"
  const external_node_buffer_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:buffer"); // CONCATENATED MODULE: ./node_modules/data-uri-to-buffer/dist/index.js
  /**
   * Returns a `Buffer` instance from the given data URI `uri`.
   *
   * @param {String} uri Data URI to turn into a Buffer instance
   * @returns {Buffer} Buffer instance from Data URI
   * @api public
   */
  function dataUriToBuffer(uri) {
    if (!/^data:/i.test(uri)) {
      throw new TypeError(
        '`uri` does not appear to be a Data URI (must begin with "data:")'
      );
    }
    // strip newlines
    uri = uri.replace(/\r?\n/g, "");
    // split the URI up into the "metadata" and the "data" portions
    const firstComma = uri.indexOf(",");
    if (firstComma === -1 || firstComma <= 4) {
      throw new TypeError("malformed data: URI");
    }
    // remove the "data:" scheme and parse the metadata
    const meta = uri.substring(5, firstComma).split(";");
    let charset = "";
    let base64 = false;
    const type = meta[0] || "text/plain";
    let typeFull = type;
    for (let i = 1; i < meta.length; i++) {
      if (meta[i] === "base64") {
        base64 = true;
      } else if (meta[i]) {
        typeFull += `;${meta[i]}`;
        if (meta[i].indexOf("charset=") === 0) {
          charset = meta[i].substring(8);
        }
      }
    }
    // defaults to US-ASCII only if type is not provided
    if (!meta[0] && !charset.length) {
      typeFull += ";charset=US-ASCII";
      charset = "US-ASCII";
    }
    // get the encoded data portion and decode URI-encoded chars
    const encoding = base64 ? "base64" : "ascii";
    const data = unescape(uri.substring(firstComma + 1));
    const buffer = Buffer.from(data, encoding);
    // set `.type` and `.typeFull` properties to MIME type
    buffer.type = type;
    buffer.typeFull = typeFull;
    // set the `.charset` property
    buffer.charset = charset;
    return buffer;
  }
  /* harmony default export */ const dist = dataUriToBuffer;
  //# sourceMappingURL=index.js.map
  // EXTERNAL MODULE: external "node:util"
  var external_node_util_ = __nccwpck_require__(7261);
  // EXTERNAL MODULE: ./node_modules/fetch-blob/index.js
  var fetch_blob = __nccwpck_require__(1410);
  // EXTERNAL MODULE: ./node_modules/formdata-polyfill/esm.min.js
  var esm_min = __nccwpck_require__(8010); // CONCATENATED MODULE: ./node_modules/node-fetch/src/errors/base.js
  class FetchBaseError extends Error {
    constructor(message, type) {
      super(message);
      // Hide custom error implementation details from end-users
      Error.captureStackTrace(this, this.constructor);

      this.type = type;
    }

    get name() {
      return this.constructor.name;
    }

    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  } // CONCATENATED MODULE: ./node_modules/node-fetch/src/errors/fetch-error.js

  /**
   * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
   */

  /**
   * FetchError interface for operational errors
   */
  class FetchError extends FetchBaseError {
    /**
     * @param  {string} message -      Error message for human
     * @param  {string} [type] -        Error type for machine
     * @param  {SystemError} [systemError] - For Node.js system error
     */
    constructor(message, type, systemError) {
      super(message, type);
      // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
      if (systemError) {
        // eslint-disable-next-line no-multi-assign
        this.code = this.errno = systemError.code;
        this.erroredSysCall = systemError.syscall;
      }
    }
  } // CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/is.js

  /**
   * Is.js
   *
   * Object type checks.
   */

  const NAME = Symbol.toStringTag;

  /**
   * Check if `obj` is a URLSearchParams object
   * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
   * @param {*} object - Object to check for
   * @return {boolean}
   */
  const isURLSearchParameters = (object) => {
    return (
      typeof object === "object" &&
      typeof object.append === "function" &&
      typeof object.delete === "function" &&
      typeof object.get === "function" &&
      typeof object.getAll === "function" &&
      typeof object.has === "function" &&
      typeof object.set === "function" &&
      typeof object.sort === "function" &&
      object[NAME] === "URLSearchParams"
    );
  };

  /**
   * Check if `object` is a W3C `Blob` object (which `File` inherits from)
   * @param {*} object - Object to check for
   * @return {boolean}
   */
  const isBlob = (object) => {
    return (
      object &&
      typeof object === "object" &&
      typeof object.arrayBuffer === "function" &&
      typeof object.type === "string" &&
      typeof object.stream === "function" &&
      typeof object.constructor === "function" &&
      /^(Blob|File)$/.test(object[NAME])
    );
  };

  /**
   * Check if `obj` is an instance of AbortSignal.
   * @param {*} object - Object to check for
   * @return {boolean}
   */
  const isAbortSignal = (object) => {
    return (
      typeof object === "object" &&
      (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget")
    );
  };

  /**
   * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
   * the parent domain.
   *
   * Both domains must already be in canonical form.
   * @param {string|URL} original
   * @param {string|URL} destination
   */
  const isDomainOrSubdomain = (destination, original) => {
    const orig = new URL(original).hostname;
    const dest = new URL(destination).hostname;

    return orig === dest || orig.endsWith(`.${dest}`);
  };

  /**
   * isSameProtocol reports whether the two provided URLs use the same protocol.
   *
   * Both domains must already be in canonical form.
   * @param {string|URL} original
   * @param {string|URL} destination
   */
  const isSameProtocol = (destination, original) => {
    const orig = new URL(original).protocol;
    const dest = new URL(destination).protocol;

    return orig === dest;
  }; // CONCATENATED MODULE: ./node_modules/node-fetch/src/body.js

  /**
   * Body.js
   *
   * Body interface provides common methods for Request and Response
   */

  const pipeline = (0, external_node_util_.promisify)(
    external_node_stream_.pipeline
  );
  const INTERNALS = Symbol("Body internals");

  /**
   * Body mixin
   *
   * Ref: https://fetch.spec.whatwg.org/#body
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */
  class Body {
    constructor(body, { size = 0 } = {}) {
      let boundary = null;

      if (body === null) {
        // Body is undefined or null
        body = null;
      } else if (isURLSearchParameters(body)) {
        // Body is a URLSearchParams
        body = external_node_buffer_namespaceObject.Buffer.from(
          body.toString()
        );
      } else if (isBlob(body)) {
        // Body is blob
      } else if (external_node_buffer_namespaceObject.Buffer.isBuffer(body)) {
        // Body is Buffer
      } else if (external_node_util_.types.isAnyArrayBuffer(body)) {
        // Body is ArrayBuffer
        body = external_node_buffer_namespaceObject.Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        // Body is ArrayBufferView
        body = external_node_buffer_namespaceObject.Buffer.from(
          body.buffer,
          body.byteOffset,
          body.byteLength
        );
      } else if (body instanceof external_node_stream_) {
        // Body is stream
      } else if (body instanceof esm_min /* FormData */.Ct) {
        // Body is FormData
        body = (0, esm_min /* formDataToBlob */.au)(body);
        boundary = body.type.split("=")[1];
      } else {
        // None of the above
        // coerce to string then buffer
        body = external_node_buffer_namespaceObject.Buffer.from(String(body));
      }

      let stream = body;

      if (external_node_buffer_namespaceObject.Buffer.isBuffer(body)) {
        stream = external_node_stream_.Readable.from(body);
      } else if (isBlob(body)) {
        stream = external_node_stream_.Readable.from(body.stream());
      }

      this[INTERNALS] = {
        body,
        stream,
        boundary,
        disturbed: false,
        error: null,
      };
      this.size = size;

      if (body instanceof external_node_stream_) {
        body.on("error", (error_) => {
          const error =
            error_ instanceof FetchBaseError
              ? error_
              : new FetchError(
                  `Invalid response body while trying to fetch ${this.url}: ${error_.message}`,
                  "system",
                  error_
                );
          this[INTERNALS].error = error;
        });
      }
    }

    get body() {
      return this[INTERNALS].stream;
    }

    get bodyUsed() {
      return this[INTERNALS].disturbed;
    }

    /**
     * Decode response as ArrayBuffer
     *
     * @return  Promise
     */
    async arrayBuffer() {
      const { buffer, byteOffset, byteLength } = await consumeBody(this);
      return buffer.slice(byteOffset, byteOffset + byteLength);
    }

    async formData() {
      const ct = this.headers.get("content-type");

      if (ct.startsWith("application/x-www-form-urlencoded")) {
        const formData = new esm_min /* FormData */.Ct();
        const parameters = new URLSearchParams(await this.text());

        for (const [name, value] of parameters) {
          formData.append(name, value);
        }

        return formData;
      }

      const { toFormData } = await __nccwpck_require__
        .e(/* import() */ 37)
        .then(__nccwpck_require__.bind(__nccwpck_require__, 4037));
      return toFormData(this.body, ct);
    }

    /**
     * Return raw response as Blob
     *
     * @return Promise
     */
    async blob() {
      const ct =
        (this.headers && this.headers.get("content-type")) ||
        (this[INTERNALS].body && this[INTERNALS].body.type) ||
        "";
      const buf = await this.arrayBuffer();

      return new fetch_blob /* default */.Z([buf], {
        type: ct,
      });
    }

    /**
     * Decode response as json
     *
     * @return  Promise
     */
    async json() {
      const text = await this.text();
      return JSON.parse(text);
    }

    /**
     * Decode response as text
     *
     * @return  Promise
     */
    async text() {
      const buffer = await consumeBody(this);
      return new TextDecoder().decode(buffer);
    }

    /**
     * Decode response as buffer (non-spec api)
     *
     * @return  Promise
     */
    buffer() {
      return consumeBody(this);
    }
  }

  Body.prototype.buffer = (0, external_node_util_.deprecate)(
    Body.prototype.buffer,
    "Please use 'response.arrayBuffer()' instead of 'response.buffer()'",
    "node-fetch#buffer"
  );

  // In browsers, all properties are enumerable.
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true },
    data: {
      get: (0, external_node_util_.deprecate)(
        () => {},
        "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
        "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
      ),
    },
  });

  /**
   * Consume and convert an entire Body to a Buffer.
   *
   * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
   *
   * @return Promise
   */
  async function consumeBody(data) {
    if (data[INTERNALS].disturbed) {
      throw new TypeError(`body used already for: ${data.url}`);
    }

    data[INTERNALS].disturbed = true;

    if (data[INTERNALS].error) {
      throw data[INTERNALS].error;
    }

    const { body } = data;

    // Body is null
    if (body === null) {
      return external_node_buffer_namespaceObject.Buffer.alloc(0);
    }

    /* c8 ignore next 3 */
    if (!(body instanceof external_node_stream_)) {
      return external_node_buffer_namespaceObject.Buffer.alloc(0);
    }

    // Body is stream
    // get ready to actually consume the body
    const accum = [];
    let accumBytes = 0;

    try {
      for await (const chunk of body) {
        if (data.size > 0 && accumBytes + chunk.length > data.size) {
          const error = new FetchError(
            `content size at ${data.url} over limit: ${data.size}`,
            "max-size"
          );
          body.destroy(error);
          throw error;
        }

        accumBytes += chunk.length;
        accum.push(chunk);
      }
    } catch (error) {
      const error_ =
        error instanceof FetchBaseError
          ? error
          : new FetchError(
              `Invalid response body while trying to fetch ${data.url}: ${error.message}`,
              "system",
              error
            );
      throw error_;
    }

    if (body.readableEnded === true || body._readableState.ended === true) {
      try {
        if (accum.every((c) => typeof c === "string")) {
          return external_node_buffer_namespaceObject.Buffer.from(
            accum.join("")
          );
        }

        return external_node_buffer_namespaceObject.Buffer.concat(
          accum,
          accumBytes
        );
      } catch (error) {
        throw new FetchError(
          `Could not create Buffer from response body for ${data.url}: ${error.message}`,
          "system",
          error
        );
      }
    } else {
      throw new FetchError(
        `Premature close of server response while trying to fetch ${data.url}`
      );
    }
  }

  /**
   * Clone body given Res/Req instance
   *
   * @param   Mixed   instance       Response or Request instance
   * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
   * @return  Mixed
   */
  const clone = (instance, highWaterMark) => {
    let p1;
    let p2;
    let { body } = instance[INTERNALS];

    // Don't allow cloning a used body
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }

    // Check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (
      body instanceof external_node_stream_ &&
      typeof body.getBoundary !== "function"
    ) {
      // Tee instance body
      p1 = new external_node_stream_.PassThrough({ highWaterMark });
      p2 = new external_node_stream_.PassThrough({ highWaterMark });
      body.pipe(p1);
      body.pipe(p2);
      // Set instance body to teed body and return the other teed body
      instance[INTERNALS].stream = p1;
      body = p2;
    }

    return body;
  };

  const getNonSpecFormDataBoundary = (0, external_node_util_.deprecate)(
    (body) => body.getBoundary(),
    "form-data doesn't follow the spec and requires special treatment. Use alternative package",
    "https://github.com/node-fetch/node-fetch/issues/1167"
  );

  /**
   * Performs the operation "extract a `Content-Type` value from |object|" as
   * specified in the specification:
   * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
   *
   * This function assumes that instance.body is present.
   *
   * @param {any} body Any options.body input
   * @returns {string | null}
   */
  const extractContentType = (body, request) => {
    // Body is null or undefined
    if (body === null) {
      return null;
    }

    // Body is string
    if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    }

    // Body is a URLSearchParams
    if (isURLSearchParameters(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    }

    // Body is blob
    if (isBlob(body)) {
      return body.type || null;
    }

    // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
    if (
      external_node_buffer_namespaceObject.Buffer.isBuffer(body) ||
      external_node_util_.types.isAnyArrayBuffer(body) ||
      ArrayBuffer.isView(body)
    ) {
      return null;
    }

    if (body instanceof esm_min /* FormData */.Ct) {
      return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
    }

    // Detect form data input from form-data module
    if (body && typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
    }

    // Body is stream - can't really do much about this
    if (body instanceof external_node_stream_) {
      return null;
    }

    // Body constructor defaults other things to string
    return "text/plain;charset=UTF-8";
  };

  /**
   * The Fetch Standard treats this as if "total bytes" is a property on the body.
   * For us, we have to explicitly get it with a function.
   *
   * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
   *
   * @param {any} obj.body Body object from the Body instance.
   * @returns {number | null}
   */
  const getTotalBytes = (request) => {
    const { body } = request[INTERNALS];

    // Body is null or undefined
    if (body === null) {
      return 0;
    }

    // Body is Blob
    if (isBlob(body)) {
      return body.size;
    }

    // Body is Buffer
    if (external_node_buffer_namespaceObject.Buffer.isBuffer(body)) {
      return body.length;
    }

    // Detect form data input from form-data module
    if (body && typeof body.getLengthSync === "function") {
      return body.hasKnownLength && body.hasKnownLength()
        ? body.getLengthSync()
        : null;
    }

    // Body is stream
    return null;
  };

  /**
   * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
   *
   * @param {Stream.Writable} dest The stream to write to.
   * @param obj.body Body object from the Body instance.
   * @returns {Promise<void>}
   */
  const writeToStream = async (dest, { body }) => {
    if (body === null) {
      // Body is null
      dest.end();
    } else {
      // Body is stream
      await pipeline(body, dest);
    }
  }; // CONCATENATED MODULE: ./node_modules/node-fetch/src/headers.js

  /**
   * Headers.js
   *
   * Headers class offers convenient helpers
   */

  /* c8 ignore next 9 */
  const validateHeaderName =
    typeof external_node_http_namespaceObject.validateHeaderName === "function"
      ? external_node_http_namespaceObject.validateHeaderName
      : (name) => {
          if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
            const error = new TypeError(
              `Header name must be a valid HTTP token [${name}]`
            );
            Object.defineProperty(error, "code", {
              value: "ERR_INVALID_HTTP_TOKEN",
            });
            throw error;
          }
        };

  /* c8 ignore next 9 */
  const validateHeaderValue =
    typeof external_node_http_namespaceObject.validateHeaderValue === "function"
      ? external_node_http_namespaceObject.validateHeaderValue
      : (name, value) => {
          if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
            const error = new TypeError(
              `Invalid character in header content ["${name}"]`
            );
            Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
            throw error;
          }
        };

  /**
   * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
   */

  /**
   * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
   * These actions include retrieving, setting, adding to, and removing.
   * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
   * You can add to this using methods like append() (see Examples.)
   * In all methods of this interface, header names are matched by case-insensitive byte sequence.
   *
   */
  class Headers extends URLSearchParams {
    /**
     * Headers class
     *
     * @constructor
     * @param {HeadersInit} [init] - Response headers
     */
    constructor(init) {
      // Validate and normalize init object in [name, value(s)][]
      /** @type {string[][]} */
      let result = [];
      if (init instanceof Headers) {
        const raw = init.raw();
        for (const [name, values] of Object.entries(raw)) {
          result.push(...values.map((value) => [name, value]));
        }
      } else if (init == null) {
        // eslint-disable-line no-eq-null, eqeqeq
        // No op
      } else if (
        typeof init === "object" &&
        !external_node_util_.types.isBoxedPrimitive(init)
      ) {
        const method = init[Symbol.iterator];
        // eslint-disable-next-line no-eq-null, eqeqeq
        if (method == null) {
          // Record<ByteString, ByteString>
          result.push(...Object.entries(init));
        } else {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }

          // Sequence<sequence<ByteString>>
          // Note: per spec we have to first exhaust the lists then process them
          result = [...init]
            .map((pair) => {
              if (
                typeof pair !== "object" ||
                external_node_util_.types.isBoxedPrimitive(pair)
              ) {
                throw new TypeError(
                  "Each header pair must be an iterable object"
                );
              }

              return [...pair];
            })
            .map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError(
                  "Each header pair must be a name/value tuple"
                );
              }

              return [...pair];
            });
        }
      } else {
        throw new TypeError(
          "Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)"
        );
      }

      // Validate and lowercase
      result =
        result.length > 0
          ? result.map(([name, value]) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return [String(name).toLowerCase(), String(value)];
            })
          : undefined;

      super(result);

      // Returning a Proxy that will lowercase key names, validate parameters and sort keys
      // eslint-disable-next-line no-constructor-return
      return new Proxy(this, {
        get(target, p, receiver) {
          switch (p) {
            case "append":
            case "set":
              return (name, value) => {
                validateHeaderName(name);
                validateHeaderValue(name, String(value));
                return URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase(),
                  String(value)
                );
              };

            case "delete":
            case "has":
            case "getAll":
              return (name) => {
                validateHeaderName(name);
                return URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase()
                );
              };

            case "keys":
              return () => {
                target.sort();
                return new Set(
                  URLSearchParams.prototype.keys.call(target)
                ).keys();
              };

            default:
              return Reflect.get(target, p, receiver);
          }
        },
      });
      /* c8 ignore next */
    }

    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }

    toString() {
      return Object.prototype.toString.call(this);
    }

    get(name) {
      const values = this.getAll(name);
      if (values.length === 0) {
        return null;
      }

      let value = values.join(", ");
      if (/^content-encoding$/i.test(name)) {
        value = value.toLowerCase();
      }

      return value;
    }

    forEach(callback, thisArg = undefined) {
      for (const name of this.keys()) {
        Reflect.apply(callback, thisArg, [this.get(name), name, this]);
      }
    }

    *values() {
      for (const name of this.keys()) {
        yield this.get(name);
      }
    }

    /**
     * @type {() => IterableIterator<[string, string]>}
     */
    *entries() {
      for (const name of this.keys()) {
        yield [name, this.get(name)];
      }
    }

    [Symbol.iterator]() {
      return this.entries();
    }

    /**
     * Node-fetch non-spec method
     * returning all headers and their values as array
     * @returns {Record<string, string[]>}
     */
    raw() {
      return [...this.keys()].reduce((result, key) => {
        result[key] = this.getAll(key);
        return result;
      }, {});
    }

    /**
     * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return [...this.keys()].reduce((result, key) => {
        const values = this.getAll(key);
        // Http.request() only supports string as Host header.
        // This hack makes specifying custom Host header possible.
        if (key === "host") {
          result[key] = values[0];
        } else {
          result[key] = values.length > 1 ? values : values[0];
        }

        return result;
      }, {});
    }
  }

  /**
   * Re-shaping object for Web IDL tests
   * Only need to do it for overridden methods
   */
  Object.defineProperties(
    Headers.prototype,
    ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {})
  );

  /**
   * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
   * not conform to HTTP grammar productions.
   * @param {import('http').IncomingMessage['rawHeaders']} headers
   */
  function fromRawHeaders(headers = []) {
    return new Headers(
      headers
        // Split into pairs
        .reduce((result, value, index, array) => {
          if (index % 2 === 0) {
            result.push(array.slice(index, index + 2));
          }

          return result;
        }, [])
        .filter(([name, value]) => {
          try {
            validateHeaderName(name);
            validateHeaderValue(name, String(value));
            return true;
          } catch {
            return false;
          }
        })
    );
  } // CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/is-redirect.js

  const redirectStatus = new Set([301, 302, 303, 307, 308]);

  /**
   * Redirect code matching
   *
   * @param {number} code - Status code
   * @return {boolean}
   */
  const isRedirect = (code) => {
    return redirectStatus.has(code);
  }; // CONCATENATED MODULE: ./node_modules/node-fetch/src/response.js

  /**
   * Response.js
   *
   * Response class provides content decoding
   */

  const response_INTERNALS = Symbol("Response internals");

  /**
   * Response class
   *
   * Ref: https://fetch.spec.whatwg.org/#response-class
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */
  class Response extends Body {
    constructor(body = null, options = {}) {
      super(body, options);

      // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
      const status = options.status != null ? options.status : 200;

      const headers = new Headers(options.headers);

      if (body !== null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body, this);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }

      this[response_INTERNALS] = {
        type: "default",
        url: options.url,
        status,
        statusText: options.statusText || "",
        headers,
        counter: options.counter,
        highWaterMark: options.highWaterMark,
      };
    }

    get type() {
      return this[response_INTERNALS].type;
    }

    get url() {
      return this[response_INTERNALS].url || "";
    }

    get status() {
      return this[response_INTERNALS].status;
    }

    /**
     * Convenience property representing if the request ended normally
     */
    get ok() {
      return (
        this[response_INTERNALS].status >= 200 &&
        this[response_INTERNALS].status < 300
      );
    }

    get redirected() {
      return this[response_INTERNALS].counter > 0;
    }

    get statusText() {
      return this[response_INTERNALS].statusText;
    }

    get headers() {
      return this[response_INTERNALS].headers;
    }

    get highWaterMark() {
      return this[response_INTERNALS].highWaterMark;
    }

    /**
     * Clone this response
     *
     * @return  Response
     */
    clone() {
      return new Response(clone(this, this.highWaterMark), {
        type: this.type,
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected,
        size: this.size,
        highWaterMark: this.highWaterMark,
      });
    }

    /**
     * @param {string} url    The URL that the new response is to originate from.
     * @param {number} status An optional status code for the response (e.g., 302.)
     * @returns {Response}    A Response object.
     */
    static redirect(url, status = 302) {
      if (!isRedirect(status)) {
        throw new RangeError(
          'Failed to execute "redirect" on "response": Invalid status code'
        );
      }

      return new Response(null, {
        headers: {
          location: new URL(url).toString(),
        },
        status,
      });
    }

    static error() {
      const response = new Response(null, { status: 0, statusText: "" });
      response[response_INTERNALS].type = "error";
      return response;
    }

    static json(data = undefined, init = {}) {
      const body = JSON.stringify(data);

      if (body === undefined) {
        throw new TypeError("data is not JSON serializable");
      }

      const headers = new Headers(init && init.headers);

      if (!headers.has("content-type")) {
        headers.set("content-type", "application/json");
      }

      return new Response(body, {
        ...init,
        headers,
      });
    }

    get [Symbol.toStringTag]() {
      return "Response";
    }
  }

  Object.defineProperties(Response.prototype, {
    type: { enumerable: true },
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true },
  }); // CONCATENATED MODULE: external "node:url"

  const external_node_url_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:url"); // CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/get-search.js
  const getSearch = (parsedURL) => {
    if (parsedURL.search) {
      return parsedURL.search;
    }

    const lastOffset = parsedURL.href.length - 1;
    const hash =
      parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
    return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
  }; // CONCATENATED MODULE: external "node:net"

  const external_node_net_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:net"); // CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/referrer.js
  /**
   * @external URL
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
   */

  /**
   * @module utils/referrer
   * @private
   */

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}
   * @param {string} URL
   * @param {boolean} [originOnly=false]
   */
  function stripURLForUseAsAReferrer(url, originOnly = false) {
    // 1. If url is null, return no referrer.
    if (url == null) {
      // eslint-disable-line no-eq-null, eqeqeq
      return "no-referrer";
    }

    url = new URL(url);

    // 2. If url's scheme is a local scheme, then return no referrer.
    if (/^(about|blob|data):$/.test(url.protocol)) {
      return "no-referrer";
    }

    // 3. Set url's username to the empty string.
    url.username = "";

    // 4. Set url's password to null.
    // Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
    url.password = "";

    // 5. Set url's fragment to null.
    // Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
    url.hash = "";

    // 6. If the origin-only flag is true, then:
    if (originOnly) {
      // 6.1. Set url's path to null.
      // Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
      url.pathname = "";

      // 6.2. Set url's query to null.
      // Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
      url.search = "";
    }

    // 7. Return url.
    return url;
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
   */
  const ReferrerPolicy = new Set([
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url",
  ]);

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
   */
  const DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}
   * @param {string} referrerPolicy
   * @returns {string} referrerPolicy
   */
  function validateReferrerPolicy(referrerPolicy) {
    if (!ReferrerPolicy.has(referrerPolicy)) {
      throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
    }

    return referrerPolicy;
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}
   * @param {external:URL} url
   * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
   */
  function isOriginPotentiallyTrustworthy(url) {
    // 1. If origin is an opaque origin, return "Not Trustworthy".
    // Not applicable

    // 2. Assert: origin is a tuple origin.
    // Not for implementations

    // 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
    if (/^(http|ws)s:$/.test(url.protocol)) {
      return true;
    }

    // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
    const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
    const hostIPVersion = (0, external_node_net_namespaceObject.isIP)(hostIp);

    if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
      return true;
    }

    if (
      hostIPVersion === 6 &&
      /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)
    ) {
      return true;
    }

    // 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
    // We are returning FALSE here because we cannot ensure conformance to
    // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
    if (url.host === "localhost" || url.host.endsWith(".localhost")) {
      return false;
    }

    // 6. If origin's scheme component is file, return "Potentially Trustworthy".
    if (url.protocol === "file:") {
      return true;
    }

    // 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
    // Not supported

    // 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
    // Not supported

    // 9. Return "Not Trustworthy".
    return false;
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}
   * @param {external:URL} url
   * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
   */
  function isUrlPotentiallyTrustworthy(url) {
    // 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
    if (/^about:(blank|srcdoc)$/.test(url)) {
      return true;
    }

    // 2. If url's scheme is "data", return "Potentially Trustworthy".
    if (url.protocol === "data:") {
      return true;
    }

    // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
    // created. Therefore, blobs created in a trustworthy origin will themselves be potentially
    // trustworthy.
    if (/^(blob|filesystem):$/.test(url.protocol)) {
      return true;
    }

    // 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.
    return isOriginPotentiallyTrustworthy(url);
  }

  /**
   * Modifies the referrerURL to enforce any extra security policy considerations.
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
   * @callback module:utils/referrer~referrerURLCallback
   * @param {external:URL} referrerURL
   * @returns {external:URL} modified referrerURL
   */

  /**
   * Modifies the referrerOrigin to enforce any extra security policy considerations.
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
   * @callback module:utils/referrer~referrerOriginCallback
   * @param {external:URL} referrerOrigin
   * @returns {external:URL} modified referrerOrigin
   */

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}
   * @param {Request} request
   * @param {object} o
   * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
   * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
   * @returns {external:URL} Request's referrer
   */
  function determineRequestsReferrer(
    request,
    { referrerURLCallback, referrerOriginCallback } = {}
  ) {
    // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
    // these cases:
    // > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
    // > Note: If request's referrer policy is the empty string, Fetch will not call into this
    // > algorithm.
    if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
      return null;
    }

    // 1. Let policy be request's associated referrer policy.
    const policy = request.referrerPolicy;

    // 2. Let environment be request's client.
    // not applicable to node.js

    // 3. Switch on request's referrer:
    if (request.referrer === "about:client") {
      return "no-referrer";
    }

    // "a URL": Let referrerSource be request's referrer.
    const referrerSource = request.referrer;

    // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
    let referrerURL = stripURLForUseAsAReferrer(referrerSource);

    // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
    //    origin-only flag set to true.
    let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

    // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
    //    referrerURL to referrerOrigin.
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }

    // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
    //    policy considerations in the interests of minimizing data leakage. For example, the user
    //    agent could strip the URL down to an origin, modify its host, replace it with an empty
    //    string, etc.
    if (referrerURLCallback) {
      referrerURL = referrerURLCallback(referrerURL);
    }

    if (referrerOriginCallback) {
      referrerOrigin = referrerOriginCallback(referrerOrigin);
    }

    // 8.Execute the statements corresponding to the value of policy:
    const currentURL = new URL(request.url);

    switch (policy) {
      case "no-referrer":
        return "no-referrer";

      case "origin":
        return referrerOrigin;

      case "unsafe-url":
        return referrerURL;

      case "strict-origin":
        // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
        //    potentially trustworthy URL, then return no referrer.
        if (
          isUrlPotentiallyTrustworthy(referrerURL) &&
          !isUrlPotentiallyTrustworthy(currentURL)
        ) {
          return "no-referrer";
        }

        // 2. Return referrerOrigin.
        return referrerOrigin.toString();

      case "strict-origin-when-cross-origin":
        // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
        //    return referrerURL.
        if (referrerURL.origin === currentURL.origin) {
          return referrerURL;
        }

        // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
        //    potentially trustworthy URL, then return no referrer.
        if (
          isUrlPotentiallyTrustworthy(referrerURL) &&
          !isUrlPotentiallyTrustworthy(currentURL)
        ) {
          return "no-referrer";
        }

        // 3. Return referrerOrigin.
        return referrerOrigin;

      case "same-origin":
        // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
        //    return referrerURL.
        if (referrerURL.origin === currentURL.origin) {
          return referrerURL;
        }

        // 2. Return no referrer.
        return "no-referrer";

      case "origin-when-cross-origin":
        // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
        //    return referrerURL.
        if (referrerURL.origin === currentURL.origin) {
          return referrerURL;
        }

        // Return referrerOrigin.
        return referrerOrigin;

      case "no-referrer-when-downgrade":
        // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
        //    potentially trustworthy URL, then return no referrer.
        if (
          isUrlPotentiallyTrustworthy(referrerURL) &&
          !isUrlPotentiallyTrustworthy(currentURL)
        ) {
          return "no-referrer";
        }

        // 2. Return referrerURL.
        return referrerURL;

      default:
        throw new TypeError(`Invalid referrerPolicy: ${policy}`);
    }
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}
   * @param {Headers} headers Response headers
   * @returns {string} policy
   */
  function parseReferrerPolicyFromHeader(headers) {
    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
    //    and response’s header list.
    const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);

    // 2. Let policy be the empty string.
    let policy = "";

    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
    //    string, then set policy to token.
    // Note: This algorithm loops over multiple policy values to allow deployment of new policy
    // values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.
    for (const token of policyTokens) {
      if (token && ReferrerPolicy.has(token)) {
        policy = token;
      }
    }

    // 4. Return policy.
    return policy;
  } // CONCATENATED MODULE: ./node_modules/node-fetch/src/request.js

  /**
   * Request.js
   *
   * Request class contains server only options
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  const request_INTERNALS = Symbol("Request internals");

  /**
   * Check if `obj` is an instance of Request.
   *
   * @param  {*} object
   * @return {boolean}
   */
  const isRequest = (object) => {
    return (
      typeof object === "object" &&
      typeof object[request_INTERNALS] === "object"
    );
  };

  const doBadDataWarn = (0, external_node_util_.deprecate)(
    () => {},
    ".data is not a valid RequestInit property, use .body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
  );

  /**
   * Request class
   *
   * Ref: https://fetch.spec.whatwg.org/#request-class
   *
   * @param   Mixed   input  Url or Request instance
   * @param   Object  init   Custom options
   * @return  Void
   */
  class Request extends Body {
    constructor(input, init = {}) {
      let parsedURL;

      // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
      if (isRequest(input)) {
        parsedURL = new URL(input.url);
      } else {
        parsedURL = new URL(input);
        input = {};
      }

      if (parsedURL.username !== "" || parsedURL.password !== "") {
        throw new TypeError(
          `${parsedURL} is an url with embedded credentials.`
        );
      }

      let method = init.method || input.method || "GET";
      if (/^(delete|get|head|options|post|put)$/i.test(method)) {
        method = method.toUpperCase();
      }

      if (!isRequest(init) && "data" in init) {
        doBadDataWarn();
      }

      // eslint-disable-next-line no-eq-null, eqeqeq
      if (
        (init.body != null || (isRequest(input) && input.body !== null)) &&
        (method === "GET" || method === "HEAD")
      ) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }

      const inputBody = init.body
        ? init.body
        : isRequest(input) && input.body !== null
          ? clone(input)
          : null;

      super(inputBody, {
        size: init.size || input.size || 0,
      });

      const headers = new Headers(init.headers || input.headers || {});

      if (inputBody !== null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody, this);
        if (contentType) {
          headers.set("Content-Type", contentType);
        }
      }

      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init) {
        signal = init.signal;
      }

      // eslint-disable-next-line no-eq-null, eqeqeq
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError(
          "Expected signal to be an instanceof AbortSignal or EventTarget"
        );
      }

      // §5.4, Request constructor steps, step 15.1
      // eslint-disable-next-line no-eq-null, eqeqeq
      let referrer = init.referrer == null ? input.referrer : init.referrer;
      if (referrer === "") {
        // §5.4, Request constructor steps, step 15.2
        referrer = "no-referrer";
      } else if (referrer) {
        // §5.4, Request constructor steps, step 15.3.1, 15.3.2
        const parsedReferrer = new URL(referrer);
        // §5.4, Request constructor steps, step 15.3.3, 15.3.4
        referrer = /^about:(\/\/)?client$/.test(parsedReferrer)
          ? "client"
          : parsedReferrer;
      } else {
        referrer = undefined;
      }

      this[request_INTERNALS] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal,
        referrer,
      };

      // Node-fetch-only options
      this.follow =
        init.follow === undefined
          ? input.follow === undefined
            ? 20
            : input.follow
          : init.follow;
      this.compress =
        init.compress === undefined
          ? input.compress === undefined
            ? true
            : input.compress
          : init.compress;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
      this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
      this.insecureHTTPParser =
        init.insecureHTTPParser || input.insecureHTTPParser || false;

      // §5.4, Request constructor steps, step 16.
      // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
      this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
    }

    /** @returns {string} */
    get method() {
      return this[request_INTERNALS].method;
    }

    /** @returns {string} */
    get url() {
      return (0, external_node_url_namespaceObject.format)(
        this[request_INTERNALS].parsedURL
      );
    }

    /** @returns {Headers} */
    get headers() {
      return this[request_INTERNALS].headers;
    }

    get redirect() {
      return this[request_INTERNALS].redirect;
    }

    /** @returns {AbortSignal} */
    get signal() {
      return this[request_INTERNALS].signal;
    }

    // https://fetch.spec.whatwg.org/#dom-request-referrer
    get referrer() {
      if (this[request_INTERNALS].referrer === "no-referrer") {
        return "";
      }

      if (this[request_INTERNALS].referrer === "client") {
        return "about:client";
      }

      if (this[request_INTERNALS].referrer) {
        return this[request_INTERNALS].referrer.toString();
      }

      return undefined;
    }

    get referrerPolicy() {
      return this[request_INTERNALS].referrerPolicy;
    }

    set referrerPolicy(referrerPolicy) {
      this[request_INTERNALS].referrerPolicy =
        validateReferrerPolicy(referrerPolicy);
    }

    /**
     * Clone this request
     *
     * @return  Request
     */
    clone() {
      return new Request(this);
    }

    get [Symbol.toStringTag]() {
      return "Request";
    }
  }

  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true },
    referrer: { enumerable: true },
    referrerPolicy: { enumerable: true },
  });

  /**
   * Convert a Request to Node.js http request options.
   *
   * @param {Request} request - A Request instance
   * @return The options object to be passed to http.request
   */
  const getNodeRequestOptions = (request) => {
    const { parsedURL } = request[request_INTERNALS];
    const headers = new Headers(request[request_INTERNALS].headers);

    // Fetch step 1.3
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }

    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body === null && /^(post|put)$/i.test(request.method)) {
      contentLengthValue = "0";
    }

    if (request.body !== null) {
      const totalBytes = getTotalBytes(request);
      // Set Content-Length if totalBytes is a number (that is not NaN)
      if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
        contentLengthValue = String(totalBytes);
      }
    }

    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }

    // 4.1. Main fetch, step 2.6
    // > If request's referrer policy is the empty string, then set request's referrer policy to the
    // > default referrer policy.
    if (request.referrerPolicy === "") {
      request.referrerPolicy = DEFAULT_REFERRER_POLICY;
    }

    // 4.1. Main fetch, step 2.7
    // > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
    // > determine request's referrer.
    if (request.referrer && request.referrer !== "no-referrer") {
      request[request_INTERNALS].referrer = determineRequestsReferrer(request);
    } else {
      request[request_INTERNALS].referrer = "no-referrer";
    }

    // 4.5. HTTP-network-or-cache fetch, step 6.9
    // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
    // >  and isomorphic encoded, to httpRequest's header list.
    if (request[request_INTERNALS].referrer instanceof URL) {
      headers.set("Referer", request.referrer);
    }

    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch");
    }

    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip, deflate, br");
    }

    let { agent } = request;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }

    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js

    const search = getSearch(parsedURL);

    // Pass the full URL directly to request(), but overwrite the following
    // options:
    const options = {
      // Overwrite search to retain trailing ? (issue #776)
      path: parsedURL.pathname + search,
      // The following options are not expressed in the URL
      method: request.method,
      headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
      insecureHTTPParser: request.insecureHTTPParser,
      agent,
    };

    return {
      /** @type {URL} */
      parsedURL,
      options,
    };
  }; // CONCATENATED MODULE: ./node_modules/node-fetch/src/errors/abort-error.js

  /**
   * AbortError interface for cancelled requests
   */
  class AbortError extends FetchBaseError {
    constructor(message, type = "aborted") {
      super(message, type);
    }
  }

  // EXTERNAL MODULE: ./node_modules/fetch-blob/from.js + 2 modules
  var from = __nccwpck_require__(2777); // CONCATENATED MODULE: ./node_modules/node-fetch/src/index.js
  /**
   * Index.js
   *
   * a request API compatible with window.fetch
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  const supportedSchemas = new Set(["data:", "http:", "https:"]);

  /**
   * Fetch function
   *
   * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
   * @param   {*} [options_] - Fetch options
   * @return  {Promise<import('./response').default>}
   */
  async function fetch(url, options_) {
    return new Promise((resolve, reject) => {
      // Build request object
      const request = new Request(url, options_);
      const { parsedURL, options } = getNodeRequestOptions(request);
      if (!supportedSchemas.has(parsedURL.protocol)) {
        throw new TypeError(
          `node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`
        );
      }

      if (parsedURL.protocol === "data:") {
        const data = dist(request.url);
        const response = new Response(data, {
          headers: { "Content-Type": data.typeFull },
        });
        resolve(response);
        return;
      }

      // Wrap http.request into fetch
      const send = (
        parsedURL.protocol === "https:"
          ? external_node_https_namespaceObject
          : external_node_http_namespaceObject
      ).request;
      const { signal } = request;
      let response = null;

      const abort = () => {
        const error = new AbortError("The operation was aborted.");
        reject(error);
        if (
          request.body &&
          request.body instanceof external_node_stream_.Readable
        ) {
          request.body.destroy(error);
        }

        if (!response || !response.body) {
          return;
        }

        response.body.emit("error", error);
      };

      if (signal && signal.aborted) {
        abort();
        return;
      }

      const abortAndFinalize = () => {
        abort();
        finalize();
      };

      // Send request
      const request_ = send(parsedURL.toString(), options);

      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }

      const finalize = () => {
        request_.abort();
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      };

      request_.on("error", (error) => {
        reject(
          new FetchError(
            `request to ${request.url} failed, reason: ${error.message}`,
            "system",
            error
          )
        );
        finalize();
      });

      fixResponseChunkedTransferBadEnding(request_, (error) => {
        if (response && response.body) {
          response.body.destroy(error);
        }
      });

      /* c8 ignore next 18 */
      if (process.version < "v14") {
        // Before Node.js 14, pipeline() does not fully support async iterators and does not always
        // properly handle when the socket close/end events are out of order.
        request_.on("socket", (s) => {
          let endedWithEventsCount;
          s.prependListener("end", () => {
            endedWithEventsCount = s._eventsCount;
          });
          s.prependListener("close", (hadError) => {
            // if end happened before close but the socket didn't emit an error, do it now
            if (
              response &&
              endedWithEventsCount < s._eventsCount &&
              !hadError
            ) {
              const error = new Error("Premature close");
              error.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", error);
            }
          });
        });
      }

      request_.on("response", (response_) => {
        request_.setTimeout(0);
        const headers = fromRawHeaders(response_.rawHeaders);

        // HTTP fetch step 5
        if (isRedirect(response_.statusCode)) {
          // HTTP fetch step 5.2
          const location = headers.get("Location");

          // HTTP fetch step 5.3
          let locationURL = null;
          try {
            locationURL =
              location === null ? null : new URL(location, request.url);
          } catch {
            // error here can only be invalid URL in Location: header
            // do not throw when options.redirect == manual
            // let the user extract the errorneous redirect URL
            if (request.redirect !== "manual") {
              reject(
                new FetchError(
                  `uri requested responds with an invalid redirect URL: ${location}`,
                  "invalid-redirect"
                )
              );
              finalize();
              return;
            }
          }

          // HTTP fetch step 5.5
          switch (request.redirect) {
            case "error":
              reject(
                new FetchError(
                  `uri requested responds with a redirect, redirect mode is set to error: ${request.url}`,
                  "no-redirect"
                )
              );
              finalize();
              return;
            case "manual":
              // Nothing to do
              break;
            case "follow": {
              // HTTP-redirect fetch step 2
              if (locationURL === null) {
                break;
              }

              // HTTP-redirect fetch step 5
              if (request.counter >= request.follow) {
                reject(
                  new FetchError(
                    `maximum redirect reached at: ${request.url}`,
                    "max-redirect"
                  )
                );
                finalize();
                return;
              }

              // HTTP-redirect fetch step 6 (counter increment)
              // Create a new Request object.
              const requestOptions = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: clone(request),
                signal: request.signal,
                size: request.size,
                referrer: request.referrer,
                referrerPolicy: request.referrerPolicy,
              };

              // when forwarding sensitive headers like "Authorization",
              // "WWW-Authenticate", and "Cookie" to untrusted targets,
              // headers will be ignored when following a redirect to a domain
              // that is not a subdomain match or exact match of the initial domain.
              // For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
              // will forward the sensitive headers, but a redirect to "bar.com" will not.
              // headers will also be ignored when following a redirect to a domain using
              // a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
              // will not forward the sensitive headers
              if (
                !isDomainOrSubdomain(request.url, locationURL) ||
                !isSameProtocol(request.url, locationURL)
              ) {
                for (const name of [
                  "authorization",
                  "www-authenticate",
                  "cookie",
                  "cookie2",
                ]) {
                  requestOptions.headers.delete(name);
                }
              }

              // HTTP-redirect fetch step 9
              if (
                response_.statusCode !== 303 &&
                request.body &&
                options_.body instanceof external_node_stream_.Readable
              ) {
                reject(
                  new FetchError(
                    "Cannot follow redirect with body being a readable stream",
                    "unsupported-redirect"
                  )
                );
                finalize();
                return;
              }

              // HTTP-redirect fetch step 11
              if (
                response_.statusCode === 303 ||
                ((response_.statusCode === 301 ||
                  response_.statusCode === 302) &&
                  request.method === "POST")
              ) {
                requestOptions.method = "GET";
                requestOptions.body = undefined;
                requestOptions.headers.delete("content-length");
              }

              // HTTP-redirect fetch step 14
              const responseReferrerPolicy =
                parseReferrerPolicyFromHeader(headers);
              if (responseReferrerPolicy) {
                requestOptions.referrerPolicy = responseReferrerPolicy;
              }

              // HTTP-redirect fetch step 15
              resolve(fetch(new Request(locationURL, requestOptions)));
              finalize();
              return;
            }

            default:
              return reject(
                new TypeError(
                  `Redirect option '${request.redirect}' is not a valid value of RequestRedirect`
                )
              );
          }
        }

        // Prepare response
        if (signal) {
          response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
        }

        let body = (0, external_node_stream_.pipeline)(
          response_,
          new external_node_stream_.PassThrough(),
          (error) => {
            if (error) {
              reject(error);
            }
          }
        );
        // see https://github.com/nodejs/node/pull/29376
        /* c8 ignore next 3 */
        if (process.version < "v12.10") {
          response_.on("aborted", abortAndFinalize);
        }

        const responseOptions = {
          url: request.url,
          status: response_.statusCode,
          statusText: response_.statusMessage,
          headers,
          size: request.size,
          counter: request.counter,
          highWaterMark: request.highWaterMark,
        };

        // HTTP-network fetch step 12.1.1.3
        const codings = headers.get("Content-Encoding");

        // HTTP-network fetch step 12.1.1.4: handle content codings

        // in following scenarios we ignore compression support
        // 1. compression support is disabled
        // 2. HEAD request
        // 3. no Content-Encoding header
        // 4. no content response (204)
        // 5. content not modified response (304)
        if (
          !request.compress ||
          request.method === "HEAD" ||
          codings === null ||
          response_.statusCode === 204 ||
          response_.statusCode === 304
        ) {
          response = new Response(body, responseOptions);
          resolve(response);
          return;
        }

        // For Node v6+
        // Be less strict when decoding compressed responses, since sometimes
        // servers send slightly invalid responses that are still accepted
        // by common browsers.
        // Always using Z_SYNC_FLUSH is what cURL does.
        const zlibOptions = {
          flush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH,
          finishFlush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH,
        };

        // For gzip
        if (codings === "gzip" || codings === "x-gzip") {
          body = (0, external_node_stream_.pipeline)(
            body,
            external_node_zlib_namespaceObject.createGunzip(zlibOptions),
            (error) => {
              if (error) {
                reject(error);
              }
            }
          );
          response = new Response(body, responseOptions);
          resolve(response);
          return;
        }

        // For deflate
        if (codings === "deflate" || codings === "x-deflate") {
          // Handle the infamous raw deflate response from old servers
          // a hack for old IIS and Apache servers
          const raw = (0, external_node_stream_.pipeline)(
            response_,
            new external_node_stream_.PassThrough(),
            (error) => {
              if (error) {
                reject(error);
              }
            }
          );
          raw.once("data", (chunk) => {
            // See http://stackoverflow.com/questions/37519828
            if ((chunk[0] & 0x0f) === 0x08) {
              body = (0, external_node_stream_.pipeline)(
                body,
                external_node_zlib_namespaceObject.createInflate(),
                (error) => {
                  if (error) {
                    reject(error);
                  }
                }
              );
            } else {
              body = (0, external_node_stream_.pipeline)(
                body,
                external_node_zlib_namespaceObject.createInflateRaw(),
                (error) => {
                  if (error) {
                    reject(error);
                  }
                }
              );
            }

            response = new Response(body, responseOptions);
            resolve(response);
          });
          raw.once("end", () => {
            // Some old IIS servers return zero-length OK deflate responses, so
            // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
            if (!response) {
              response = new Response(body, responseOptions);
              resolve(response);
            }
          });
          return;
        }

        // For br
        if (codings === "br") {
          body = (0, external_node_stream_.pipeline)(
            body,
            external_node_zlib_namespaceObject.createBrotliDecompress(),
            (error) => {
              if (error) {
                reject(error);
              }
            }
          );
          response = new Response(body, responseOptions);
          resolve(response);
          return;
        }

        // Otherwise, use response as-is
        response = new Response(body, responseOptions);
        resolve(response);
      });

      // eslint-disable-next-line promise/prefer-await-to-then
      writeToStream(request_, request).catch(reject);
    });
  }

  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    const LAST_CHUNK =
      external_node_buffer_namespaceObject.Buffer.from("0\r\n\r\n");

    let isChunkedTransfer = false;
    let properLastChunkReceived = false;
    let previousChunk;

    request.on("response", (response) => {
      const { headers } = response;
      isChunkedTransfer =
        headers["transfer-encoding"] === "chunked" &&
        !headers["content-length"];
    });

    request.on("socket", (socket) => {
      const onSocketClose = () => {
        if (isChunkedTransfer && !properLastChunkReceived) {
          const error = new Error("Premature close");
          error.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(error);
        }
      };

      const onData = (buf) => {
        properLastChunkReceived =
          external_node_buffer_namespaceObject.Buffer.compare(
            buf.slice(-5),
            LAST_CHUNK
          ) === 0;

        // Sometimes final 0-length chunk and end of message code are in separate packets
        if (!properLastChunkReceived && previousChunk) {
          properLastChunkReceived =
            external_node_buffer_namespaceObject.Buffer.compare(
              previousChunk.slice(-3),
              LAST_CHUNK.slice(0, 3)
            ) === 0 &&
            external_node_buffer_namespaceObject.Buffer.compare(
              buf.slice(-2),
              LAST_CHUNK.slice(3)
            ) === 0;
        }

        previousChunk = buf;
      };

      socket.prependListener("close", onSocketClose);
      socket.on("data", onData);

      request.on("close", () => {
        socket.removeListener("close", onSocketClose);
        socket.removeListener("data", onData);
      });
    });
  }

  // EXTERNAL MODULE: ./node_modules/fast-xml-parser/src/fxp.js
  var fxp = __nccwpck_require__(2603); // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/fetch.js
  async function fetch_fetchXml(url, validator) {
    const res = await fetchUrl(url);
    try {
      const data = await res.text();
      const asJson = new XMLParser().parse(data);
      return validator ? validator.parse(asJson) : asJson;
    } catch (err) {
      throw new Error(
        `Error parsing XML from ${url}: ${isError(err) ? err.message : "UNKNOWN"}`
      );
    }
  }
  async function fetch_fetchJson(url, validator) {
    const res = await fetchUrl(url);
    try {
      const parsed = await res.json();
      return validator ? validator.parse(parsed) : parsed;
    } catch (err) {
      throw new Error(
        `Error parsing JSON from ${url}: ${utils_isError(err) ? err.message : "UNKNOWN"}`
      );
    }
  }
  async function fetchUrl(url) {
    try {
      const res = await fetch(url);
      if (res.status >= 300) {
        throw new Error(
          `Error fetching "${url}": ${res.status} ${res.statusText}`
        );
      }
      return res;
    } catch (err) {
      throw new Error(
        `Error fetching "${url}": ${utils_isError(err) ? err.message : "UNKNOWN"}`
      );
    }
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/releases.js
  //# sourceMappingURL=fetch.js.map
  /**
   * This package is used to generate a releases object, stored
   * as a JSON file for public download. The latest version of this
   * releases object can be downloaded from this URL.
   */
  const releasesUrl =
    "https://bscotch.github.io/stitch/artifacts/gamemaker/releases-summary.json";
  /**
   * Given a URL to an already-synthesized
   * GameMaker Studio merged-releases feed,
   * download the feed and return the list of
   * releases.
   */
  async function fetchReleasesSummaryWithNotes(url = releasesUrl) {
    const releases = await fetch_fetchJson(
      url,
      lib_z.array(feeds_types_gameMakerReleaseWithNotesSchema)
    );
    return releases;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/browser.js
  // CONCATENATED MODULE: external "node:fs/promises"
  //# sourceMappingURL=releases.js.map
  /**
   * @file Browser-compatible exports
   */

  //# sourceMappingURL=browser.js.map
  const promises_namespaceObject = __WEBPACK_EXTERNAL_createRequire(
    import.meta.url
  )("node:fs/promises"); // CONCATENATED MODULE: ./node_modules/@bscotch/pathy/dist/util.js
  /**
   * If the provided value is not an array,
   * wrap it in an array. If the value is undefined
   * will return an empty array.
   */
  function util_arrayWrapped(item) {
    if (Array.isArray(item)) {
      // @ts-expect-error Help! Does work, but Typescript doesn't like it.
      return item;
    }
    // @ts-expect-error Help! Does work, but Typescript doesn't like it.
    return typeof item == "undefined" ? [] : [item];
  }
  class PathyError extends Error {
    tries;
    constructor(message, cause, asserter) {
      super(message);
      this.name = "PathyError";
      this.cause = cause;
      Error.captureStackTrace(this, asserter || this.constructor);
    }
  }
  function util_assert(claim, message, cause) {
    if (!claim) {
      throw new PathyError(message, cause, util_assert);
    }
  }
  /**
   * A decorator for async methods that ensures that calls to
   * the method are resolved in order, and that only one call
   * is active at a time.
   */
  function util_Sequential() {
    return function (target, propertyKey, descriptor) {
      const originalMethod = descriptor.value;
      let promise = Promise.resolve();
      descriptor.value = function (...args) {
        const result = promise.then(() => {
          promise = originalMethod.apply(this, args);
          return promise;
        });
        return result;
      };
      return descriptor;
    };
  }
  const util_sequential = util_Sequential(); // CONCATENATED MODULE: ./node_modules/@bscotch/pathy/dist/fsSafe.js
  //# sourceMappingURL=util.js.map
  /**
   * Read a file, returning the raw binary content. Optionally retry
   * if the file is locked.
   */
  async function readSafe(path, options) {
    const { maxRetries, retryDelayMillis } = cleanRetryOptions(options);
    let tries = 0;
    let error = null;
    while (tries <= maxRetries) {
      error = null;
      try {
        const content = await promises_namespaceObject.readFile(
          path.toString()
        );
        return content;
      } catch (err) {
        _throwIfMissing(err);
        error = new PathyError(`Failed to read file "${path.toString()}"`, err);
        tries++;
        error.tries = tries;
        await new Promise((resolve) => setTimeout(resolve, retryDelayMillis));
        continue;
      }
    }
    throw error;
  }
  async function writeSafe(path, content, options) {
    const { maxRetries, retryDelayMillis } = cleanRetryOptions(options);
    let tries = 0;
    let error = null;
    while (tries <= maxRetries) {
      error = null;
      try {
        await promises_namespaceObject.writeFile(path.toString(), content);
        return;
      } catch (err) {
        error = new PathyError(
          `Failed to write file "${path.toString()}"`,
          err
        );
        tries++;
        error.tries = tries;
        await new Promise((resolve) => setTimeout(resolve, retryDelayMillis));
        continue;
      }
    }
    throw error;
  }
  async function existsSafe(path, options) {
    try {
      await statSafe(path, options);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Try to get stats for a file. If there is an error due to that file
   * not existing, throw. Otherwise retry if requested.
   */
  async function statSafe(path, options) {
    const { maxRetries, retryDelayMillis } = cleanRetryOptions(options);
    let tries = 0;
    let error = null;
    while (tries <= maxRetries) {
      error = null;
      try {
        const stats = await promises_namespaceObject.stat(path.toString());
        return stats;
      } catch (err) {
        _throwIfMissing(err);
        error = new PathyError(`Failed to stat file "${path.toString()}"`, err);
        tries++;
        error.tries = tries;
        await new Promise((resolve) => setTimeout(resolve, retryDelayMillis));
        continue;
      }
    }
    throw error;
  }
  async function rmSafe(path, options) {
    const { maxRetries, retryDelayMillis } = cleanRetryOptions(options);
    let tries = 0;
    let error = null;
    while (tries <= maxRetries) {
      error = null;
      try {
        const stats = await promises_namespaceObject.rm(
          path.toString(),
          options
        );
        return stats;
      } catch (err) {
        if (isMissingError(err)) {
          if (options?.throwIfMissing) {
            throw err;
          }
          return;
        }
        error = new PathyError(`Failed to remove "${path.toString()}"`, err);
        tries++;
        error.tries = tries;
        await new Promise((resolve) => setTimeout(resolve, retryDelayMillis));
        continue;
      }
    }
    throw error;
  }
  function cleanRetryOptions(options) {
    let maxRetries = options?.maxRetries || 0;
    util_assert(
      typeof maxRetries === "number" && maxRetries >= 0,
      "maxRetries must be a non-negative number"
    );
    let retryDelayMillis = options?.retryDelayMillis || 20;
    util_assert(
      typeof retryDelayMillis === "number" && retryDelayMillis >= 0,
      "retryDelayMillis must be a non-negative number"
    );
    return { maxRetries, retryDelayMillis };
  }
  function isMissingError(err) {
    if (!err || typeof err !== "object") return false;
    return (
      (err instanceof Error && "code" in err && err.code === "ENOENT") ||
      ("cause" in err && isMissingError(err.cause))
    );
  }
  function isPermissionsError(err) {
    if (!err || typeof err !== "object") return false;
    return (
      (err instanceof Error && "code" in err && err.code === "EPERM") ||
      ("cause" in err && isPermissionsError(err.cause))
    );
  }
  function _throwIfMissing(err) {
    if (isMissingError(err)) {
      throw err;
    }
  }
  //# sourceMappingURL=fsSafe.js.map
  // EXTERNAL MODULE: external "fs"
  var external_fs_ = __nccwpck_require__(7147);
  // EXTERNAL MODULE: ./node_modules/@bscotch/pathy/node_modules/fs-extra/lib/index.js
  var fs_extra_lib = __nccwpck_require__(4850);
  // EXTERNAL MODULE: ./node_modules/tslib/tslib.js
  var tslib_tslib = __nccwpck_require__(4351); // CONCATENATED MODULE: ./node_modules/tslib/modules/index.js
  const {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
  } = tslib_tslib;

  /* harmony default export */ const modules =
    /* unused pure expression or super */ null && tslib;

  // EXTERNAL MODULE: external "assert"
  var external_assert_ = __nccwpck_require__(9491);
  // EXTERNAL MODULE: ./node_modules/json5/lib/index.js
  var json5_lib = __nccwpck_require__(6904);
  // EXTERNAL MODULE: external "url"
  var external_url_ = __nccwpck_require__(7310);
  // EXTERNAL MODULE: ./node_modules/yaml/dist/index.js
  var yaml_dist = __nccwpck_require__(4083); // CONCATENATED MODULE: ./node_modules/@bscotch/pathy/dist/pathy.static.js
  /**
   * A base class providing static functions for {@link Pathy}.
   * Can be used on its own if you want to make use of Pathy
   * normalization and methods while only using strings (instead
   * of Pathy instances).
   */
  class PathyStatic {
    /**
     * Normalize a path to posix-style separators and trim
     * trailing slashes.
     *
     * This provides better portability of paths across platforms,
     * and ensures that the same path always normalizes to the same
     * string value.
     */
    static normalize(path) {
      let cleanPath = typeof path === "string" ? path : path.absolute;
      cleanPath ||= ".";
      try {
        cleanPath = cleanPath.startsWith("file://")
          ? (0, external_url_.fileURLToPath)(cleanPath)
          : cleanPath;
      } catch {
        // We'll land here if we have a POSIX-style path
        // when we're on Windows.
        cleanPath = decodeURIComponent(cleanPath.replace(/^file:\/\//, ""));
      }
      cleanPath = external_path_.posix.normalize(
        cleanPath.replace(/\\+/g, "/")
      );
      // Ensure trailing slash if root, otherwise ensure
      // NO trailing slash
      if (cleanPath.match(/^[a-z]:$/i)) {
        cleanPath += "/";
      } else if (cleanPath !== "/" && !cleanPath.match(/^[a-z]:\/$/i)) {
        cleanPath = cleanPath.replace(/\/+$/, "");
      }
      const [, drive, rest] = cleanPath.match(/^([a-z]):(\/.*)$/i) || [];
      if (drive) {
        cleanPath = `${drive.toLowerCase()}:${rest}`;
      }
      return cleanPath;
    }
    /**
     * Replace the current path separators
     * withs something else. Defaults to the
     * separator of the current platform.
     */
    static replaceSeparator(path, separator = external_path_.sep) {
      return path.replace(/[\\/]+/g, separator);
    }
    static basename(path) {
      return external_path_.posix.basename(PathyStatic.normalize(path));
    }
    /**
     * Check if a path has the given extension, ignoring case
     * and ensuring the `.` is present even if not provided in
     * the args (since that's always confusing).
     */
    static hasExtension(path, ext) {
      const normalized = PathyStatic.normalize(path);
      const normalizedExt = ext.startsWith(".") ? ext : `.${ext}`;
      return normalized.toLowerCase().endsWith(normalizedExt.toLowerCase());
    }
    /**
     * Instead of parsing a file as `{name}{.ext}`,
     * also parse out the infix if present: `{name}{.infix}{.ext}`.
     */
    static parseInfix(path) {
      const basename = PathyStatic.basename(path);
      const parts = basename.match(
        /^(?<name>[^.]+)(?<infix>\.[^.]+)?(?<ext>\..*)$/
      );
      return {
        name: parts?.groups.name || basename,
        infix: parts?.groups.infix || "",
        ext: parts?.groups.ext || "",
      };
    }
    static removeInfix(path) {
      const parts = PathyStatic.parseInfix(path);
      if (!parts || !parts.infix) {
        return path.toString();
      }
      return `${parts.name}${parts.ext}`;
    }
    /**
     * Explode a path by splitting on the path separator.
     * Basically the opposite of {@link join}.
     *
     * Maintains consistent array length between relative and
     * absolute paths by having the first element be `'/'`
     * for absolute paths and `''` (nullstring) for
     * relative paths.
     *
     * @example
     * PathyStatic.explode('/a/b/c.js');
     * // ['/','a','b','c.js']
     * PathyStatic.explode('a/b/c.js');
     * // ['','a','b','c.js']
     */
    static explode(path) {
      path = PathyStatic.normalize(path);
      const segments = PathyStatic.normalize(path).split("/");
      if (segments[0] === "") {
        segments[0] = "/";
      } else {
        segments.unshift("");
      }
      return segments;
    }
    /**
     * Compare to paths, returning a number indicating their relative
     * sort order based on their parts. This is useful for semantically
     * sorting paths so that those in the same folder heirarchy are grouped
     * together, and those with similar depth are grouped near each other.
     */
    static compare(path1, path2) {
      const path1Parts = PathyStatic.explode(path1);
      const path2Parts = PathyStatic.explode(path2);
      const minParts = Math.min(path1Parts.length, path2Parts.length);
      for (let i = 0; i < minParts; i++) {
        const part1 = path1Parts[i];
        const part2 = path2Parts[i];
        if (part1 !== part2) {
          return part1.localeCompare(part2);
        }
      }
      return path1Parts.length - path2Parts.length;
    }
    /**
     * Get all parent paths eventually leading to a given
     * path.
     *
     * @example
     * // Absolute
     * PathyStatic.lineage("/a/b/c.js");
     * // [
     * //   "/",
     * //   "/a",
     * //   "/a/b",
     * //   "/a/b/c.js",
     * // ]
     *
     * // Relative
     * PathyStatic.lineage("a/b/c.js");
     * // [
     * //   "",
     * //   "a",
     * //   "a/b",
     * //   "a/b/c.js",
     * // ]
     */
    static lineage(path) {
      path = PathyStatic.normalize(path);
      const parts = PathyStatic.explode(path);
      // A relative path has an imaginary leading "./",
      // such that an absolute and relative path with the
      // same lineage length will split into a different
      // number of parts.
      const lineage = Array(parts.length);
      for (let i = 0; i < parts.length; i++) {
        lineage[i] = PathyStatic.join(...parts.slice(0, i + 1));
      }
      return lineage;
    }
    static isAbsolute(path) {
      const normalized = PathyStatic.normalize(path);
      const isAbsoluteForPosix = external_path_.posix.isAbsolute(normalized);
      const isAbsoluteForWin32 = external_path_.win32.isAbsolute(normalized);
      return isAbsoluteForPosix || isAbsoluteForWin32;
    }
    static isRelative(path) {
      return !PathyStatic.isAbsolute(path);
    }
    static ensureAbsolute(path, cwd = process.cwd()) {
      cwd = PathyStatic.normalize(cwd);
      if (!PathyStatic.isAbsolute(path)) {
        (0, external_assert_.ok)(
          PathyStatic.isAbsolute(cwd),
          `cwd must be absolute: ${cwd}`
        );
        return PathyStatic.join(cwd, path);
      }
      return PathyStatic.normalize(path);
    }
    static join(...paths) {
      const normalized = paths.map((p) =>
        typeof p === "string" ? p : p.normalized
      );
      return PathyStatic.normalize(external_path_.win32.join(...normalized));
    }
    static resolve(...paths) {
      return PathyStatic.normalize(
        external_path_.win32.resolve(...paths.map(PathyStatic.normalize))
      );
    }
    static resolveRelative(from, to) {
      return PathyStatic.normalize(
        external_path_.win32.relative(
          PathyStatic.normalize(from),
          PathyStatic.normalize(to)
        )
      );
    }
    /**
     * For two paths, represented as strings or Pathy instances,
     * returns `true` if their normalized paths are equal.
     *
     * @example
     * const p1 = new Pathy('/foo/bar');
     * Pathy.isSamePath(p1,'/foo/bar'); // true
     */
    static equals(firstPath, otherPath) {
      // If one path has a cwd and the other does
      // not, assume the same cwd for the other
      const cwds = [firstPath, otherPath]
        .map((p) => (typeof p === "string" ? undefined : p.workingDirectory))
        .filter((x) => x);
      const cwd = array_arrayIsDuplicates(cwds) && cwds[0];
      const normalized = [firstPath, otherPath].map((p) => {
        p = PathyStatic.normalize(p);
        if (cwd) {
          p = PathyStatic.resolve(cwd, p);
        }
        return p;
      });
      return normalized[0] === normalized[1];
    }
    /**
     * Given a collection of paths, determine their
     * common branch point (the directory at which they
     * stop sharing their path components).
     *
     * **NOTE:** take care to ensure that all paths are
     * relative to the same root, e.g. due to being
     * absolute or relative to the same cwd. Otherwise
     * you'll get unexpected results.
     */
    static findBranchPoint(...paths) {
      (0, external_assert_.ok)(
        paths.length > 1,
        "At least two paths are required to find a shared parent."
      );
      // Get the lineage of the first path and work towards
      // the last path, reducing the matching path
      // components as we go
      const branchpoint = PathyStatic.lineage(paths[0]);
      for (let i = 1; i < paths.length; i++) {
        const otherLineage = PathyStatic.lineage(paths[i]);
        for (
          let j = 0;
          j < branchpoint.length && j < otherLineage.length;
          j++
        ) {
          if (branchpoint[j] !== otherLineage[j]) {
            // Then the prior value is their branchpoint.
            (0, external_assert_.ok)(
              j !== 0,
              "Paths do not share a common branch point"
            );
            branchpoint.splice(j);
          }
        }
      }
      return PathyStatic.join(...branchpoint);
    }
    /**
     * Determine if one path is the parent of another.
     *
     * Returns `true` if `parent` is a parent of `child`,
     * or if both are the same path.
     */
    static isParentOf(parent, child) {
      [parent, child] = [parent, child].map(PathyStatic.normalize);
      if (parent == child) {
        return true;
      }
      if (parent.length >= child.length) {
        return false;
      }
      return child.startsWith(parent) && child[parent.length] == "/";
    }
    static async listChildrenRecursively(dir, options = {}) {
      await dir.isDirectory({ assert: true });
      const _children = [];
      const addChild = (child) => {
        _children.push(options?.transform ? options.transform(child) : child);
      };
      const ignoredDirs = options.unignoreAll
        ? []
        : options.unignore
          ? PathyStatic.defaultIgnoredDirs.filter((dir) =>
              options.unignore?.includes(dir)
            )
          : PathyStatic.defaultIgnoredDirs;
      const [includeExtension, excludeExtension] = [
        options.includeExtension,
        options.excludeExtension,
      ].map((ext) => {
        if (!ext || !ext.length) {
          return;
        }
        ext = Array.isArray(ext) ? ext : [ext];
        const exts = ext.map((ext) => (ext.startsWith(".") ? ext : `.${ext}`));
        return (p) => exts.some((e) => p.absolute.endsWith(e));
      });
      const hasReachedLimit = () =>
        options.softLimit && _children.length >= options.softLimit;
      async function innerLoop(currentPath, depth = 0) {
        if (hasReachedLimit() || depth > (options?.maxDepth ?? Infinity)) {
          return;
        }
        const children = await currentPath.listChildren();
        for (const child of children) {
          if (hasReachedLimit()) {
            return;
          }
          // May have permissions problems trying to
          // stat administrative files etc. In those
          // cases, treat those as if they were ignored.
          try {
            await child.stat(options);
          } catch (err) {
            if (options.onError !== "throw") {
              continue;
            }
            throw err;
          }
          // Handle dirs first!
          const checkDir = async () => {
            if (options?.includeDirs) {
              addChild(child);
            }
            return await innerLoop(child, depth + 1);
          };
          if (await child.isDirectory()) {
            if (ignoredDirs.includes(child.basename)) {
              continue;
            }
            if (options.filter) {
              if ((await options.filter?.(child, children)) !== false) {
                await checkDir();
              }
            } else if ("excludePatterns" in options) {
              if (!stringIsMatch(child.basename, options.excludePatterns)) {
                await checkDir();
              }
            } else {
              await checkDir();
            }
            continue;
          }
          // Then is a file
          if (options?.includeDirs === "only") {
            continue;
          }
          if (includeExtension) {
            if (!includeExtension(child)) {
              continue;
            }
          }
          if (excludeExtension) {
            if (excludeExtension(child)) {
              continue;
            }
          }
          if (options.filter) {
            if (!(await options.filter?.(child, children))) {
              continue;
            }
          }
          if (options.includePatterns) {
            if (!stringIsMatch(child.basename, options.includePatterns)) {
              continue;
            }
          }
          if (options.excludePatterns) {
            if (stringIsMatch(child.basename, options.excludePatterns)) {
              continue;
            }
          }
          addChild(child);
          if (options?.onInclude) {
            await options.onInclude(child);
          }
        }
      }
      await innerLoop(dir);
      return await Promise.all(_children);
    }
    /**
     * Starting in the `startDir`, work up the directory tree
     * looking for a file that matches `basename` in each
     * parent directory.
     */
    static async findParentPath(from, basename, options) {
      let currentPath = from;
      while (!currentPath.isRoot) {
        const possibleParent = currentPath.append(basename);
        const exists = await possibleParent.exists();
        if (exists) {
          const isMatch =
            !options?.test || (await options.test(possibleParent));
          if (isMatch) {
            return possibleParent;
          }
        }
        currentPath = currentPath.up();
      }
      return;
    }
    static findParentPathSync(from, basename, options) {
      let currentPath = from;
      while (!currentPath.isRoot) {
        const possibleParent = currentPath.append(basename);
        const exists = possibleParent.existsSync();
        if (exists) {
          const isMatch = !options?.test || options.test(possibleParent);
          if (isMatch) {
            return possibleParent;
          }
        }
        currentPath = currentPath.up();
      }
      return;
    }
    /**
     * For file extensions that indicate identical or similar
     * content serialization, get a normalized extension. This
     * is useful for simplifying parser/serializer lookups.
     *
     * Currently only supports JSON and YAML extensions.
     */
    static normalizedExtension(filepath) {
      // Attempt to infer the parser to use
      const extensionMatcher = /\.((?<yaml>ya?ml)|(?<json>json[c5]?))$/;
      const extensionMatch =
        PathyStatic.basename(filepath).match(extensionMatcher);
      if (!extensionMatch) {
        return;
      }
      const fileType = extensionMatch.groups;
      return Object.entries(fileType).find(([, value]) => value)?.[0];
    }
    static async stat(filepath, options) {
      return await statSafe(filepath, options);
    }
    static async exists(filepath, options) {
      try {
        await PathyStatic.stat(filepath, options);
        return true;
      } catch {
        return false;
      }
    }
    /**
     * Write data to file, using the extension to determine
     * the serialization method.
     *
     * If the incoming data is a string, it is already assumed
     * to be serialized when writing to JSON or YAML.
     */
    static async write(filepath, data, options) {
      data = options?.schema ? options.schema.parse(data) : data;
      filepath = PathyStatic.ensureAbsolute(filepath);
      const extension = PathyStatic.normalizedExtension(filepath);
      const onClobber = options?.onClobber || "overwrite";
      if (onClobber !== "overwrite" && (await PathyStatic.exists(filepath))) {
        (0, external_assert_.ok)(onClobber !== "error", "File already exists");
        return;
      }
      await fs_extra_lib.ensureDir(external_path_.dirname(filepath));
      let serialized;
      if (typeof options?.serialize == "function") {
        serialized = await options.serialize(data);
      } else if (options?.serialize === false) {
        serialized = data;
      } else if (typeof data == "string" || Buffer.isBuffer(data)) {
        serialized = data;
      } else if (extension == "json") {
        serialized = JSON.stringify(data, null, 2);
      } else if (extension == "yaml") {
        serialized = yaml_dist.stringify(data);
      } else {
        // We work with a lot of JSON files that don't
        // end with a .json extension, and anyway JSON
        // is the most natural way to write JavaScript
        // data structures.
        serialized = JSON.stringify(data, null, 2);
      }
      (0, external_assert_.ok)(
        typeof serialized == "string" || Buffer.isBuffer(serialized),
        "Unable to serialize data as a string or buffer for writing."
      );
      (0, external_assert_.ok)(
        serialized.length,
        `Data serialized to nullish value for file ${filepath}. Data was of type ${typeof data}.`
      );
      if (
        options?.trailingNewline &&
        typeof serialized === "string" &&
        serialized.at(-1) !== "\n"
      ) {
        serialized += "\n";
      }
      await writeSafe(filepath, serialized);
    }
    /**
     * Read the file at a given path, automatically parsing
     * it if the extension is supported (parsing can be customized).
     */
    static async read(filepath, options) {
      const doesExist = await PathyStatic.exists(filepath);
      const hasFallback = options && "fallback" in options;
      const clean = (fileContent) =>
        options?.schema ? options.schema.parse(fileContent) : fileContent;
      (0, external_assert_.ok)(
        doesExist || hasFallback,
        `File does not exist: ${filepath}`
      );
      const fileInfo = doesExist
        ? await PathyStatic.stat(filepath, options)
        : undefined;
      const isDirectory = doesExist && fileInfo.isDirectory();
      (0, external_assert_.ok)(
        !isDirectory,
        `Expected file, found directory: ${filepath}`
      );
      if (!doesExist) {
        (0, external_assert_.ok)(hasFallback, `No file found at: ${filepath}`);
        return clean(options.fallback);
      }
      const doNotParse = options?.parse === false;
      const customParser =
        typeof options?.parse == "function" ? options.parse : undefined;
      // Handle the binary case
      const binary = await readSafe(filepath, options);
      if (options?.encoding === false) {
        if (customParser) {
          return clean(await customParser(binary));
        }
        return clean(binary);
      }
      // Handle the encoded text case
      const encoding = options?.encoding || "utf8";
      const decoded = binary.toString(encoding);
      if (customParser) {
        return clean(await customParser(decoded));
      } else if (doNotParse) {
        return clean(decoded);
      }
      // Attempt to infer the parser to use
      const fileType = PathyStatic.normalizedExtension(filepath);
      if (!fileType) {
        return clean(decoded);
      }
      try {
        if (fileType == "yaml") {
          return clean(yaml_dist.parse(decoded));
        } else if (fileType == "json") {
          return clean(json5_lib.parse(decoded));
        }
      } catch (err) {
        console.error(err);
        throw new Error(`Unable to parse file: ${filepath}`, { cause: err });
      }
      throw new Error(`Impossible outcome: should have matched filetype.`);
    }
    static get defaultIgnoredDirs() {
      return [
        "node_modules",
        ".git",
        ".hg",
        ".svn",
        ".idea",
        ".vscode",
        ".vscode-test",
      ];
    }
  }
  __decorate(
    [
      Sequential({
        subqueueBy: (p) => PathyStatic.normalize(p),
      }),
      __metadata("design:type", Function),
      __metadata("design:paramtypes", [Object, Object, Object]),
      __metadata("design:returntype", Promise),
    ],
    PathyStatic,
    "write",
    null
  );
  __decorate(
    [
      Sequential({
        shareQueueWith: "write",
        subqueueBy: (p) => PathyStatic.normalize(p),
      }),
      __metadata("design:type", Function),
      __metadata("design:paramtypes", [Object, Object]),
      __metadata("design:returntype", Promise),
    ],
    PathyStatic,
    "read",
    null
  ); // CONCATENATED MODULE: ./node_modules/@bscotch/pathy/dist/pathy.js
  //# sourceMappingURL=pathy.static.js.map
  /**
   * An **immutable** utility class for reducing the cognitive load of
   * working with file paths.
   *
   * Any operation that would return a new path will will return a new
   * {@link Pathy} instance.
   */
  class pathy_Pathy extends PathyStatic {
    /**
     * The normalized path, with whatever
     * absolute/relative status the original input
     * path had.
     *
     * Use {@link absolute} or
     * {@link relative} for
     * guaranteed-absolute/relative variants.
     */
    normalized;
    /**
     * The normalized absolute path, as determined
     * by the cwd (provided or inferred) at instantiation
     * (or by the path itself if it was already absolute.)
     */
    absolute;
    /**
     * The normalized relative path, as determined
     * by the cwd (provided or inferred) at instantiation.
     */
    relative;
    /**
     * The working directory from when the instance
     * was created.
     */
    workingDirectory;
    /**
     * A zod schema or other compatible validator, which will be used
     * during file read/write if provided.
     */
    validator;
    constructor(path = process.cwd(), cwdOrOptions) {
      super();
      const cwd = pathy_Pathy.isStringOrPathy(cwdOrOptions)
        ? cwdOrOptions
        : cwdOrOptions?.cwd ||
          (pathy_Pathy.isPathy(cwdOrOptions) &&
            cwdOrOptions.workingDirectory) ||
          (pathy_Pathy.isPathy(path) && path.workingDirectory) ||
          process.cwd();
      this.workingDirectory = pathy_Pathy.normalize(cwd);
      this.normalized = pathy_Pathy.normalize(
        Array.isArray(path) ? pathy_Pathy.join(...path) : path
      );
      this.absolute = pathy_Pathy.resolve(
        this.workingDirectory,
        this.normalized
      );
      this.relative = pathy_Pathy.resolveRelative(
        this.workingDirectory,
        this.absolute
      );
      this.validator =
        typeof cwdOrOptions === "object" ? cwdOrOptions.validator : undefined;
    }
    get directory() {
      return external_path_.win32.dirname(this.absolute);
    }
    get name() {
      return external_path_.win32.parse(this.normalized).name;
    }
    get basename() {
      return external_path_.win32.basename(this.normalized);
    }
    get extname() {
      return external_path_.extname(this.normalized);
    }
    withValidator(validator) {
      return new pathy_Pathy(this, { cwd: this.workingDirectory, validator });
    }
    /**
     * Check if a path has the given extension, ignoring case
     * and ensuring the `.` is present even if not provided in
     * the args (since that's always confusing).
     */
    hasExtension(ext) {
      return util_arrayWrapped(ext).some((e) =>
        PathyStatic.hasExtension(this, e)
      );
    }
    parseInfix() {
      return pathy_Pathy.parseInfix(this);
    }
    /**
     * Whether this path is the root path.
     * This returns `true` when there is no parent directory.
     *
     * @example
     * new Pathy('/').isRoot; // true
     * new Pathy('c:/').isRoot; // true
     * new Pathy('c:/hello').isRoot; // false
     * new Pathy('c:\\').isRoot; // true
     * new Pathy('').isRoot; // false
     * new Pathy('/a/b').isRoot; // false
     * new Pathy('a').isRoot; // false
     */
    get isRoot() {
      return this.absolute === pathy_Pathy.normalize(this.directory);
    }
    /**
     * Get a new {@link Pathy} instance that contains the relative
     * bath from the current location to another.
     */
    relativeTo(to = process.cwd()) {
      return pathy_Pathy.resolveRelative(this.absolute, to.toString());
    }
    relativeFrom(from = process.cwd()) {
      return pathy_Pathy.resolveRelative(from.toString(), this.absolute);
    }
    /**
     * Change the path by moving up the tree some number of
     * levels.
     *
     * @example
     * const path = new Path('/a/b/c');
     * path.up(); // `/a/b`
     */
    up(levels = 1) {
      return this.resolveTo(...Array(levels).fill(".."));
    }
    join(...paths) {
      return new pathy_Pathy(
        pathy_Pathy.join(this, ...paths),
        this.workingDirectory
      );
    }
    /**
     * Change to another path by jumping through a number
     * of relative or absolute paths, using `path.resolve` logic.
     *
     * @example
     * const path = new Path('/a/b');
     * path.resolveTo('c'); // `/a/b/c`
     * path.resolveTo('..'); // `/a/b`
     * path.resolveTo('c/d','e'); // `/a/b/c/d/e`
     * path.resolveTo('irrelevant','/new-root','../z'); // `/z`
     */
    resolveTo(...paths) {
      return new pathy_Pathy(
        pathy_Pathy.resolve(this.absolute, ...paths),
        this.workingDirectory
      );
    }
    async isDirectory(options) {
      const metadata = await this.stat();
      const isDirectory = metadata.isDirectory();
      util_assert(
        !options?.assert || isDirectory,
        `${this.absolute} is not a directory`
      );
      return isDirectory;
    }
    isDirectorySync() {
      const metadata = this.statSync();
      return metadata.isDirectory();
    }
    async isFile() {
      const metadata = await this.stat();
      return metadata.isFile();
    }
    isFileSync() {
      const metadata = this.statSync();
      return metadata.isFile();
    }
    isParentOf(otherPath) {
      return pathy_Pathy.isParentOf(this, otherPath);
    }
    isChildOf(otherPath) {
      return pathy_Pathy.isParentOf(otherPath, this);
    }
    /**
     * Read the file at the current path automatically parsing
     * it if the extension is supported (see {@link Pathy.read}).
     */
    async read(options) {
      return await pathy_Pathy.read(this, {
        schema: this.validator,
        ...options,
      });
    }
    /**
     * Write to file at the current path, automatically serializing
     * if the extension is supported (see {@link Pathy.write}).
     */
    async write(data, options) {
      return await pathy_Pathy.write(this, data, {
        schema: this.validator,
        ...options,
      });
    }
    /**
     * Whether or not a file/directory exists at this path.
     */
    async exists(options) {
      try {
        await this.stat(options);
        return true;
      } catch {
        if (options?.assert) {
          throw new Error(`Path ${this.absolute} does not exist`);
        }
        return false;
      }
    }
    existsSync(options) {
      try {
        this.statSync();
        return true;
      } catch {
        if (options?.assert) {
          throw new Error(`Path ${this.absolute} does not exist`);
        }
        return false;
      }
    }
    async stat(options) {
      return await pathy_Pathy.stat(this.absolute, options);
    }
    statSync() {
      return external_fs_.statSync(this.absolute);
    }
    /**
     * Check if this path leads to an empty directory.
     *
     * (If the path does not exist, will throw an error.)
     */
    async isEmptyDirectory(options = {}) {
      const exists = await this.exists({ assert: !options.allowNotFound });
      if (!exists) {
        return true;
      }
      await this.isDirectory({ assert: true });
      let isEmpty = false;
      if (options.strict) {
        // Must be *literally nothing* in the directory
        isEmpty = (await fs_extra_lib.readdir(this.absolute)).length === 0;
      } else {
        // May contain other directories, but *NO FILES*.
        const foundFiles = await this.listChildrenRecursively({
          unignoreAll: true,
          softLimit: 1,
        });
        isEmpty = foundFiles.length === 0;
      }
      util_assert(
        !options?.assert || isEmpty,
        `${this.absolute} is not an empty directory`
      );
      return isEmpty;
    }
    /**
     * Treat the path as a directory, and ensure
     * that it exists (creating any needed parent
     * directories as along the way).
     */
    async ensureDirectory() {
      await fs_extra_lib.mkdir(this.absolute, { recursive: true });
    }
    /**
     * @alias {@link Pathy.ensureDirectory}
     */
    ensureDir = this.ensureDirectory;
    /**
     * @alias {@link Pathy.ensureDirectory}
     */
    mkdir = this.ensureDirectory;
    /**
     * List all immediate children of this path.
     *
     * (The path must be folder, and the children
     * can be files or folders.)
     */
    async listChildren() {
      util_assert(
        await this.isDirectory(),
        `${this.normalized} is not a directory`
      );
      return (await fs_extra_lib.readdir(this.absolute)).map((entry) => {
        const path = this.join(entry);
        return new pathy_Pathy(path, this.workingDirectory);
      });
    }
    /**
     * @alias {@link Pathy.listChildren}
     */
    ls = this.listChildren;
    listChildrenSync() {
      util_assert(
        this.isDirectorySync(),
        `${this.normalized} is not a directory`
      );
      return fs_extra_lib.readdirSync(this.absolute).map((entry) => {
        const path = this.join(entry);
        return new pathy_Pathy(path, this.workingDirectory);
      });
    }
    /**
     * Copy this file/directory to another location.
     */
    async copy(destination, options) {
      destination = pathy_Pathy.asInstance(destination);
      const destinationParent = destination.up();
      await destinationParent.ensureDirectory();
      await fs_extra_lib.copy(this.absolute, destination.absolute, options);
    }
    /**
     * @alias {@link Pathy.copy}
     */
    cp = this.copy;
    /**
     * Shorthand for performing a copy to destination, followed by deletion
     */
    async move(destination, options) {
      await this.copy(destination, options);
      await this.delete(options);
    }
    /**
     * @alias {@link Pathy.move}
     */
    mv = this.move;
    /**
     * Delete this path.
     */
    async delete(options) {
      await rmSafe(this, options);
    }
    /**
     * @alias {@link Pathy.delete}
     */
    rm = this.delete;
    async listSiblings() {
      const dir = this.up();
      return await dir.listChildren();
    }
    async findChild(basename, options) {
      let child;
      if (options?.recursive) {
        const children = await this.listChildrenRecursively({
          includePatterns: [basename],
          softLimit: 1,
        });
        child = children[0];
      } else {
        child = (await this.listChildren()).find((c) =>
          typeof basename === "string"
            ? c.basename === basename
            : basename.test(c.basename)
        );
      }
      util_assert(
        !options?.assert || child,
        `${this.absolute} does not have a child named ${basename}`
      );
      return child;
    }
    async listChildrenRecursively(options = {}) {
      return await pathy_Pathy.listChildrenRecursively(this, options);
    }
    async findInParents(basename, options) {
      return await pathy_Pathy.findParentPath(this, basename, options);
    }
    findInParentsSync(basename, options) {
      return pathy_Pathy.findParentPathSync(this, basename, options);
    }
    /**
     * Create a new Pathy instance that has the same path
     * as this one, guaranteed to be absolute.
     */
    toAbsolute(cwd = process.cwd()) {
      return new pathy_Pathy(pathy_Pathy.ensureAbsolute(this, cwd));
    }
    /**
     * Add additional path segments (uses `path.join`).
     */
    append(...paths) {
      return new pathy_Pathy(pathy_Pathy.join(this, ...paths));
    }
    changeExtension(from, to) {
      let newPath = this.absolute;
      const ensureDot = (ext) => (ext[0] === "." ? ext : `.${ext}`);
      const newExtension = ensureDot(to || from);
      if (to === undefined) {
        util_assert(
          typeof from === "string",
          "Function signature is wrong. If only one argument is provided it must be a string."
        );
        // Just replace the last .ext, whatever it is
        newPath = newPath.replace(/\.[^/.]+$/, newExtension);
      } else {
        const fromPattern = util_arrayWrapped(from).map(ensureDot).join("|");
        newPath = newPath.replace(
          new RegExp(`(${fromPattern})$`),
          newExtension
        );
      }
      return new pathy_Pathy(newPath, this.workingDirectory);
    }
    /**
     * Check if this path matches another path after both
     * are normalized.
     */
    equals(other) {
      return pathy_Pathy.equals(this, other.toString());
    }
    /**
     * Add a file to this path, assuming it's a directory
     * (else will throw an error).
     */
    async addFileToDirectory(fileName, content, options) {
      await this.isDirectory({ assert: true });
      const filePath = this.append(fileName);
      await filePath.write(content, options);
      return filePath;
    }
    /**
     * Get the normalized path as an array of
     * path segments.
     */
    explode() {
      return PathyStatic.explode(this);
    }
    /**
     * Get all parent paths eventually leading to a given
     * path.
     */
    lineage() {
      return PathyStatic.lineage(this);
    }
    /**
     * Serialize this Pathy instance as a plain string.
     *
     * Uses the absolute path, since that's generally
     * the safest choice.
     */
    toString(options) {
      const path = options?.relative ? this.relative : this.absolute;
      return options?.format == "win32" ? path.replace(/\//g, "\\") : path;
    }
    /**
     * This method causes {@link Pathy} instances to automatically
     * JSON-serialize as their normalized string values.
     *
     * If the path is absolute, its cwd-relative path is returned
     * since that's usually what is desired in a JSON context.
     *
     * @example
     * const pathContainer = {
     *   title: "My path",
     *   path: new Path('/foo/bar')
     * }
     * JSON.stringify(pathContainer); // {"title":"My path","path":"/foo/bar"}
     */
    toJSON() {
      return this.toString();
    }
    /**
     * The current working directory as a Pathy instance.
     */
    static cwd() {
      return new pathy_Pathy(process.cwd());
    }
    /**
     * Convenience function for ensuring that a path is a
     * Pathy instance, useful for cases where a function
     * allows either a string or Pathy instance to be passed.
     *
     * If `stringOrInstance` is a Pathy instance, returns
     * that same instance. If it is undefined,
     * `process.cwd()` is used.
     *
     * See {@link PathyStatic.asString} for the opposite case.
     */
    static asInstance(stringOrInstance) {
      if (stringOrInstance instanceof pathy_Pathy) {
        return stringOrInstance;
      }
      return new pathy_Pathy(stringOrInstance || process.cwd());
    }
    static isString(thing) {
      return typeof thing === "string";
    }
    static isPathy(thing) {
      return thing instanceof pathy_Pathy;
    }
    static isStringOrPathy(thing) {
      return pathy_Pathy.isString(thing) || pathy_Pathy.isPathy(thing);
    }
  } // CONCATENATED MODULE: ./node_modules/@bscotch/pathy/dist/index.js
  //# sourceMappingURL=pathy.js.map
  function pathy(path, cwdOrOptions) {
    return new pathy_Pathy(path, cwdOrOptions);
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/constants.js
  //# sourceMappingURL=index.js.map
  const defaultCacheDir = pathy(
    external_os_.tmpdir(),
    "@bscotch/gamemaker-releases"
  );
  const constants_defaultNotesCachePath = defaultCacheDir.join(
    "release-notes-cache.json"
  ); // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/feeds.lib.js
  //# sourceMappingURL=constants.js.map
  /**
   * Get the runtime with the closest release date to the given IDE
   */
  function feeds_lib_findPairedRuntime(runtimeFeed, ide) {
    const location = runtimeFeed.reduce(
      (acc, cur, idx) => {
        if (!cur.publishedAt || cur.channel !== ide.channel) {
          return acc;
        }
        const diff = Math.abs(
          new Date(cur.publishedAt).getTime() -
            new Date(ide.publishedAt).getTime()
        );
        if (diff < acc.minDiff) {
          acc.minDiff = diff;
          acc.minIndex = idx;
        }
        return acc;
      },
      {
        minDiff: Infinity,
        minIndex: -1,
      }
    );
    return location.minIndex === -1
      ? undefined
      : runtimeFeed[location.minIndex];
  }
  async function feeds_lib_downloadRssFeed(url) {
    const feed = await fetchXml(url, rssFeedSchema);
    return feed.rss.channel.item;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/notes.js
  //# sourceMappingURL=feeds.lib.js.map
  async function notes_listReleaseNotes(
    releases,
    cache = defaultNotesCachePath
  ) {
    const cachePath = Pathy.asInstance(cache).withValidator(
      rawReleaseNotesCacheSchema
    );
    assert(
      cachePath.hasExtension("json"),
      `Cache path must have a .json extension`
    );
    const cacheData = await cachePath.read({ fallback: {} });
    for (const release of releases) {
      for (const type of ["ide", "runtime"]) {
        let url = release[type].notesUrl;
        // URL can be malformed
        url = url.replace(/^(.+\.cloudfront\.net)(release.*)$/, "$1/$2");
        if (cacheData[url]) {
          if (!cacheData[url].type) {
            cacheData[url].type = type;
            await cachePath.write(cacheData);
          }
          continue;
        }
        console.info("Notes cache miss:", url);
        const note = await fetchJson(url, rawReleaseNoteSchema);
        cacheData[url] = {
          type,
          ...rawReleaseNoteSchema.parse(note),
        };
        await cachePath.write(cacheData);
      }
    }
    return cleanNotes(cacheData);
  }
  function cleanNotes(cachedNotes) {
    const rawNotes = Object.entries(cachedNotes).map(([url, note]) => ({
      ...note,
      url,
    }));
    // As of writing, all versions from downloaded notes are unique.
    // We'll assume that moving forward, but also throw if that assumption is broken.
    const versions = rawNotes.map((note) => `${note.version} (${note.type})`);
    assert(
      countNonUnique(versions) === 0,
      `Duplicate versions found in release notes`
    );
    // Convert each note into a well-defined structured document.
    const cleanedNotes = rawNotes.map(cleanNote);
    // Try to normalize "since" versions, since they're often only the *last* digits
    for (const note of cleanedNotes) {
      if (!note.changes.since?.match(/^\d+$/)) {
        continue;
      }
      const possibleMatches = versions.filter((v) =>
        v.endsWith(`.${note.changes.since}`)
      );
      if (possibleMatches.length === 1) {
        note.changes.since = possibleMatches[0];
        continue;
      }
      if (!possibleMatches.length) {
        // Then just replace the current version with those digits
        note.changes.since = note.version.replace(/\d+$/, note.changes.since);
        continue;
      }
      // Score matches by digits in common
      const versionParts = note.version.split(".");
      note.changes.since = findMax(possibleMatches, (possibleMatch) => {
        const matchParts = possibleMatch.split(".");
        let score = 0;
        for (let j = 0; j < matchParts.length; j++) {
          score += matchParts[j] === versionParts[j] ? 1 : 0;
        }
        return score;
      });
    }
    // Re-organize into a map for indexing by notes-URL, so that these can be merged
    // into the release feed data.
    const notesByUrl = cleanedNotes.reduce((acc, note) => {
      acc[note.url] = note;
      return acc;
    }, {});
    return notesByUrl;
  }
  function cleanNote(note) {
    assert(note.type, "Note type must be set");
    const { body, title } = parseHeader(note.release_notes.join(""));
    const groups = parseBody(body);
    const sinceVersion = relativeToVersion(title);
    // Normalize the HTML
    return {
      version: note.version,
      url: note.url,
      title,
      type: note.type,
      changes: {
        since: sinceVersion,
        groups,
      },
    };
  }
  function relativeToVersion(title) {
    if (!title) {
      return null;
    }
    const sinceMatch = title.match(/([0-9.]+)/i);
    return sinceMatch?.[1] || null;
  }
  function parseBody(html) {
    // Split on h3 elements, and then pull out the lists within each
    const parts = html.split(/<h3>\s*(.+?)\s*<\/h3>\s*<ul>\s*(.+?)\s*<\/ul>/gs);
    const changes = [];
    for (let groupIdx = 0; groupIdx < parts.length - 2; groupIdx += 3) {
      const [title, list] = [parts[groupIdx + 1], parts[groupIdx + 2]];
      changes.push({ title, changes: parseList(list) });
    }
    return changes;
  }
  function parseList(htmlList) {
    const parts = htmlList.split(/<li>\s*(.+?)\s*<\/li>/gs);
    const changes = [];
    for (let groupIdx = 0; groupIdx < parts.length - 1; groupIdx += 2) {
      const change = parts[groupIdx + 1];
      changes.push(change);
    }
    return changes;
  }
  function parseHeader(html) {
    // Remove changelogs from other versions (if there are additional h2 headings, remove
    // those and all below them)
    html = html.trim();
    // If there is an h2 with the word "since" in it (otherwise the first h2), treat that
    // one as the one describing this version and remove everything above and all headers
    // below it.
    const h2s = html.match(/<h2>\s*(.+?)\s*<\/h2>/gs);
    if (!h2s?.length) {
      return { title: null, body: html };
    }
    const thisVersionH2 = h2s.find((h2) => h2.match(/\bsince\b/i)) || h2s[0];
    let [, after] = html.split(thisVersionH2);
    const firstH2Index = after.indexOf("<h2>");
    if (firstH2Index > 0) {
      after = after.slice(0, firstH2Index);
    }
    assert(!after.includes("<h2>"), `Somehow still has an h2 after parsing`);
    const [, title] = thisVersionH2.match(/^<h2>\s*(?<title>.+?)\s*<\/h2>/ms);
    return { title, body: after };
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/feeds.js
  //# sourceMappingURL=notes.js.map
  async function computeReleasesSummaryWithNotes(
    releases,
    cache = defaultNotesCachePath
  ) {
    releases ||= await computeReleasesSummary();
    const notes = await listReleaseNotes(releases, cache);
    const withNotes = [];
    const emptyChanges = {
      changes: {
        since: null,
        groups: [],
      },
    };
    for (const release of releases) {
      const ideNotes = notes[release.ide.notesUrl] || emptyChanges;
      const runtimeNotes = notes[release.runtime.notesUrl] || emptyChanges;
      const ide = { ...release.ide, notes: ideNotes.changes };
      const runtime = { ...release.runtime, notes: runtimeNotes.changes };
      withNotes.push({
        channel: release.channel,
        summary: release.summary,
        publishedAt: release.publishedAt,
        ide,
        runtime,
      });
    }
    withNotes.sort(
      (a, b) =>
        new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
    );
    return z.array(gameMakerReleaseWithNotesSchema).parse(withNotes);
  }
  async function computeReleasesSummary() {
    const ideArtifacts = await listArtifacts("ide");
    const runtimeArtifacts = await listArtifacts("runtime");
    const releases = [];
    for (let i = 0; i < ideArtifacts.length; i++) {
      const ide = ideArtifacts[i];
      if (!ide.publishedAt) {
        continue;
      }
      const runtime = findPairedRuntime(runtimeArtifacts, ide);
      if (!runtime) {
        continue;
      }
      releases.push({
        channel: ide.channel,
        summary: ide.summary,
        publishedAt: ide.publishedAt,
        ide,
        runtime,
      });
    }
    releases.sort(
      (a, b) =>
        new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
    );
    return z.array(gameMakerReleaseSchema).parse(releases);
  }
  async function listArtifacts(type) {
    const entries = [];
    const urls = type === "ide" ? ideFeedUrls() : runtimeFeedUrls();
    const feeds = await Promise.all(
      channels.map((channel) => downloadRssFeed(urls[channel]))
    );
    for (let i = 0; i < channels.length; i++) {
      const channel = channels[i];
      const feed = feeds[i];
      for (const entry of feed) {
        entries.push(
          gameMakerArtifactSchema.parse({
            type,
            channel,
            publishedAt: entry.pubDate,
            version: entry.title.match(/^Version (.*)/)[1],
            link: entry.link,
            feedUrl: urls[channel],
            summary: entry.description,
            notesUrl: entry.comments,
          })
        );
      }
    }
    entries.sort(
      (a, b) =>
        new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
    );
    return entries;
  } // CONCATENATED MODULE: ./node_modules/@bscotch/gamemaker-releases/dist/index.js
  // CONCATENATED MODULE: ./src/lib/igor-setup.ts
  //# sourceMappingURL=feeds.js.map
  //# sourceMappingURL=index.js.map
  class IgorSetup {
    constructor(
      accessKey,
      targetRuntime,
      localSettingsFile,
      devicesSettingsFile
    ) {
      this.accessKey = accessKey;
      this.targetRuntime = targetRuntime;
      this.localSettingsFile = localSettingsFile;
      this.devicesSettingsFile = devicesSettingsFile;
      this.igorExecutable = "";
      this.userName = "tempUser";
      this.bootstrapperDir = __nccwpck_require__.ab + "bootstrapper";
      this.runtimeDir = __nccwpck_require__.ab + "runtimes";
      this.workingDir = __nccwpck_require__.ab + "gm-sandbox";
      this.userDir = "";
      this.targetRuntimeDir = "";
      this.targetModules = [];
      lib_default().ensureDirSync(this.cacheDir);
      lib_default().ensureDirSync(this.tempDir);
      lib_default().ensureDirSync(this.workingDir);
      this.userDir = external_path_default().join(
        this.workingDir,
        "gm-user",
        this.userName
      );
      lib_default().ensureDirSync(this.userDir);
      this._populateUserDir();
    }
    get workingDirDevices() {
      return external_path_default().join(this.userDir, "devices.json");
    }
    get workingDirLocalSettings() {
      return external_path_default().join(this.userDir, "local_settings.json");
    }
    get cacheDir() {
      return external_path_default().join(this.workingDir, "gm-cache");
    }
    get tempDir() {
      return external_path_default().join(this.workingDir, "gm-temp");
    }
    static async getRuntimeBasedOnYyp(yypPath) {
      if (!lib_default().existsSync(yypPath)) {
        throw new Error(`YYP file does not exist: ${yypPath}`);
      }
      const yypContent = lib_default().readFileSync(yypPath).toString();
      const regex = /"IDEVersion":"(\d+\.\d+\.\d+\.\d+)"/;
      const match = yypContent.match(regex);
      let ideVersion;
      if (match) {
        ideVersion = match[1];
      } else {
        throw new Error("Could not find IDEVersion in the yyp file.");
      }
      const releases = await fetchReleasesSummaryWithNotes();
      const release = releases.find((r) => r.ide.version == ideVersion);
      const matchingRuntimeVersion =
        release === null || release === void 0
          ? void 0
          : release.runtime.version;
      return matchingRuntimeVersion;
    }
    async ensureIgorBootStrapperBasedOnOs() {
      let igorExecutable = "Igor";
      let igorPlatform;
      switch ((0, external_os_.platform)()) {
        case "win32":
          igorPlatform = "win";
          igorExecutable += ".exe";
          break;
        case "darwin":
          igorPlatform = "osx";
          break;
        case "linux":
          igorPlatform = "linux";
          break;
        default:
          throw new Error("Unsupported platform!");
      }
      let arch;
      switch (process.arch) {
        case "x64":
          arch = "x64";
          break;
        case "arm64":
          arch = "arm64";
          if (igorPlatform === "osx") {
            igorPlatform = "osx.11.0";
          }
          break;
        default:
          throw new Error("Unsupported architecture!");
      }
      const igorExecutableFullPath = external_path_default().resolve(
        external_path_default().join(this.bootstrapperDir, igorExecutable)
      );
      if (!lib_default().existsSync(igorExecutableFullPath)) {
        const bootstrapperDir = this.bootstrapperDir;
        const igorUrl = `https://gms.yoyogames.com/igor_${igorPlatform}-${arch}.zip`;
        const extraction = new Promise((resolve, reject) => {
          const tempDir = lib_default().mkdtempSync(
            external_path_default().join((0, external_os_.tmpdir)(), "gms2-")
          );
          const igorZipPath = external_path_default().join(tempDir, "igor.zip");
          const file = lib_default().createWriteStream(igorZipPath);
          external_https_default().get(igorUrl, function (response) {
            if (response.statusCode === 200) {
              response.pipe(file);
              file.on("finish", function () {
                const zip = new (adm_zip_default())(igorZipPath);
                zip.extractAllTo(bootstrapperDir, true);
                resolve(igorExecutableFullPath);
              });
            } else {
              reject(
                `GameMaker license server responded with ${response.statusCode}`
              );
            }
          });
        });
        await extraction;
      } else {
        core.info(
          `Igor bootstrapper already exists at: ${igorExecutableFullPath}`
        );
      }
      this.igorExecutable = igorExecutableFullPath;
      lib_default().chmodSync(this.igorExecutable, 0o777);
      // Get the license file
      const licenseFileDir = external_path_default().join(
        this.userDir,
        "licence.plist"
      );
      if (!lib_default().existsSync(licenseFileDir)) {
        const fetchLicenseArgs = [
          "runtime",
          "FetchLicense",
          `-ak=${this.accessKey}`,
          `-of=${licenseFileDir}`,
        ];
        // console.log(this.igorExecutable);
        // console.log(fetchLicenseArgs.join("\n"));
        // console.log([this.igorExecutable, fetchLicenseArgs.join(" ")].join(" "));
        external_child_process_default().spawnSync(
          this.igorExecutable,
          fetchLicenseArgs,
          {
            stdio: "inherit",
            cwd: external_path_default().dirname(this.igorExecutable),
          }
        );
      } else {
        core.info(`License file already exists at: ${licenseFileDir}`);
      }
      const licenseFile = lib_default().readFileSync(licenseFileDir, "utf-8");
      const licenseFileContent = plist_default().parse(licenseFile);
      const userName = licenseFileContent.name.split("@")[0];
      const id = licenseFileContent.id;
      this.userName = `${userName}_${id}`;
      const newUserDir = external_path_default().join(
        this.workingDir,
        "gm-user",
        this.userName
      );
      lib_default().ensureDirSync(newUserDir);
      lib_default().copySync(this.userDir, newUserDir);
      lib_default().removeSync(this.userDir);
      this.userDir = newUserDir;
    }
    installModules(modules) {
      if (!modules || modules.length === 0) {
        switch ((0, external_os_.platform)()) {
          case "win32":
            modules = ["windows"];
            break;
          case "darwin":
            modules = ["ios"];
            break;
          case "linux":
            modules = ["android"];
            break;
        }
      }
      if (this.modulesAreInstalled(modules)) {
        core.info("Modules already installed!");
      } else {
        if (!this.modulesAreInstalled(modules)) {
          const osModule = this._getRequiredOsModule();
          let targetAndOsModules = modules;
          if (osModule) {
            targetAndOsModules = modules.concat(osModule);
          }
          const args = [];
          args.push(
            `/rp=${this.runtimeDir}`,
            `/ru=${this._inferFeed()}`,
            `/uf=${this.userDir}`,
            `/m=${targetAndOsModules.join(",")}`,
            `--`,
            `Runtime`,
            `Install`,
            this.targetRuntime
          );
          core.info(this.igorExecutable);
          core.info(args.join("\n"));
          core.info([this.igorExecutable, args.join(" ")].join(" "));
          external_child_process_default().spawnSync(
            this.igorExecutable,
            args,
            {
              stdio: "inherit",
              cwd: external_path_default().dirname(this.igorExecutable),
            }
          );
          this.targetModules = targetAndOsModules;
        } else {
          core.info("Runtime is already installed!");
        }
      }
      this.checkFfmpeg();
      this.targetRuntimeDir = external_path_default().join(
        this.runtimeDir,
        `runtime-${this.targetRuntime}`
      );
      if ((0, external_os_.platform)() !== "win32") {
        this.postInstall();
      }
    }
    modulesAreInstalled(modules) {
      const runtimeReceiptPath = external_path_default().join(
        this.runtimeDir,
        `runtime-${this.targetRuntime}`,
        "receipt.json"
      );
      if (!lib_default().existsSync(runtimeReceiptPath)) {
        return false;
      }
      for (const module of modules) {
        const requiredModules = this._getRequiredModules(module);
        const downloadedModules = Object.keys(
          lib_default().readJSONSync(runtimeReceiptPath)
        );
        if (!requiredModules.every((i) => downloadedModules.includes(i))) {
          return false;
        }
      }
      return true;
    }
    _runtimeExists(runtimeUrl) {
      const args = [];
      args.push(
        `/rp=${this.runtimeDir}`,
        `/ru=${runtimeUrl}`,
        `/uf=${this.userDir}`,
        `--`,
        `Runtime`,
        `Info`,
        this.targetRuntime
      );
      const cmd = this.igorExecutable;
      const res = external_child_process_default().spawnSync(cmd, args, {
        cwd: external_path_default().dirname(cmd),
      });
      const output = res.output.toString();
      core.info(output);
      return output.includes(this.targetRuntime);
    }
    /**
     * @description Create a working dir where the local_settings is copied to. The local_settings file will also point to the temp and cache dir.
     */
    _populateUserDir() {
      lib_default().writeJsonSync(
        this.workingDirLocalSettings,
        this._createLocalSettings()
      );
      let devicesJsonContent = { mac: {} };
      if (this.devicesSettingsFile) {
        core.info(`Using devices settings file: ${this.devicesSettingsFile}`);
        const fileContent = lib_default().readJsonSync(
          this.devicesSettingsFile
        );
        devicesJsonContent = fileContent;
      }
      lib_default().writeJsonSync(this.workingDirDevices, devicesJsonContent);
    }
    _createLocalSettings() {
      const defaultLocalSettings = {
        "machine.Platform Settings.Windows.visual_studio_path":
          "C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\Tools\\VsDevCmd.bat", //See https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md#visual-studio-enterprise-2022
        "machine.Platform Settings.Android.Paths.jdk_location":
          process.env.JAVA_HOME_11_X64,
        "machine.Platform Settings.Android.Paths.sdk_location":
          process.env.ANDROID_SDK_ROOT,
        "machine.Platform Settings.Android.Paths.ndk_location":
          process.env.ANDROID_NDK_ROOT,
        "machine.Platform Settings.Android.Packaging.full_install": false,
        "machine.Platform Settings.Android.Packaging.package_install": false,
        "machine.Platform Settings.iOS.suppress_build": true,
        "cloud.General Settings.Compiling.UseSubstForDrivePaths": false,
        "machine.Platform Settings.Android.max_heap_size": 16,
        "machine.General Settings.Paths.IDE.TempFolder": this.tempDir,
        "machine.General Settings.Paths.IDE.AssetCacheFolder": this.cacheDir,
        runtimeDir: this.runtimeDir,
        userDir: this.userDir,
        targetRuntime: this.targetRuntime,
      };
      const localSettings = defaultLocalSettings;
      if (this.localSettingsFile) {
        if (!lib_default().existsSync(this.localSettingsFile)) {
          core.warning(
            `Local settings file does not exist: ${this.localSettingsFile}`
          );
        } else {
          core.info(`Using local settings file: ${this.localSettingsFile}`);
          const fileContent = lib_default().readJsonSync(
            this.localSettingsFile
          );
          Object.assign(localSettings, fileContent);
        }
      }
      return localSettings;
    }
    _getRequiredOsModule() {
      const versionParts = this._getVersionParts(this.targetRuntime);
      const major = parseInt(versionParts.major);
      if (major >= 2023) {
        let os;
        switch ((0, external_os_.platform)()) {
          case "win32":
            os = "windows";
            break;
          case "darwin":
            os = "osx";
            break;
          case "linux":
            os = "linux";
            break;
        }
        const baseOsModule = `base-module-${os}-${process.arch}`;
        return baseOsModule;
      } else {
        return undefined;
      }
    }
    _getRequiredModules(targetPlatform) {
      const platformLower = targetPlatform.toLocaleLowerCase();
      let requiredModules;
      switch (platformLower) {
        case "android":
          requiredModules = ["android"];
          break;
        case "windows":
          requiredModules = ["windows", "windowsYYC"];
          break;
        case "mac":
          requiredModules = ["mac", "macYYC"];
          break;
        case "ios":
          requiredModules = ["ios"];
          break;
        case "linux":
          requiredModules = ["linux", "linuxYYC"];
          break;
        default:
          throw new Error(`${targetPlatform} is not supported!`);
      }
      const requiredOsModule = this._getRequiredOsModule();
      if (requiredOsModule) {
        requiredModules.push(requiredOsModule);
      }
      requiredModules.push("base");
      return requiredModules;
    }
    _inferFeed() {
      let feed = "https://gms.yoyogames.com/Zeus-Runtime-NuBeta.rss";
      if (!this._runtimeExists(feed)) {
        feed = "https://gms.yoyogames.com/Zeus-Runtime-NuBeta-I.rss";
        if (!this._runtimeExists(feed)) {
          feed = "https://gms.yoyogames.com/Zeus-Runtime.rss";
          if (!this._runtimeExists(feed)) {
            if (!this._runtimeExists(feed)) {
              feed = "https://gms.yoyogames.com/Zeus-Runtime-LTS.rss";
              if (!this._runtimeExists(feed)) {
                throw "Runtime does not exist in GameMaker's RSS feed!";
              }
            }
          }
        }
      }
      //Cache busting by adding day and hour to the feed url
      const date = new Date();
      const day = date.getDay();
      const hour = date.getHours();
      const cacheBustingPostfix = `?day=${day}&hour=${hour}`;
      return feed + cacheBustingPostfix;
    }
    _getVersionParts(version) {
      const versionParts = version.split(".");
      return {
        major: versionParts[0],
        minor: versionParts[1],
        patch: versionParts[2],
        revision: versionParts[3],
      };
    }
    checkFfmpeg() {
      const ffmpegPath = external_path_default().join(
        this.runtimeDir,
        `runtime-${this.targetRuntime}`,
        "bin",
        "ffmpeg"
      );
      if (!lib_default().existsSync(ffmpegPath)) {
        core.warning("Runtime is missing ffmpeg!");
      }
    }
    postInstall() {
      const targetRuntimeBinDir = external_path_default().join(
        this.targetRuntimeDir,
        "bin"
      );
      let postInstallScript = "linux-post-install.sh";
      if ((0, external_os_.platform)() === "darwin") {
        postInstallScript = "mac-post-install.sh";
      }
      const postInstallSh = external_path_default().join(
        targetRuntimeBinDir,
        postInstallScript
      );
      if (lib_default().existsSync(postInstallSh)) {
        core.info("Running post install scripts.");
        lib_default().chmodSync(postInstallSh, 0o777);
        external_child_process_default().spawnSync("sh", [postInstallSh], {
          stdio: "inherit",
          cwd: this.targetRuntimeDir,
        });
      }
      const versionParts = this._getVersionParts(this.targetRuntime);
      const major = parseInt(versionParts.major);
      const minor = parseInt(versionParts.minor);
      if (
        ((minor > 2 && minor < 100) || (minor >= 100 && minor < 300)) &&
        major < 2023 &&
        (0, external_os_.platform)() === "linux"
      ) {
        //Linux is case sensitive, and the compiler uses Capital `Android` for some older runtimes.
        const androidPath = external_path_default().join(
          this.targetRuntimeDir,
          "android"
        );
        if (lib_default().existsSync(androidPath)) {
          const androidNewPath = external_path_default().join(
            this.targetRuntimeDir,
            "Android"
          );
          lib_default().renameSync(androidPath, androidNewPath);
        }
      }
      if ((0, external_os_.platform)() === "darwin") {
        const optimizeSh = external_path_default().join(
          targetRuntimeBinDir,
          "mac-optimise-runtime.sh"
        );
        if (lib_default().existsSync(optimizeSh)) {
          core.info("Running mac optimize runtime scripts.");
          lib_default().chmodSync(optimizeSh, 0o777);
          external_child_process_default().spawnSync("sh", [optimizeSh], {
            stdio: "inherit",
            cwd: this.targetRuntimeDir,
          });
        }
      }
      const png_crush_dir = external_path_default().join(
        targetRuntimeBinDir,
        "pngcrush"
      );
      if (lib_default().existsSync(png_crush_dir)) {
        lib_default().chmodSync(png_crush_dir, 0o777);
      }
    }
  } // CONCATENATED MODULE: ./src/index.ts

  async function run() {
    try {
      const accessKey = core.getInput("access-key");
      let targetRuntime = core.getInput("runtime-version");
      const targetYyp = core.getInput("target-yyp");
      if (targetRuntime && targetYyp) {
        core.info(
          "Both runtime-version and target-yyp are specified. Using runtime-version."
        );
      } else if (!targetRuntime && !targetYyp) {
        throw new Error(
          "You must specify either runtime-version or target-yyp"
        );
      } else if (targetYyp) {
        core.info(`Inferring runtime from target-yyp: ${targetYyp}`);
        targetRuntime = await IgorSetup.getRuntimeBasedOnYyp(targetYyp);
      }
      const localSettingsOverrideFile = core.getInput(
        "local-settings-override-file"
      );
      const devicesOverrideFile = core.getInput(
        "devices-settings-override-file"
      );
      const targetModulesFromInputModule = core.getInput("module");
      const targetModulesFromInputModules = core.getInput("modules");
      if (targetModulesFromInputModule && targetModulesFromInputModules) {
        throw new Error(
          "Both `module` and `modules` are specified. You must specify only one."
        );
      }
      const targetModules =
        targetModulesFromInputModule || targetModulesFromInputModules;
      const targetModulesSplitAsArray = targetModules
        ? targetModules.split(",")
        : undefined;
      const igorSetup = new IgorSetup(
        accessKey,
        targetRuntime,
        localSettingsOverrideFile,
        devicesOverrideFile
      );
      await igorSetup.ensureIgorBootStrapperBasedOnOs();
      igorSetup.installModules(targetModulesSplitAsArray);
      core.info(`Installed modules: ${igorSetup.targetModules.join(",")}`);
      core.info(`For runtime: ${targetRuntime}`);
      core.setOutput("cache-dir", igorSetup.cacheDir);
      core.setOutput("temp-dir", igorSetup.tempDir);
      core.setOutput("runtime-dir", igorSetup.targetRuntimeDir);
      core.setOutput("user-dir", igorSetup.userDir);
      core.setOutput("settings-dir", igorSetup.workingDirLocalSettings);
      core.setOutput("bootstrapper-dir", igorSetup.bootstrapperDir);
    } catch (err) {
      core.setFailed(err.message);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  run();
})();

var __webpack_exports__run = __webpack_exports__.K;
export { __webpack_exports__run as run };
